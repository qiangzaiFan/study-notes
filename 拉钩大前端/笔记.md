# JavaScript 深度剖析

## 函数式编程

### 为什么要学习函数式编程以及什么是函数式编程

#### 为什么要学习函数式编程？

- 函数式编程随着React的流星受到越来越多的关注
- Vue3也开始拥抱函数式编程
- 函数式编程可以抛弃this
- 打包过程中可以更好的利用tree shaking过滤无用代码
- 方便测试，方便并行处理
- 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda

#### 什么是函数式编程

函数式编程(Functional Programming, FP)是编程范式之一，我们常听说的编程范式还有面向过程编程、面向对象编程。

- 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
- 函数式编程的思维方式：把现实世界的事物和事物之间的**联系**抽象到程序世界（对运算过程进行抽象）
- x->f(联系、映射)->y,y=f(x)
- **函数式编程中的函数指的不是程序中的函数（方法）**，而是数学中的函数即映射关系，例如：**y=sin(x)**,x和y的关系
- **相同的输入始终要得到相同的输出**（纯函数）
- 函数式编程用来描述数据（函数）之间的映射
- 函数式编程的一个好处就是可以让代码进行重用

- 



#### 函数是一等公民

- 函数可以存储在变量中

- 在JavaScript 中函数就是一个普通的对象（可以通过new Function()）,我们可以把函数存储到变量、数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过new Function('alert(1)')来构造一个新的函数。

- 代码

  ```javascript
  // 把函数赋值给变量
  let fn = function () {
    console.log(Hello First-class Function);
  };
  fu();
  
  // 一个示例
  
  const BlogController = {
    index(posts){return Views.index(posts)},
    show(post){return Views.show(post)},
    create(attrs){return Db.create(attrs)},
    update(post,attrs){return Db.update(post,attrs)},
    destroy(post){return Db.destroy(post)},
  }
  
  // 优化
  // 一个函数包裹另一个函数，并且它的形式也相同的时候，可以优化，就是正常的简写
  const BlogController = {
    index:Views.index,
    show:Views.show,
    create:Db.create,
    update:Db.update,
    destroy:Db.destroy,
  }
  
  ```

  

- 函数是一等公民是我们后面要学习的高阶函数、柯里化等的基础。



#### 高阶函数

- 什么是高阶函数

  - 高阶函数（Higher-order function）

    - 可以把函数作为参数传递给另一个函数
    - 可以把函数作为另一个函数的返回结果
    - React中有一个概念，Higher-order-component,本质上就是高阶函数

  - 函数作为参数

    ```javascript
    // 高阶函数-函数作为参数
    function forEach(array, fn) {
      for (let index = 0; index < array.length; index++) {
        fn(array[index]);
      }
    }
    let numberList = [1, 3, 5, 6, 7, 8];
    // forEach(numberList, function (value) {
    //   console.log(value);
    // });
    
    function filter(array, fn) {
      let results = [];
      for (let index = 0; index < array.length; index++) {
        if (fn(array[index])) {
          results.push(array[index]);
        }
      }
      return results;
    }
    
    let res = filter(numberList, function (value) {
      return value % 2 === 0;
    });
    
    console.log(res);
    
    ```

    - 更加灵活了

  - 函数作为返回值

    - 代码

      ```javascript
      function makeFn() {
        let msg = "hello function";
        return function () {
          console.log(msg);
        };
      }
      // const fn = makeFn();
      // console.log(fn());
      
      // makeFn()();
      
      // jQuery中有一个once函数，Lodash中也有一个这个函数。目的是为了让函数只调用一次，使用场景例如：支付的时候，无论点击多少次，就只能调用一次。
      
      function once(fn) {
        let done = false;
        return function () {
          if (!done) {
            done = true;
            return fn.apply(this, arguments);
          }
        };
      }
      
      let pay = once(function (money) {
        console.log("---支付,", money + "元");
      });
      
      pay(4);
      
      ```

      

    - 

- 使用高阶函数的意义

  - 抽象可以帮助我们屏蔽细节，只需要关注与我们的目标
  - 高阶函数是用来抽象通用的问题
  - 
    - ![image-20220507085540681](%E7%AC%94%E8%AE%B0.assets/image-20220507085540681.png)
  - 

- 常见的高阶函数（比如 map、every、some）

  - ```javascript
    // map every some 高阶函数实现
    
    // map
    let arr = [1, 2, 3, 5, 7, 8];
    function map(array, fn) {
      let results = [];
      for (let item of array) {
        results.push(fn(item));
      }
      return results;
    }
    
    // console.log(map(arr, (v) => v * v));
    
    // every
    function every(array, fn) {
      let flag = false;
      for (let item of array) {
        flag = fn(item);
        if (!flag) {
          break;
        }
      }
      return flag;
    }
    // console.log(every(arr, (v) => v > 3));
    
    // some
    function some(array, fn) {
      let flag = false;
      for (let item of array) {
        flag = fn(item);
        if (flag) {
          break;
        }
      }
      return flag;
    }
    
    console.log(some(arr, (v) => v > 3));
    
    ```

  - 

- 



#### 闭包

- 闭包（Closure）:函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包。
  - 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。
  - 
    - ![image-20220509011225249](%E7%AC%94%E8%AE%B0.assets/image-20220509011225249.png)
    - ![image-20220509011300349](%E7%AC%94%E8%AE%B0.assets/image-20220509011300349.png)
    -  
  - 闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。

##### 闭包-案例

- call Stack 调用栈 Scope作用域，进入makePower方法的时候，makePower函数进入栈顶，Local是这个函数内部的局部作用域， this指向的是window,
  - ![image-20220517215606890](%E7%AC%94%E8%AE%B0.assets/image-20220517215606890.png)
  - 当一个函数执行完之后，这个函数会在调用栈上移除掉
    - ![image-20220517215933417](%E7%AC%94%E8%AE%B0.assets/image-20220517215933417.png)
  - Closure闭包
    - ![image-20220517220139252](%E7%AC%94%E8%AE%B0.assets/image-20220517220139252.png)

#### 纯函数概念

- 纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

- 概念

  - ![image-20220517221141561](%E7%AC%94%E8%AE%B0.assets/image-20220517221141561.png)

  - 例子

    ```javascript
    // 纯函数和不纯的函数
    // slice / splice
    
    let array = [1, 2, 3, 4, 5];
    
    // 纯函数
    console.log(array.slice(0, 3));
    console.log(array.slice(0, 3));
    console.log(array.slice(0, 3));
    
    // 不纯的函数
    console.log(array.splice(0, 3));
    console.log(array.splice(0, 3));
    console.log(array.splice(0, 3));
    
    // 纯函数
    
    function getSum(n1, n2) {
      return n1 + n2;
    }
    console.log(getSum(1, 2));
    console.log(getSum(1, 2));
    console.log(getSum(1, 2));
    ```

    

  - 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的） 

  - 我们可以把一个函数的执行结果交给另一个函数去处理

#### Lodash

1. 初始化一个package.json
   npm init -y

2. 加载lodash 插件
   npm install lodash  或者 npm i lodash

3. 代码

   ```javascript
   // 演示lodash
   // first / last / toUpper / reverse /each /includes /find /findIndex
   const _ = require("lodash");
   
   const array = ["jack", "tom", "lucky", "kate"];
   
   console.log(_.first(array));
   console.log(_.last(array));
   console.log(_.toUpper(_.first(array)));
   console.log(_.reverse(array));
   console.log(
     _.each(array, (item, index) => {
       console.log(item, index);
     })
   );
   
   ```

   

4. 

#### 纯函数的好处

- 可缓存
  - 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来，比如我们有某个函数，这个函数执行起来特别耗时，每次调用这个函数的时候都要等一段时间才能获取到这个结果，我们想提交这个性能的话，可以把第一次的结果缓存起来。第二次调用的时候，直接拿这个结果。
    
    - 
    
  - 自己模拟一个memoize函数
  
    ```javascript
    // 记忆函数
    const _ = require("lodash");
    
    function getArea(r) {
      console.log(r);
      return Math.PI * r * r;
    }
    
    // let getAreaWithMemory = _.memoize(getArea);
    // console.log(getAreaWithMemory(4));
    // console.log(getAreaWithMemory(4));
    // console.log(getAreaWithMemory(4));
    
    //模拟memoize 方法的实现
    function memoize(f) {
      let cash = {};
      return function () {
        console.log("---arguments,", arguments, JSON.stringify(arguments));
        let key = JSON.stringify(arguments);
        cash[key] = cash[key] || f.apply(f, arguments);
        console.log("---cash,", cash);
        return cash[key];
      };
    }
    
    let getAreaWithMemory = memoize(getArea);
    console.log(getAreaWithMemory(4));
    console.log(getAreaWithMemory(4));
    console.log(getAreaWithMemory(4));
    
    ```
  
  - 其他有点
  
    - 可测试
      - 纯函数让测试更方便,因为纯函数始终有输入和输出，因为单元测试始终在调研这个函数的结果。
    - 并行处理
      - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
      - 纯函数不需要访问共享的内存数据（比如全局变量），所以并行环境下可以任意运行纯函数（Web worker），多数时候我们使用js的单线程去处理，ES6有一个Web worker多线程。
    - 
  
  - 
- 

#### 副作用

- 纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

  ```javascript
  // 不纯
  let mini = 18;
  
  function getAge(age) {
    return age > mini;
  }
  
  // 纯的，有硬编码，后续可以用柯里化来解决
  function checkAge(age) {
    let mini = 18;
    return age > mini;
  }
  ```

  

- 副作用会让一个函数变得不纯（如上例），纯函数根据相同的输入返回相同的输出，如果函数依赖外部的状态就无法保证输出相同，就会带来副作用。

- 副作用来源：

  - 配置文件
  - 数据库
  - 获取用户的输入
  - 。。。。。。

- 所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合拓展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

- 

#### 柯里化 （Haskell Brooks Curry）

- 使用柯里化解决上一个案例中硬编码的问题

  ```javascript
  // // 普通的纯函数
  // function checkAge(min, age) {
  //   return age >= min;
  // }
  // console.log(checkAge(18, 20));
  // console.log(checkAge(18, 24));
  // console.log(checkAge(22, 24));
  
  // 函数的柯里化
  // function checkAge(min) {
  //   return function (age) {
  //     return age >= min;
  //   };
  // }
  
  // 箭头函数改写
  
  const checkAge = (min) => (age) => age >= min;
  
  let checkAge18 = checkAge(18);
  let checkAge20 = checkAge(20);
  
  console.log(checkAge18(22));
  console.log(checkAge18(24));
  console.log(checkAge18(13));
  
  ```

  

- 柯里化（Curring）:

  - 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
  - 然后返回一个新的函数接收剩余的参数，返回结果

- 

#### Lodash中的柯里化

- _.curry(func)

  - 功能：创建一个函数，该函数接收 `func` 的参数，要么调用`func`返回的结果，如果 `func` 所需参数已经提供，则直接返回 `func` 所执行的结果。或返回一个函数，接受余下的`func` 参数的函数，可以使用 `func.length` 强制需要累积的参数个数。
  - 参数：需要柯里化的函数
  - 返回值：柯里化后的函数

- 代码

  ```javascript
  // // lodash 中curry的基本使用
  const _ = require("lodash");
  function getSum(a, b, c) {
    return a + b + c;
  }
  const curried = _.curry(getSum);
  console.log(curried(1, 2, 3));
  console.log(curried(1)(2, 3));
  console.log(curried(1, 2)(3));
  
  ```

  

- 

#### 柯里化案例

- 代码

  ```javascript
  // 柯里化案例
  // "".match(/\s+/g);
  // "".match(/\d+/g);
  
  const _ = require("lodash");
  
  // 普通方法匹配
  // function matchStr(reg, str) {
  //   return str.match(reg);
  // }
  
  // 使用柯里化的方式
  const match = _.curry(function (reg, str) {
    return str.match(reg);
  });
  
  const haveSpace = match(/\s+/g);
  const haveNumber = match(/\d+/g);
  
  // 会把空白字符给提取出来，返回一个数组的形式 [ ' ' ]
  // console.log(haveSpace("hello world"));
  // // 没有空格， 没有匹配到，返回null
  // console.log(haveSpace("helloworld"));
  // console.log(haveNumber("abc"));
  
  // 写一个filter的柯里化函数
  const filter = _.curry(function (fun, array) {
    return array.filter(fun);
  });
  
  console.log(filter(haveSpace, ["ab c", "ab_c"]));
  
  // 另一种写法
  
  const filterSpace = filter(haveSpace);
  console.log(filterSpace(["ab c", "ab_c"]));
  
  ```

  

- 

#### 柯里化原理模拟

- 代码

  ```javascript
  // 模拟实现lodash中的curry方法
  const _ = require("lodash");
  function getSum(a, b, c) {
    return a + b + c;
  }
  const curried = _.curry(getSum);
  console.log(curried(1, 2, 3));
  console.log(curried(1)(2, 3));
  console.log(curried(1, 2)(3));
  
  function curry(func) {
    return function curried(...args) {
      if (args.length < func.length) {
        return function () {
          return curried(...args.concat(Array.from(arguments)));
        };
      }
      return func(...args);
    };
  }
  
  const curriedmoni = curry(getSum);
  console.log(curriedmoni(1, 2, 3));
  console.log(curriedmoni(1)(2, 3));
  console.log(curriedmoni(1, 2)(3));
  
  ```

  

- 

#### 柯里化总结

#### 函数组合概念







### 函数式编程的特性（纯函数、柯里化、函数组合等）

### 函数式编程的应用场景

### 函数式编程库 Lodash

## 

# 前端工程化实战

# Vue.js 框架源码与进阶

# React 框架原理与实战

# Node.js 全栈开发

# 泛客户端开发

# 商业技术解决方案与高阶技术

# 