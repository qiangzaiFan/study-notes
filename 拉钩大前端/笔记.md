# JavaScript 深度剖析

## 函数式编程

### 为什么要学习函数式编程以及什么是函数式编程

#### 为什么要学习函数式编程？

- 函数式编程随着React的流行受到越来越多的关注
- Vue3也开始拥抱函数式编程
- 函数式编程可以抛弃this
- 打包过程中可以更好的利用tree shaking过滤无用代码
- 方便测试，方便并行处理
- 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda

#### 什么是函数式编程

函数式编程(Functional Programming, FP)是编程范式之一，我们常听说的编程范式还有面向过程编程、面向对象编程。

- 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
- 函数式编程的思维方式：把现实世界的事物和事物之间的**联系**抽象到程序世界（对运算过程进行抽象）
- x->f(联系、映射)->y,y=f(x)
- **函数式编程中的函数指的不是程序中的函数（方法）**，而是数学中的函数即映射关系，例如：**y=sin(x)**,x和y的关系
- **相同的输入始终要得到相同的输出**（纯函数）
- 函数式编程用来描述数据（函数）之间的映射
- 函数式编程的一个好处就是可以让代码进行重用

- 



#### 函数是一等公民

- 函数可以存储在变量中

- 在JavaScript 中函数就是一个普通的对象（可以通过new Function()）,我们可以把函数存储到变量、数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过new Function('alert(1)')来构造一个新的函数。

- 代码

  ```javascript
  // 把函数赋值给变量
  let fn = function () {
    console.log(Hello First-class Function);
  };
  fu();
  
  // 一个示例
  
  const BlogController = {
    index(posts){return Views.index(posts)},
    show(post){return Views.show(post)},
    create(attrs){return Db.create(attrs)},
    update(post,attrs){return Db.update(post,attrs)},
    destroy(post){return Db.destroy(post)},
  }
  
  // 优化
  // 一个函数包裹另一个函数，并且它的形式也相同的时候，可以优化，就是正常的简写
  const BlogController = {
    index:Views.index,
    show:Views.show,
    create:Db.create,
    update:Db.update,
    destroy:Db.destroy,
  }
  
  ```

  

- 函数是一等公民是我们后面要学习的高阶函数、柯里化等的基础。



#### 高阶函数

- 什么是高阶函数

  - 高阶函数（Higher-order function）

    - 可以把函数作为参数传递给另一个函数
    - 可以把函数作为另一个函数的返回结果
    - React中有一个概念，Higher-order-component,本质上就是高阶函数

  - 函数作为参数

    ```javascript
    // 高阶函数-函数作为参数
    function forEach(array, fn) {
      for (let index = 0; index < array.length; index++) {
        fn(array[index]);
      }
    }
    let numberList = [1, 3, 5, 6, 7, 8];
    // forEach(numberList, function (value) {
    //   console.log(value);
    // });
    
    function filter(array, fn) {
      let results = [];
      for (let index = 0; index < array.length; index++) {
        if (fn(array[index])) {
          results.push(array[index]);
        }
      }
      return results;
    }
    
    let res = filter(numberList, function (value) {
      return value % 2 === 0;
    });
    
    console.log(res);
    
    ```

    - 更加灵活了

  - 函数作为返回值

    - 代码

      ```javascript
      function makeFn() {
        let msg = "hello function";
        return function () {
          console.log(msg);
        };
      }
      // const fn = makeFn();
      // console.log(fn());
      
      // makeFn()();
      
      // jQuery中有一个once函数，Lodash中也有一个这个函数。目的是为了让函数只调用一次，使用场景例如：支付的时候，无论点击多少次，就只能调用一次。
      
      function once(fn) {
        let done = false;
        return function () {
          if (!done) {
            done = true;
            return fn.apply(this, arguments);
          }
        };
      }
      
      let pay = once(function (money) {
        console.log("---支付,", money + "元");
      });
      
      pay(4);
      
      ```

      

    - 

- 使用高阶函数的意义

  - 抽象可以帮助我们屏蔽细节，只需要关注与我们的目标
  - 高阶函数是用来抽象通用的问题
  - 
    - ![image-20220507085540681](%E7%AC%94%E8%AE%B0.assets/image-20220507085540681.png)
  - 

- 常见的高阶函数（比如 map、every、some）

  - ```javascript
    // map every some 高阶函数实现
    
    // map
    let arr = [1, 2, 3, 5, 7, 8];
    function map(array, fn) {
      let results = [];
      for (let item of array) {
        results.push(fn(item));
      }
      return results;
    }
    
    // console.log(map(arr, (v) => v * v));
    
    // every
    function every(array, fn) {
      let flag = false;
      for (let item of array) {
        flag = fn(item);
        if (!flag) {
          break;
        }
      }
      return flag;
    }
    // console.log(every(arr, (v) => v > 3));
    
    // some
    function some(array, fn) {
      let flag = false;
      for (let item of array) {
        flag = fn(item);
        if (flag) {
          break;
        }
      }
      return flag;
    }
    
    console.log(some(arr, (v) => v > 3));
    
    ```

  - 

- 



#### 闭包

- 闭包（Closure）:函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包。
  - 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。
  - 
    - ![image-20220509011225249](%E7%AC%94%E8%AE%B0.assets/image-20220509011225249.png)
    - ![image-20220509011300349](%E7%AC%94%E8%AE%B0.assets/image-20220509011300349.png)
    -  
  - 闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。

##### 闭包-案例

- call Stack 调用栈 Scope作用域，进入makePower方法的时候，makePower函数进入栈顶，Local是这个函数内部的局部作用域， this指向的是window,
  - ![image-20220517215606890](%E7%AC%94%E8%AE%B0.assets/image-20220517215606890.png)
  - 当一个函数执行完之后，这个函数会在调用栈上移除掉
    - ![image-20220517215933417](%E7%AC%94%E8%AE%B0.assets/image-20220517215933417.png)
  - Closure闭包
    - ![image-20220517220139252](%E7%AC%94%E8%AE%B0.assets/image-20220517220139252.png)

#### 纯函数概念

- 纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

- 概念

  - ![image-20220517221141561](%E7%AC%94%E8%AE%B0.assets/image-20220517221141561.png)

  - 例子

    ```javascript
    // 纯函数和不纯的函数
    // slice / splice
    
    let array = [1, 2, 3, 4, 5];
    
    // 纯函数
    console.log(array.slice(0, 3));
    console.log(array.slice(0, 3));
    console.log(array.slice(0, 3));
    
    // 不纯的函数
    console.log(array.splice(0, 3));
    console.log(array.splice(0, 3));
    console.log(array.splice(0, 3));
    
    // 纯函数
    
    function getSum(n1, n2) {
      return n1 + n2;
    }
    console.log(getSum(1, 2));
    console.log(getSum(1, 2));
    console.log(getSum(1, 2));
    ```

    

  - 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的） 

  - 我们可以把一个函数的执行结果交给另一个函数去处理

#### Lodash

1. 初始化一个package.json
   npm init -y

2. 加载lodash 插件
   npm install lodash  或者 npm i lodash

3. 代码

   ```javascript
   // 演示lodash
   // first / last / toUpper / reverse /each /includes /find /findIndex
   const _ = require("lodash");
   
   const array = ["jack", "tom", "lucky", "kate"];
   
   console.log(_.first(array));
   console.log(_.last(array));
   console.log(_.toUpper(_.first(array)));
   console.log(_.reverse(array));
   console.log(
     _.each(array, (item, index) => {
       console.log(item, index);
     })
   );
   
   ```

   

4. 

#### 纯函数的好处

- 可缓存
  - 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来，比如我们有某个函数，这个函数执行起来特别耗时，每次调用这个函数的时候都要等一段时间才能获取到这个结果，我们想提交这个性能的话，可以把第一次的结果缓存起来。第二次调用的时候，直接拿这个结果。
    
    - 
    
  - 自己模拟一个memoize函数
  
    ```javascript
    // 记忆函数
    const _ = require("lodash");
    
    function getArea(r) {
      console.log(r);
      return Math.PI * r * r;
    }
    
    // let getAreaWithMemory = _.memoize(getArea);
    // console.log(getAreaWithMemory(4));
    // console.log(getAreaWithMemory(4));
    // console.log(getAreaWithMemory(4));
    
    //模拟memoize 方法的实现
    function memoize(f) {
      let cash = {};
      return function () {
        console.log("---arguments,", arguments, JSON.stringify(arguments));
        let key = JSON.stringify(arguments);
        cash[key] = cash[key] || f.apply(f, arguments);
        console.log("---cash,", cash);
        return cash[key];
      };
    }
    
    let getAreaWithMemory = memoize(getArea);
    console.log(getAreaWithMemory(4));
    console.log(getAreaWithMemory(4));
    console.log(getAreaWithMemory(4));
    
    ```
  
  - 其他有点
  
    - 可测试
      - 纯函数让测试更方便,因为纯函数始终有输入和输出，因为单元测试始终在调研这个函数的结果。
    - 并行处理
      - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
      - 纯函数不需要访问共享的内存数据（比如全局变量），所以并行环境下可以任意运行纯函数（Web worker），多数时候我们使用js的单线程去处理，ES6有一个Web worker多线程。
    - 
  
  - 
- 

#### 副作用

- 纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

  ```javascript
  // 不纯
  let mini = 18;
  
  function getAge(age) {
    return age > mini;
  }
  
  // 纯的，有硬编码，后续可以用柯里化来解决
  function checkAge(age) {
    let mini = 18;
    return age > mini;
  }
  ```

  

- 副作用会让一个函数变得不纯（如上例），纯函数根据相同的输入返回相同的输出，如果函数依赖外部的状态就无法保证输出相同，就会带来副作用。

- 副作用来源：

  - 配置文件
  - 数据库
  - 获取用户的输入
  - 。。。。。。

- 所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合拓展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

- 

#### 柯里化 （Haskell Brooks Curry）

- 使用柯里化解决上一个案例中硬编码的问题

  ```javascript
  // // 普通的纯函数
  // function checkAge(min, age) {
  //   return age >= min;
  // }
  // console.log(checkAge(18, 20));
  // console.log(checkAge(18, 24));
  // console.log(checkAge(22, 24));
  
  // 函数的柯里化
  // function checkAge(min) {
  //   return function (age) {
  //     return age >= min;
  //   };
  // }
  
  // 箭头函数改写
  
  const checkAge = (min) => (age) => age >= min;
  
  let checkAge18 = checkAge(18);
  let checkAge20 = checkAge(20);
  
  console.log(checkAge18(22));
  console.log(checkAge18(24));
  console.log(checkAge18(13));
  
  ```

  

- 柯里化（Curring）:

  - 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
  - 然后返回一个新的函数接收剩余的参数，返回结果

- 

#### Lodash中的柯里化

- _.curry(func)

  - 功能：创建一个函数，该函数接收 `func` 的参数，要么调用`func`返回的结果，如果 `func` 所需参数已经提供，则直接返回 `func` 所执行的结果。或返回一个函数，接受余下的`func` 参数的函数，可以使用 `func.length` 强制需要累积的参数个数。
  - 参数：需要柯里化的函数
  - 返回值：柯里化后的函数

- 代码

  ```javascript
  // // lodash 中curry的基本使用
  const _ = require("lodash");
  function getSum(a, b, c) {
    return a + b + c;
  }
  const curried = _.curry(getSum);
  console.log(curried(1, 2, 3));
  console.log(curried(1)(2, 3));
  console.log(curried(1, 2)(3));
  
  ```

  

- 

#### 柯里化案例

- 代码

  ```javascript
  // 柯里化案例
  // "".match(/\s+/g);
  // "".match(/\d+/g);
  
  const _ = require("lodash");
  
  // 普通方法匹配
  // function matchStr(reg, str) {
  //   return str.match(reg);
  // }
  
  // 使用柯里化的方式
  const match = _.curry(function (reg, str) {
    return str.match(reg);
  });
  
  const haveSpace = match(/\s+/g);
  const haveNumber = match(/\d+/g);
  
  // 会把空白字符给提取出来，返回一个数组的形式 [ ' ' ]
  // console.log(haveSpace("hello world"));
  // // 没有空格， 没有匹配到，返回null
  // console.log(haveSpace("helloworld"));
  // console.log(haveNumber("abc"));
  
  // 写一个filter的柯里化函数
  const filter = _.curry(function (fun, array) {
    return array.filter(fun);
  });
  
  console.log(filter(haveSpace, ["ab c", "ab_c"]));
  
  // 另一种写法
  
  const filterSpace = filter(haveSpace);
  console.log(filterSpace(["ab c", "ab_c"]));
  
  ```

  

- 

#### 柯里化原理模拟

- 代码

  ```javascript
  // 模拟实现lodash中的curry方法
  const _ = require("lodash");
  function getSum(a, b, c) {
    return a + b + c;
  }
  const curried = _.curry(getSum);
  console.log(curried(1, 2, 3));
  console.log(curried(1)(2, 3));
  console.log(curried(1, 2)(3));
  
  function curry(func) {
    return function curried(...args) {
      if (args.length < func.length) {
        return function () {
          return curried(...args.concat(Array.from(arguments)));
        };
      }
      return func(...args);
    };
  }
  
  const curriedmoni = curry(getSum);
  console.log(curriedmoni(1, 2, 3));
  console.log(curriedmoni(1)(2, 3));
  console.log(curriedmoni(1, 2)(3));
  
  ```

  

- 

#### 柯里化总结

- 总结
  - ![image-20220523212812664](%E7%AC%94%E8%AE%B0.assets/image-20220523212812664.png)
- 

#### 函数组合概念

- 函数组合

  - ![image-20220523212934993](%E7%AC%94%E8%AE%B0.assets/image-20220523212934993.png)

- 管道

  - ![image-20220523213106562](%E7%AC%94%E8%AE%B0.assets/image-20220523213106562.png)
  - 

- 函数组合

  - 函数组合（compose）:如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
    - 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果。
    - 函数组合默认是从右到左执行
  - 

- 代码

  ```javascript
  // 函数组合
  function compose(f, g) {
    return function (value) {
      return f(g(value));
    };
  }
  
  function reverse(array) {
    return array.reverse();
  }
  function first(array) {
    return array[0];
  }
  
  const last = compose(first, reverse);
  console.log(last([1, 2, 3, 4]));
  
  ```

  



#### Lodash 中的组合函数

- lodash中的组合函数

  - lodash中的组合函数flow()或flowRight(),他们都可以组合多个函数
  - flow() 是从左到右运行
  - flowRight()是从右到左运行，使用的更多一些

- 代码

  ```javascript
  // lodash中函数组合方法 _.flowRight()
  const _ = require("lodash");
  const reverse = (arr) => arr.reverse();
  const first = (arr) => arr[0];
  const upperCase = (s) => s.toUpperCase();
  const compose = _.flowRight(upperCase, first, reverse);
  
  console.log(compose(["one", "two", "three", "four"]));
  ```

  

- 

#### 函数组合的实现原理

- 代码

  ```javascript
  // 模拟lodash中的flowRight
  const _ = require("lodash");
  const reverse = (arr) => arr.reverse();
  const first = (arr) => arr[0];
  const upperCase = (s) => s.toUpperCase();
  // const f = _.flowRight(upperCase, first, reverse);
  // console.log(f(["one", "two", "three"]));
  
  function compose(...args) {
    return function (value) {
      return args.reverse().reduce((acc, fn) => {
        return fn(acc);
      }, value);
    };
  }
  let f = compose(upperCase, first, reverse);
  console.log(f(["one", "two", "three"]));
  
  ```

  

- 

#### 函数组合-结合律

- 代码

  ```javascript
  // lodash中函数组合方法 _.flowRight()
  const _ = require("lodash");
  
  // const f = _.flowRight(_.upperCase, _.first, _.reverse);
  // const f = _.flowRight(_.flowRight(_.upperCase, _.first), _.reverse);
  const f = _.flowRight(_.upperCase, _.flowRight(_.first, _.reverse));
  
  console.log(f(["one", "two", "three", "four"]));
  
  ```

  

- 

#### 函数组合-调试

- 调试

  - 如何调试组合函数

- 代码

  ```javascript
  // 函数组合 调试
  // NEVER SAY DIE --> never-say-die
  
  const { flowRight } = require("lodash");
  const _ = require("lodash");
  
  // const log = (v) => {
  //   console.log(v);
  //   return v;
  // };
  
  const trace = _.curry((tag, v) => {
    console.log(tag, v);
    return v;
  });
  
  // _.split()
  const split = _.curry((sep, str) => _.split(str, sep));
  
  // _.toLower()
  
  const join = _.curry((sep, array) => _.join(array, sep));
  const map = _.curry((fn, array) => _.map(array, fn));
  // 我们需要返回的是数组，
  const f = flowRight(
    join("-"),
    trace("map之后"),
    map(_.toLower),
    trace("split之后"),
    split(" ")
  );
  // const f = flowRight(join("-"), log, _.toLower, split(" "));
  
  console.log(f("NEVER SAY DIE"));
  
  ```

  

- 

#### Lodash-fp模块

- lodash/fp

  - lodash的fp模块提供了实用的对函数式编程友好的方法

  - 提供了不可变auto-curried iteratee-first data-last 的方法 （函数优先，数据滞后）

  - lodash 模块 与 lodash/fp模块 比对

    - ![image-20220528192202388](%E7%AC%94%E8%AE%B0.assets/image-20220528192202388.png)

  - 代码,可以与之前lodash写的做比对

    ```javascript
    // lodash 中的fp模块
    // NEVER SAY DIE --> never-say-die
    
    const fp = require('lodash/fp')
    
    const f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '))
    
    console.log(f('NEVER SAY DIE'))
    
    ```

    

  - 

- 

  

#### Lodash中的FP模块，map方法的区别

- 代码, 二进制的数字只有0 1

  ```javascript
  // lodash 和 lodash中的fp模块，map方法的区别
  // 小技巧，vscode，输入方法（）的时候，能看到方法需要传入的参数，iteratee 是函数的意思
  
  const _ = require('lodash')
  
  // 打印的值为 [ 23, NaN, 2 ]，为什么会这样，因为parseInt 的第二个参数是转化进制，
  console.log(_.map(['23', '8', '10'], parseInt))
  // 模拟上面函数parseInt的执行，0是10进制，1没有这个定义，2是二进制，所以打印出NaN
  // parseInt('23',0,array)
  // parseInt('8',1,array)
  // parseInt('10',2,array)
  
  const fp = require('lodash/fp')
  // [ 23, 8, 10 ],打印出正常的值，这个fp中的parseInt 只需要处理数组中的每一个元素，lodash中的parseInt的方法需要传入3个参数
  console.log(fp.map(parseInt, ['23', '8', '10']))
  
  ```

  

- 经典面试题

  ```javascript
  ["1", "2", "3"].map(parseInt)
  
  首先， map接受两个参数， 一个回调函数 callback， 一个回调函数的this值
  其中回调函数接受三个参数 currentValue， index， arrary;
  而题目中， map只传入了回调函数--parseInt.
  其次， parseInt 只接受两个两个参数 string， radix(基数).
  在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：
  如果字符串 string 以"0x"或者"0X"开头， 则基数是16 (16进制).
  如果字符串 string 以"0"开头， 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
  如果字符串 string 以其它任何值开头，则基数是10 (十进制)。
  所以本题即问
  parseInt('1', 0);
  parseInt('2',1);
  parseInt('3', 2);
  首先后两者参数不合法.
  所以答案是 [1, NaN, NaN]
  
  ```

  

- 

#### Point Free

- Point Free:我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

  - 不需要指明处理的数据
  - 只需要合成运算过程
  - 需要定义一些辅助的基本运算函数
  - 案例演示
    - ![image-20220529013454194](%E7%AC%94%E8%AE%B0.assets/image-20220529013454194.png)
  - 

- 代码

  ```javascript
  // point free
  // Hello   World --> hello_world
  
  // 非 point free 模式
  const _ = require('lodash')
  const fp = require('lodash/fp')
  
  const compoise = word => {
    return word.toLowerCase().replace(/\s+/g, '_')
  }
  console.log(compoise('Hello   World'))
  
  // point free 模式
  
  const f = fp.flowRight(fp.replace(/\s+/g, '_'), fp.toLower)
  console.log(f('Hello   World'))
  
  ```

  

- 

#### Pointfree 案例

- 代码

  ```javascript
  // 把一个字符串中的首字母提取并转换成大写，使用 . 作为分隔符
  // world wild web --> W. W. W
  
  const fp = require('lodash/fp')
  
  // 这边使用了两次fp.map，做了两次循环，我们能不能只做一次循环
  // const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.first), fp.map(fp.toUpper), fp.split(' '))
  
  const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(' '))
  console.log(firstLetterToUpper('world wild web'))
  
  ```

  

- 

#### Functor(函子)

- 为什么要学函子

  - 到目前为止已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。

- 什么是Functor

  - 容器：包含值和值的变形关系（这个变形关系就是函数）
  - 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理（变形关系）

- 代码

  ```javascript
  // Functor 函子
  
  // class Container {
  //   constructor(value) {
  //     this._value = value
  //   }
  
  //   map(fn) {
  //     return new Container(fn(this._value))
  //   }
  // }
  
  // 调用的时候不像函数式编程，像面向对象，所以创建static 静态方法内部使用构造函数创建对象
  // let r = new Container(5).map(x => x + 1).map(x => x * x)
  
  // console.log(r)
  
  class Container {
    static of(value) {
      return new Container(value)
    }
    constructor(value) {
      this._value = value
    }
    map(fn) {
      return Container.of(fn(this._value))
    }
  }
  
  let r = Container.of(5)
    .map(x => x + 2)
    .map(x => x * x)
  console.log(r)
  
  ```

  

- 

#### Functor总结

- 总结

  - 函数式编程的运算不直接操作值，而是由函子完成
  - 函子就是一个实现了map契约的对象
  - 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
  - 想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
  - 最终map方法返回一个包含新值的盒子（函子）

- 因为纯函数相同的输入必须要有相同的输出，输入null，报错，就变得不纯了

  - 代码

    ```javascript
    class Container {
      static of(value) {
        return new Container(value)
      }
      constructor(value) {
        this._value = value
      }
      map(fn) {
        return Container.of(fn(this._value))
      }
    }
    
    // let r = Container.of(5)
    //   .map(x => x + 2)
    //   .map(x => x * x)
    // console.log(r)
    
    // 演示 null undefined 的问题
    
    // Cannot read property 'toUpperCase' of null
    Container.of(null).map(x => x.toUpperCase())
    ```

    



#### MayBe函子

- 可能会是空值的情况，我们使用MayBe函子 

- MayBe函子

  - 我们在编程的过程中可能会遇到很多错误，需要对这些错误做相对应的处理
  - MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在合理的范围内）

- 代码

  ```javascript
  // MayBe 函子
  
  class MayBe {
    static of(value) {
      return new MayBe(value)
    }
    constructor(value) {
      this._value = value
    }
  
    map(fn) {
      // 返回前对this._value进行空值判断
      return this.isNothing ? MayBe.of(null) : fn(this._value)
    }
  
    isNothing() {
      return this._value === null || this._value === undefined
    }
  }
  
  // MayBe { _value: null }
  // let r = MayBe.of('hello world').map(x => x.toUpperCase())
  
  // 会得到null的结果，但是我们不知道什么时候出现的（虽然我们可以出现空值，但是多次调用map的时候，哪一次出现空值，我们是不明确的），这个时候我们需要Either函子
  // MayBe { _value: null }
  let r = MayBe.of('hello world')
    .map(x => x.toUpperCase())
    .map(x => null)
    .map(x => x.split(' '))
  console.log(r)
  
  ```

  



#### Either函子

- Either函子

  - Either两者中的任何一个，类似于if...else...的处理
  - 异常会让函数变得不纯，Either函子可以用来做异常处理

- 代码

  ```javascript
  // Either 函子
  
  class Left {
    static of(value) {
      return new Left(value)
    }
    constructor(value) {
      this._value = value
    }
    map() {
      return this
    }
  }
  
  class Right {
    static of(value) {
      return new Right(value)
    }
    constructor(value) {
      this._value = value
    }
    map(fn) {
      return Right.of(fn(this._value))
    }
  }
  
  function parseJSON(str) {
    try {
      return Right.of(JSON.parse(str))
    } catch (e) {
      return Left.of({ error: e.message })
    }
  }
  
  // 演示错误案例
  // Left { _value: { error: 'Unexpected token n in JSON at position 1' } }
  // let r = parseJSON('{name:ds}')
  // console.log(r)
  
  // Right { _value: 'DS' }
  let r = parseJSON('{"name":"ds"}').map(x => x.name.toUpperCase())
  console.log(r)
  
  ```

  

- 

#### IO函子

- IO函子
  - IO函子中的_value 是一个函数，这里是把函数作为值来处理
  - IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作为纯函数
  - 把不纯的操作交给调用者来处理
  - 截图
    - ![image-20220529223515174](%E7%AC%94%E8%AE%B0.assets/image-20220529223515174.png)
  - 
  
- 代码

  ```javascript
  // IO 函子
  const fp = require('lodash/fp')
  
  class IO {
    static of(value) {
      return new IO(function () {
        return value
      })
    }
  
    constructor(fn) {
      this._value = fn
    }
  
    map(fn) {
      return new IO(fp.flowRight(fn, this._value))
    }
  }
  
  // 因为当前使用node 运行，有进程这个值
  let r = IO.of(process).map(p => p.execPath)
  console.log(r)
  console.log(r._value())
  
  ```

  

- 

#### Folktale

- Task异步执行

  - 异步任务的实现过于复杂，我们使用folktale中的Task来演示
  - [folktale](https://folktale.origamitower.com/)一个标准的函数式编程库
    - 和lodash、ramda不同的是，他没有提供很多功能函数
    - 只提供了一些函数式处理的操作，例如：compose、curry等，一些函子 Task、Either、MayBe等
    - ![image-20220608224938315](%E7%AC%94%E8%AE%B0.assets/image-20220608224938315.png)

- 步骤

  - npm install folktale

  - 代码

    ```javascript
    // folktale 中的compose 、 curry
    
    const { compose, curry } = require('folktale/core/lambda')
    const { first, toUpper } = require('lodash/fp')
    
    // curry 使用
    // let f = curry(2, function (x, y) {
    //   return x + y
    // })
    
    // 3 3
    // console.log(f(1, 2))
    // console.log(f(1)(2))
    
    // compose 使用
    
    // 跟lodash/fp中的flowRight一样，也是从右往左执行
    let r = compose(toUpper, first)
    // ONE
    console.log(r(['one', 'two']))
    
    ```

    

  - 

- 

#### Task函子执行异步任务

可以通过folktale官网来查看

```javascript
// Task 处理异步任务
const fs = require('fs')
const { task } = require('folktale/concurrency/task')
const { split, find } = require('lodash/fp')

function readFile(filename) {
  // task 返回的Task类型的对象
  return task(resolver => {
    fs.readFile(filename, 'utf-8', (err, data) => {
      if (err) resolver.reject(err)
      resolver.resolve(data)
    })
  })
}

readFile('package.json')
  .map(split('\n'))
  .map(find(x => x.includes('dependencies')))
  .run()
  .listen({
    onRejected: err => {
      console.log(err)
    },
    onResolved: value => {
      console.log(value)
    }
  })

```



#### d

#### e

#### 3 

### 函数式编程的特性（纯函数、柯里化、函数组合等）

### 函数式编程的应用场景

### 函数式编程库 Lodash

## 

# 前端工程化实战

### 

# Vue.js 框架源码与进阶

# React 框架原理与实战

## React基础

### React介绍

![image-20220610150144884](%E7%AC%94%E8%AE%B0.assets/image-20220610150144884.png)

React是一个用于构建用户界面的JavaScript库，它只负责应用的视图层，帮助开发人员构建快速且交互式的Web应用程序。

React使用组件的方式构建用户界面。

### JSX 语法 

在React中使用JSX语法描述用户界面，它是一种JavaScript语法拓展。

在React代码执行之前，Babel会将JSX语法转换为标准的JavaScript API。

JSX语法就是一种语法糖，让开发人员使用更加舒服的代码构建用户界面。

#### 在JSX中使用表达式

```javascript
const user = {
    firstName:'liu',
    lastName:'cao'
}
function formatName(user){
    return user.firstName + '' + user.lastName;
}
const element = <h1>Hello,{formatName(user)}</h1>;
```

JSX本身其实也是一种表达式，将它赋值给变量，当做参数传入，作为返回值都可以。

```javascript
function formatName(user){
    if(user){
        return <h1>Hello,{formatName(user)}</h1>;
       }
   return <h1>Hello,Stranger</h1>;
}
```

#### 属性

如果属性值为字符串类型，需要加引号，属性名称推荐采用驼峰式命名法。

```react
const element = <div greeting="hello"></div>;
```

如果属性值为JavaScript表达式，属性值外面加大括号。

```react
const element = <img src={user.avatarUrl} />;
// 注意大括号外面不能加引号，JSX 会将引号当中的内容识别为字符串而不是表达式
```

#### JSX 单标记必须闭合

如果 JSX 是单标记，必须闭合，否则报错。

```react
const element = <img src={user.avatarUrl} />
const element = <input type="text"/>
```

#### className

为 JSX 标记添加类名需要使用 className，而不是class。

```react
const element = <img src={user.avatarUrl} className="rounded"/>;
```

#### JSX 自动展开数组

```react
const ary = [<p>哈哈</p>, <p>呵呵</p>, <p>嘿嘿</p>];
const element = (
	<div>{ary}</div>
);
// 解析后
/*
	<div>
		<p>哈哈</p>
		<p>呵呵</p>
		<p>嘿嘿</p>
	</div>
*/
```

#### 三元运算

```react
{ boolean ? <div>Hello React</div> : null }
{ boolean && <div>Hello React</div> }
```

#### 循环

```react
const persons = [{
  id: 1,
  name: '张三',
  age: 20
}, {
  id: 2,
  name: '李四',
  age: 15
}, {
  id: 3,
  name: '王五',
  age: 22
}]
```

```react
<ul>
  { persons.map(person => <li key={person.id}> {person.name} {person.age} </li>) }
</ul>
```

#### 事件

```react
{/* 第一个参数即是事件对象 不需传递 */}
<button onClick={this.eventHandler}>按钮</button>
{/* 需要传递事件对象 */}
<button onClick={e=>this.eventHandler('arg',e)}>按钮</button>
{/* 最后一个参数即是事件对象 不需传递 */}
<button onClick={this.eventHandler.bind(null, 'arg')}>按钮</button>
```

```react
constructor () {
  this.eventHandler = this.eventHandler.bind(this)
}
eventHandler () {}
<button onClick={this.eventHandler}>按钮</button>

// 这边如果使用箭头函数就不需要在constructor里面使用bind函数
eventHandler = () => {}
```

#### 样式

项目中选择css in js方案，使用less or sass ,有一个插件 classnames ，可以写多个classname

##### 行内样式

```react
class App extends Component {
  render() {
    const style = {width: 200, height: 200, backgroundColor: 'red'};
    return <div style={style}></div>
  }
}
```

##### 外链样式

```react
// Button.js
import styles from './Button.module.css';
class Button extends Component {
  render() {
    return <button className={styles.error}>Error Button</button>;
  }
}
```

##### 全局样式

```react
import './styles.css'
```



#### ref 属性

##### createRef

```react
class Input extends Component {
  constructor() {
    super()
    this.inputRef = React.createRef()
  }
  render() {
    return (
      <div>
        <input type="text" ref={this.inputRef} />
        <button onClick={() => console.log(this.inputRef.current)}> button </button>
      </div>
    )
  }
}
```

##### 函数参数

```react
class Input extends Component {
  render() {
    return (
      <div>
        <input type="text" ref={input => (this.input = input)} />
        <button onClick={() => console.log(this.input)}>button</button>
      </div>
    )
  }
}
```

##### ref 字符串

不推荐使用，在严格模式下报错。

```react
class Input extends Component {
  render() {
    return (
      <div>
        <input type="text" ref="username" />
        <button onClick={() => console.log(this.refs.username)}>button</button>
      </div>
    )
  }
}
```

##### 获取组件实例

点击按钮让 input 文本框获取焦点。

input 文本框以及让文本框获取焦点的方法定义在 Input 组件中，在 App 组件中引入 Input 组件，按钮定义在 App 组件中。

```react
// Input.js
class Input extends Component {
  constructor() {
    super()
    this.inputRef = React.createRef()
    this.focusInput = this.focusInput.bind(this)
  }
  focusInput() {
    this.inputRef.current.focus()
  }
  render() {
    return (
      <div>
        <input type="text" ref={this.inputRef} />
      </div>
    )
  }
}
```

```react
// App.js
class App extends Component {
  constructor() {
    super()
    this.InputComponentRef = React.createRef()
  }
  render() {
    return (
      <div className="App">
        <Input ref={this.InputComponentRef} />
        <button onClick={() => this.InputComponentRef.current.focusInput()}>button</button>
      </div>
    )
}
```

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/5.gif" />

- 



### 组件

####  什么是组件

React 是基于组件的方式进行用户界面开发的. 组件可以理解为对页面中某一块区域的封装。

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/2.png" width="70%"/>

#### 创建组件

##### d创建类组件

```react
import React, { Component } from 'react';
class App extends Component {
    render () {
        return <div>Hello, 我是类组件</div>
    }
}
```

##### 创建函数组件

```react
const Person = () => {
     return <div>Hello, 我是函数型组件</div>;
}
```

**注意事项**

1. 组件名称首字母必须大写，用以区分组件和普通标签。
2. jsx语法外层必须有一个根元素

#### 组件 props

##### props 传递数据

在调用组件时可以向组件内部传递数据，在组件中可以通过 props 对象获取外部传递进来的数据。

```react
<Person name="乔治" age="20"/>
<Person name="玛丽" age="10"/>
```

```react
// 类组件
class Person extends Component {
  render() {
    return (
      <div>
        <h3>姓名：{this.props.name}</h3>
        <h4>年龄：{this.props.age}</h4>
      </div>
    );
  }
}
```

```react
// 函数组件
const Person = props => {
  return (
    <div>
      <h3>姓名：{props.name}</h3>
      <h4>年龄：{props.age}</h4>
    </div>
  );
}
```

**注意：**

1. props 对象中存储的数据是只读的，不能在组件内部被修改。
2. 当 props 数据源中的数据被修改后，组件中的接收到的 props 数据会被同步更新。( 数据驱动DOM )

##### 设置 props 默认值

```react
class App extends Component {
    static defaultProps = {}
}
```

```react
function ThemedButton(props) {
}
ThemedButton.defaultProps = {
  theme: "secondary",
  label: "Button Text"
};
```

##### 组件 children

通过 props.children 属性可以获取到在调用组件时填充到组件标签内部的内容。

```react
<Person>组件内部的内容</Person>
```

```react
const Person = (props) => {
    return (
    	<div>{props.children}</div>
    );
}
```

##### 单向数据流

1. 在React中, 关于数据流动有一条原则, 就是单向数据流动, 自顶向下, 从父组件到子组件.

2. 单向数据流特性要求我们共享数据要放置在上层组件中.

3. 子组件通过调用父组件传递过来的方法更改数据.

4. 当数据发生更改时, React会重新渲染组件树.

5. 单向数据流使组件之间的数据流动变得可预测. 使得定位程序错误变得简单.

   <img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/3.png" />

#### 类组件状态 state

##### 定义组件状态

类组件除了能够从外部 (props) 接收状态数据以外还可以拥有自己的状态 (state)，此状态在组件内部可以被更新，状态更新 DOM 更新。

组件内部的状态数据被存储在组件类中的 state 属性中，state 属性值为对象类型，属性名称固定不可更改。

```react
class App extends Component {
  constructor () {
    super()
    this.state = {
      person: { name: '张三', age: 20 },
    }
  }
  render () {
    return (
      <div>
        {this.state.person.name}
        {this.state.person.age}
      </div>
    );
  }
}
```

##### 更改组件状态

state 状态对象中的数据不可直接更改，如果直接更改 DOM 不会被更新，要更改 state 状态数据需要使用 setState方法。

```react
class App extends Component {
  constructor () {
    this.state = {
      person: { name: '张三', age: 20 },
    }
    this.changePerson = this.changePerson.bind(this)
  }
	changePerson () {
    this.setState({
      person: {
        name: '李四',
        age: 15
      }
    })
  }
  render() {
    return (
      <div>
        {this.state.person.name}
        {this.state.person.age}
        <button onClick={this.changePerson}>按钮</button>
      </div>
    );
  }
}
```

##### 双向数据绑定

双向数据绑定是指，组件类中更新了状态，DOM 状态同步更新，DOM 更改了状态，组件类中同步更新。组件 <=> 视图。

要实现双向数据绑定需要用到表单元素和 state 状态对象。

```react
class App extends Component {
  constructor () {
    this.state = {
      name: "张三"
    }
    this.nameChanged = this.nameChanged.bind(this)
  }
  nameChanged (event) {
    this.setState({name: event.target.value});
  }
  render() {
    return (
      <div>
        <div>{this.state.name}</div>
        <Person name={this.state.name} changed={this.nameChanged}/>
      </div>
    )
  }
}
```

```react
const Person = props => {
	return <input type="text" value={props.name} onChange={props.changed}/>;
}
```

#### 类组件生命周期函数

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/4.jpg"/>



在组件完成更新之前需要做某种逻辑或者计算，就需要用到快照

```react
componentDidUpdate(prevProps, prevState, snapshot) {}
```

getSnapshotBeforeUpdate 方法会在组件完成更新之前执行，用于执行某种逻辑或计算，返回值可以在 componentDidUpdate 方法中的第三个参数中获取，就是说在组件更新之后可以拿到这个值再去做其他事情。

```react
getSnapshotBeforeUpdate(prevProps, prevState) {
  return 'snapshot'
}
```

#### Context 

通过 Context 可以跨层级传递数据

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/6.png" width="70%"/>

```react
// userContext.js
import React from "react"

const userContext = React.createContext("default value")
const UserProvider = userContext.Provider
const UserConsumer = userContext.Consumer

export { UserProvider, UserConsumer }
```

```react
// App.js
import { UserProvider } from "./userContext"
class App extends Component {
  render() {
    return (
      <UserProvider value="Hello React Context">
        <A />
      </UserProvider>
    )
  }
}
```

```react
// C.js
import { UserConsumer } from "./userContext"
// username 就是UserProvider传递过来的值
export class C extends Component {
  render() {
    return (
      <div>
        <UserConsumer>
          {username => {
            return <div>{username}</div>
          }}
        </UserConsumer>
      </div>
    )
  }
}
```

context 的另一种用法

```react
// userContext.js
export default userContext
```

```react
// C.js
import userContext from "./userContext"

export class C extends Component {
  static contextType = userContext
  render() {
    return (
      <div>
        {this.context}
      </div>
    )
  }
}
```

- 

### 表单

#### 受控表单

表单控件中的值由组件的 state 对象来管理，state对象中存储的值和表单控件中的值时同步状态的

```react
class App extends Component {
  constructor () {
    this.state = { username: "" }
    this.nameChanged = this.nameChanged.bind(this)
  }
  
  nameChanged (e) {
    this.setState({username: e.target.value})
  }
  render() {
    return (
      <form>
        <p>{this.state.username}</p>
        <input type="text" value={this.state.username} onChange={this.nameChanged}/>
      </form>
    )
  }
}
```

#### 非受控表单

表单元素的值由 DOM 元素本身管理。

```react
class App extends Component {
  constructor () {
    this.onSubmit = this.onSubmit.bind(this)
  }
  onSubmit(e) {
    console.log(this.username.value)
    e.preventDefault();
  }
  render(
    <form onSubmit={this.onSubmit}>
      <input type="text" ref={username => this.username = username}/>
    </form>
  )
}
```



### 路由

url地址与组件之间的对应关系，访问不同的url地址显示不同的组件。

下载：`npm install react-router-dom`



#### 路由基本使用

```react
// App.js
import React from 'react';
import { BrowserRouter as Router, Route, Link } from 'react-router-dom';
function Index() {
	return <div>首页</div>;
}
function News() {
	return <div>新闻</div>;
}
function App() {
  return (
    <Router>
      <div>
        <Link to="/index">首页</Link>
        <Link to="/news">新闻</Link>
      </div>
      <div>
        <Route path="/index" component={Index}/>
        <Route path="/news" component={News}/>
      </div>
    </Router>
  );
}
```

#### 5.1.2 路由嵌套

```react
function News(props) {
  return (
    <div>
      <div>
        <Link to={`${props.match.url}/company`}>公司新闻</Link>
        <Link to={`${props.match.url}/industry`}>行业新闻</Link>
      </div>
      <div>
        <Route path={`${props.match.path}/company`} component={CompanyNews} />
        <Route path={`${props.match.path}/industry`} component={IndustryNews}/>  
      </div>	
    </div>
  );
}

function CompanyNews() {
	return <div>公司新闻</div>
}
function IndustryNews() {
	return <div>行业新闻</div>
}
```

#### 5.1.3 路由传参

```react
import url from 'url';
class News extends Component {
  constructor(props) {
    super(props);
    this.state = {
      list: [{
        id: 1,
        title: '新闻1'
      }, {
        id: 2,
        title: '新闻2'
      }]
    }
  }
    
  render() {
    return (
      <div>
        <div>新闻列表组件</div>
        <ul>
          this.state.list.map((item, index) => {
            return (
              <li key={index}>
                <Link to={`/detail?id=${item.id}`}>{item.title}</Link>
              </li>
            );
          })
        </ul>
      </div>
    );
  }
}
class Detail extends Component {
  constructor(props) {
    super(props);
  }
	const { query } = url.parse(this.props.location.search, true);
	console.log(query); // {id: 1}
  render() {
    return <div>新闻详情</div>
  }
}
```

#### 路由重定向

```react
import { Redirect } from 'react-router-dom';

class Login extends Component {
  render() {
    if (this.state.isLogin) {
      return <Redirect to="/"/>
    }
  }
}
```



### 

## Virtual DOM 及Diff算法

### JSX 到底是什么

使用 React 就一定会写 JSX，JSX 到底是什么呢？它是一种 JavaScript 语法的扩展，React 使用它来描述用户界面长成什么样子。虽然它看起来非常像 HTML，但它确实是 JavaScript 。在 React 代码执行之前，Babel 会对将 JSX 编译为 React API.

```react
<div className="container">
  <h3>Hello React</h3>
  <p>React is great </p>
</div>
```

```react
React.createElement(
  "div",
  {
    className: "container"
  },
  React.createElement("h3", null, "Hello React"),
  React.createElement("p", null, "React is great")
);
```

从两种语法对比来看，JSX 语法的出现是为了让 React 开发人员编写用户界面代码更加轻松。

[Babel REPL](https://babeljs.io/repl)

React 代码执行之前，Babel 会对将 JSX 编译为 React API（JSX 会被 Babel 转换为 React.createElement 方法的调用）,使用上面链接，try it out 进行尝试，左边第一个是普通JSX变量，第二个是函数组件

![image-20220610162443238](%E7%AC%94%E8%AE%B0.assets/image-20220610162443238.png)

### DOM 操作问题

在现代 web 应用程序中使用 JavaScript 操作 DOM 是必不可少的，但遗憾的是它比其他大多数 JavaScript 操作要慢的多。

大多数 JavaScript 框架对于 DOM 的更新远远超过其必须进行的更新，从而使得这种缓慢操作变得更糟。

例如假设你有包含十个项目的列表，你仅仅更改了列表中的第一项，大多数 JavaScript 框架会重建整个列表，这比必要的工作要多十倍。

更新效率低下已经成为严重问题，为了解决这个问题，React 普及了一种叫做 Virtual DOM 的东西，Virtual DOM 出现的目的就是为了提高 JavaScript 操作 DOM 对象的效率。

### 什么是 Virtual DOM

在 React 中，每个 DOM 对象都有一个对应的 Virtual DOM 对象，它是 DOM 对象的 JavaScript 对象表现形式，其实就是使用 JavaScript 对象来描述 DOM 对象信息，比如 DOM 对象的类型是什么，它身上有哪些属性，它拥有哪些子元素。

可以把 Virtual DOM 对象理解为 DOM 对象的副本，但是它不能直接显示在屏幕上。

```react
<div className="container">
  <h3>Hello React</h3>
  <p>React is great </p>
</div>
```

```react
{
  type: "div",
  props: { className: "container" },
  children: [
    {
      type: "h3",
      props: null,
      children: [
        {
          type: "text",
          props: {
            textContent: "Hello React"
          }
        }
      ]
    },
    {
      type: "p",
      props: null,
      children: [
        {
          type: "text",
          props: {
            textContent: "React is great"
          }
        }
      ]
    }
  ]
}
```

### Virtual DOM 如何提升效率

精准找出发生变化的 DOM 对象，只更新发生变化的部分。

在 React 第一次创建 DOM 对象后，会为每个 DOM 对象创建其对应的 Virtual DOM 对象，在 DOM 对象发生更新之前，React 会先更新所有的 Virtual DOM 对象，然后 React 会将更新后的 Virtual DOM 和 更新前的 Virtual DOM 进行比较，从而找出发生变化的部分，React 会将发生变化的部分更新到真实的 DOM 对象中，React 仅更新必要更新的部分。

Virtual DOM 对象的更新和比较仅发生在内存中，不会在视图中渲染任何内容，所以这一部分的性能损耗成本是微不足道的。

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/1.png" style="margin: 20px 0;width: 80%"/>

```react
<div id="container">
	<p>Hello React</p>
</div>
```

```react
<div id="container">
	<p>Hello Angular</p>
</div>
```

```react
const before = {
  type: "div",
  props: { id: "container" },
  children: [
    {
      type: "p",
      props: null,
      children: [
        { type: "text", props: { textContent: "Hello React" } }
      ]
    }
  ]
}
```

```react
const after = {
  type: "div",
  props: { id: "container" },
  children: [
    {
      type: "p",
      props: null,
      children: [
        { type: "text", props: { textContent: "Hello Angular" } }
      ]
    }
  ]
}
```

###  创建 Virtual DOM

在 React 代码执行前，JSX 会被 Babel 转换为 React.createElement 方法的调用，在调用 createElement 方法时会传入元素的类型，元素的属性，以及元素的子元素，createElement 方法的返回值为构建好的 Virtual DOM 对象。

```react
{
  type: "div",
  props: null,
  children: [{type: "text", props: {textContent: "Hello"}}]
}
```

``` react
/**
 * 创建 Virtual DOM
 * @param {string} type 类型
 * @param {object | null} props 属性
 * @param  {createElement[]} children 子元素
 * @return {object} Virtual DOM
 */
function createElement (type, props, ...children) {
	return {
    type,
    props,
    children
  } 
}
```

从 createElement 方法的第三个参数开始就都是子元素了，在定义 createElement 方法时，通过 `...children` 将所有的子元素放置到 children 数组中。

```react
const virtualDOM = (
  <div className="container">
    <h1>你好 Tiny React</h1>
    <h2>(编码必杀技)</h2>
    <div>
      嵌套1 <div>嵌套 1.1</div>
    </div>
    <h3>(观察: 这个将会被改变)</h3>
    {2 == 1 && <div>如果2和1相等渲染当前内容</div>}
    {2 == 2 && <div>2</div>}
    <span>这是一段内容</span>
    <button onClick={() => alert("你好")}>点击我</button>
    <h3>这个将会被删除</h3>
    2, 3
  </div>
)
console.log(virtualDOM)
```

通过以上代码测试，发现返回的 Virtual DOM 存在一些问题，第一个问题是文本节点被直接放入到了数组中

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/2.png" width="50%"/>

而我们期望是文本节点应该是这样的

```react
children: [
  {
    type: "text",
    props: {
      textContent: "React is great"
    }
  }
]
```

通过以下代码对 Virtual DOM 进行改造，重新构建 Virtual DOM。

```javascript
// 将原有 children 拷贝一份 不要在原有数组上进行操作
const childElements = [].concat(...children).map(child => {
  // 判断 child 是否是对象类型
  if (child instanceof Object) {
    // 如果是 什么都不需要做 直接返回即可
    return child
  } else {
    // 如果不是对象就是文本 手动调用 createElement 方法将文本转换为 Virtual DOM
    return createElement("text", { textContent: child })
  }
})
return {
  type,
  props,
  children: childElements
}
```

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/3.png" width="50%"/>

通过观察返回的 Virtual DOM，文本节点已经被转化成了对象类型的 Virtual DOM，但是布尔值也被当做文本节点被转化了，在 JSX 中，如果 Virtual DOM 被转化为了布尔值或者null，是不应该被更新到真实 DOM 中的，所以接下来要做的事情就是清除 Virtual DOM 中的布尔值和null。

```react
// 由于 map 方法无法从数据中刨除元素, 所以此处将 map 方法更改为 reduce 方法
const childElements = [].concat(...children).reduce((result, child) => {
  // 判断子元素类型 刨除 null true false
  if (child != null && child != false && child != true) {
    if (child instanceof Object) {
      result.push(child)
    } else {
      result.push(createElement("text", { textContent: child }))
    }
  }
  // 将需要保留的 Virtual DOM 放入 result 数组
  return result
}, [])
```

在 React 组件中，可以通过 props.children 获取子元素，所以还需要将子元素存储在 props 对象中。

```javascript
return {
  type,
  props: Object.assign({ children: childElements }, props),
  children: childElements
}
```

###  渲染 Virtual DOM 对象为 DOM 对象

通过调用 render 方法可以将 Virtual DOM 对象更新为真实 DOM 对象。

在更新之前需要确定是否存在旧的 Virtual DOM，如果存在需要比对差异，如果不存在可以直接将 Virtual DOM 转换为 DOM 对象。 

目前先只考虑不存在旧的 Virtual DOM 的情况，就是说先直接将 Virtual DOM 对象更新为真实 DOM 对象。

```react
// render.js
export default function render(virtualDOM, container, oldDOM = container.firstChild) {
  // 在 diff 方法内部判断是否需要对比 对比也好 不对比也好 都在 diff 方法中进行操作  
  diff(virtualDOM, container, oldDOM)
}
```

```react
// diff.js
import mountElement from "./mountElement"

export default function diff(virtualDOM, container, oldDOM) {
  // 判断 oldDOM 是否存在
  if (!oldDOM) {
    // 如果不存在 不需要对比 直接将 Virtual DOM 转换为真实 DOM
    mountElement(virtualDOM, container)
  }
}
```

在进行 virtual DOM 转换之前还需要确定 Virtual DOM 的类 Component VS Native Element。

类型不同需要做不同的处理 如果是 Native Element 直接转换。

如果是组件 还需要得到组件实例对象 通过组件实例对象获取组件返回的 virtual DOM 然后再进行转换。

目前先只考虑 Native Element 的情况。

```javascript
babel 转化
<div className="container">
  <h3>Hello React</h3>
  <p>React is great </p>
</div>

function Demo (){
	return <div>Hello React</div>
}

// 转化后

"use strict";

/*#__PURE__*/
React.createElement("div", {
  className: "container"
}, /*#__PURE__*/React.createElement("h3", null, "Hello React"), /*#__PURE__*/React.createElement("p", null, "React is great "));

function Demo() {
  return /*#__PURE__*/React.createElement("div", null, "Hello React");
}
```



```react
// mountElement.js
import mountNativeElement from "./mountNativeElement"

export default function mountElement(virtualDOM, container) {
  // 通过调用 mountNativeElement 方法转换 Native Element
  mountNativeElement(virtualDOM, container)
}
```

```react
// mountNativeElement.js
import createDOMElement from "./createDOMElement"

export default function mountNativeElement(virtualDOM, container) {
  const newElement = createDOMElement(virtualDOM)
  container.appendChild(newElement)
}
```

```react
// createDOMElement.js
import mountElement from "./mountElement"
import updateElementNode from "./updateElementNode"

export default function createDOMElement(virtualDOM) {
  let newElement = null
  if (virtualDOM.type === "text") {
    // 创建文本节点
    newElement = document.createTextNode(virtualDOM.props.textContent)
  } else {
    // 创建元素节点
    newElement = document.createElement(virtualDOM.type)
    // 更新元素属性
    updateElementNode(newElement, virtualDOM)
  }
  // 递归渲染子节点
  virtualDOM.children.forEach(child => {
    // 因为不确定子元素是 NativeElement 还是 Component 所以调用 mountElement 方法进行确定
    mountElement(child, newElement)
  })
  return newElement
}

```

###  为元素节点添加属性

```react
// createDOMElement.js
// 看看节点类型是文本类型还是元素类型
if (virtualDOM.type === "text") {
  // 创建文本节点 设置节点内容
  newElement = document.createTextNode(virtualDOM.props.textContent)
} else {
  // 根据 Virtual DOM type 属性值创建 DOM 元素
  newElement = document.createElement(virtualDOM.type)
  // 为元素设置属性
  updateElementNode(newElement, virtualDOM)
}
```

```react
export default function updateElementNode(element, virtualDOM) {
  // 获取要解析的 VirtualDOM 对象中的属性对象
  const newProps = virtualDOM.props
  // 将属性对象中的属性名称放到一个数组中并循环数组
  Object.keys(newProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    // 考虑属性名称是否以 on 开头 如果是就表示是个事件属性 onClick -> click
    if (propName.slice(0, 2) === "on") {
      const eventName = propName.toLowerCase().slice(2)
      element.addEventListener(eventName, newPropsValue)
      // 如果属性名称是 value 或者 checked 需要通过 [] 的形式添加
    } else if (propName === "value" || propName === "checked") {
      element[propName] = newPropsValue
      // 刨除 children 因为它是子元素 不是属性
    } else if (propName !== "children") {
      // className 属性单独处理 不直接在元素上添加 class 属性是因为 class 是 JavaScript 中的关键字
      if (propName === "className") {
        element.setAttribute("class", newPropsValue)
      } else {
        // 普通属性
        element.setAttribute(propName, newPropsValue)
      }
    }
  })
}
```

### 渲染组件

####  函数组件

在渲染组件之前首先要明确的是，组件的 Virtual DOM 类型值为函数，函数组件和类组件都是这样的。

```react
// 原始组件
const Heart = () => <span>&hearts;</span>
```

```react
<Heart />
```

```react
// 组件的 Virtual DOM
{
  type: f function() {},
  props: {}
  children: []
}
```

在渲染组件时，要先将 Component 与 Native Element 区分开，如果是 Native Element 可以直接开始渲染，如果是组件，特别处理。

```react
// mountElement.js
export default function mountElement(virtualDOM, container) {
  // 无论是类组件还是函数组件 其实本质上都是函数 
  // 如果 Virtual DOM 的 type 属性值为函数 就说明当前这个 Virtual DOM 为组件
  if (isFunction(virtualDOM)) {
    // 如果是组件 调用 mountComponent 方法进行组件渲染
    mountComponent(virtualDOM, container)
  } else {
    mountNativeElement(virtualDOM, container)
  }
}

// Virtual DOM 是否为函数类型
export function isFunction(virtualDOM) {
  return virtualDOM && typeof virtualDOM.type === "function"
}
```

在 mountComponent 方法中再进行函数组件和类型的区分，然后再分别进行处理。

```react
// mountComponent.js
import mountNativeElement from "./mountNativeElement"

export default function mountComponent(virtualDOM, container) {
  // 存放组件调用后返回的 Virtual DOM 的容器
  let nextVirtualDOM = null
  // 区分函数型组件和类组件
  if (isFunctionalComponent(virtualDOM)) {
    // 函数组件 调用 buildFunctionalComponent 方法处理函数组件
    nextVirtualDOM = buildFunctionalComponent(virtualDOM)
  } else {
    // 类组件
  }
  // 判断得到的 Virtual Dom 是否是组件
  if (isFunction(nextVirtualDOM)) {
    // 如果是组件 继续调用 mountComponent 解剖组件
    mountComponent(nextVirtualDOM, container)
  } else {
    // 如果是 Navtive Element 就去渲染
    mountNativeElement(nextVirtualDOM, container)
  }
}

// Virtual DOM 是否为函数型组件
// 条件有两个: 1. Virtual DOM 的 type 属性值为函数 2. 函数的原型对象中不能有render方法
// 只有类组件的原型对象中有render方法 
export function isFunctionalComponent(virtualDOM) {
  const type = virtualDOM && virtualDOM.type
  return (
    type && isFunction(virtualDOM) && !(type.prototype && type.prototype.render)
  )
}

// 函数组件处理 
function buildFunctionalComponent(virtualDOM) {
  // 通过 Virtual DOM 中的 type 属性获取到组件函数并调用
  // 调用组件函数时将 Virtual DOM 对象中的 props 属性传递给组件函数 这样在组件中就可以通过 props 属性获取数据了
  // 组件返回要渲染的 Virtual DOM
  return virtualDOM && virtualDOM.type(virtualDOM.props || {})
}
```

####  类组件

类组件本身也是 Virtual DOM，可以通过 Virtual DOM 中的 type 属性值确定当前要渲染的组件是类组件还是函数组件。

在确定当前要渲染的组件为类组件以后，需要实例化类组件得到类组件实例对象，通过类组件实例对象调用类组件中的 render 方法，获取组件要渲染的 Virtual DOM。

类组件需要继承 Component 父类，子类需要通过 super 方法将自身的 props 属性传递给 Component 父类，父类会将 props 属性挂载为父类属性，子类继承了父类，自己本身也就自然拥有props属性了。这样做的好处是当 props 发生更新后，父类可以根据更新后的 props 帮助子类更新视图。

假设以下代码就是我们要渲染的类组件：

```react
class Alert extends TinyReact.Component {
  constructor(props) {
    // 将 props 传递给父类 子类继承父类的 props 子类自然就有 props 数据了
    // 否则 props 仅仅是 constructor 函数的参数而已
    // 将 props 传递给父类的好处是 当 props 发生更改时 父类可以帮助更新 props 更新组件视图
    super(props)
    this.state = {
      title: "default title"
    }
  }
  render() {
    return (
      <div>
        <h2>{this.state.title}</h2>
        <p>{this.props.message}</p>
      </div>
    )
  }
}

TinyReact.render(<Alert message="Hello React" />, root)
```

```react
// Component.js 父类 Component 实现
export default class Component {
  constructor(props) {
    this.props = props
  }
}
```

在 mountComponent 方法中通过调用 buildStatefulComponent 方法得到类组件要渲染的 Virtual DOM

```react
// mountComponent.js
export default function mountComponent(virtualDOM, container) {
  let nextVirtualDOM = null
  // 区分函数型组件和类组件
  if (isFunctionalComponent(virtualDOM)) {
    // 函数组件
    nextVirtualDOM = buildFunctionalComponent(virtualDOM)
  } else {
    // 类组件
    nextVirtualDOM = buildStatefulComponent(virtualDOM)
  }
  // 判断得到的 Virtual Dom 是否是组件
  if (isFunction(nextVirtualDOM)) {
    mountComponent(nextVirtualDOM, container)
  } else {
    mountNativeElement(nextVirtualDOM, container)
  }
}

// 处理类组件
function buildStatefulComponent(virtualDOM) {
  // 实例化类组件 得到类组件实例对象 并将 props 属性传递进类组件
  const component = new virtualDOM.type(virtualDOM.props)
  // 调用类组件中的render方法得到要渲染的 Virtual DOM
  const nextVirtualDOM = component.render()
  // 返回要渲染的 Virtual DOM
  return nextVirtualDOM
}
```

### Virtual DOM 比对

在进行 Virtual DOM 比对时，需要用到更新后的 Virtual DOM 和更新前的 Virtual DOM，更新后的 Virtual DOM 目前我们可以通过 render 方法进行传递，现在的问题是更新前的 Virtual DOM 要如何获取呢？

对于更新前的 Virtual DOM，对应的其实就是已经在页面中显示的真实 DOM 对象。既然是这样，那么我们在创建真实DOM对象时，就可以将 Virtual DOM 添加到真实 DOM 对象的属性中。在进行 Virtual DOM 对比之前，就可以通过真实 DOM 对象获取其对应的 Virtual DOM 对象了，其实就是通过render方法的第三个参数获取的，container.firstChild。

在创建真实 DOM 对象时为其添加对应的 Virtual DOM 对象

 ```react
// mountElement.js
import mountElement from "./mountElement"

export default function mountNativeElement(virtualDOM, container) {
  // 将 Virtual DOM 挂载到真实 DOM 对象的属性中 方便在对比时获取其 Virtual DOM
  newElement._virtualDOM = virtualDOM
}
 ```

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/8.png" width="80%" style="margin-bottom: 30px"/>

####  Virtual DOM 类型相同

Virtual DOM 类型相同，如果是元素节点，就对比元素节点属性是否发生变化，如果是文本节点就对比文本节点内容是否发生变化

要实现对比，需要先从已存在 DOM 对象中获取其对应的 Virtual DOM 对象。

```react
// diff.js
// 获取未更新前的 Virtual DOM
const oldVirtualDOM = oldDOM && oldDOM._virtualDOM
```

判断 oldVirtualDOM 是否存在， 如果存在则继续判断要对比的 Virtual DOM 类型是否相同，如果类型相同判断节点类型是否是文本，如果是文本节点对比，就调用 updateTextNode 方法，如果是元素节点对比就调用 setAttributeForElement 方法

```react
// diff.js
else if (oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
  if (virtualDOM.type === "text") {
    // 文本节点 对比文本内容是否发生变化
    updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)
  } else {
    // 元素节点 对比元素属性是否发生变化
    setAttributeForElement(oldDOM, virtualDOM, oldVirtualDOM)
  }
```

updateTextNode 方法用于对比文本节点内容是否发生变化，如果发生变化则更新真实 DOM 对象中的内容，既然真实 DOM 对象发生了变化，还要将最新的 Virtual DOM 同步给真实 DOM 对象。

```react
function updateTextNode(virtualDOM, oldVirtualDOM, oldDOM) {
  // 如果文本节点内容不同
  if (virtualDOM.props.textContent !== oldVirtualDOM.props.textContent) {
    // 更新真实 DOM 对象中的内容
    oldDOM.textContent = virtualDOM.props.textContent
  }
  // 同步真实 DOM 对应的 Virtual DOM
  oldDOM._virtualDOM = virtualDOM
}
```

setAttributeForElement 方法用于设置/更新元素节点属性

思路是先分别获取更新后的和更新前的 Virtual DOM 中的 props 属性，循环新 Virtual DOM 中的 props 属性，通过对比看一下新 Virtual DOM 中的属性值是否发生了变化，如果发生变化 需要将变化的值更新到真实 DOM 对象中

再循环未更新前的 Virtual DOM 对象，通过对比看看新的 Virtual DOM 中是否有被删除的属性，如果存在删除的属性 需要将 DOM 对象中对应的属性也删除掉

```react
// updateNodeElement.js
export default function updateNodeElement(
  newElement,
  virtualDOM,
  oldVirtualDOM = {}
) {
  // 获取节点对应的属性对象
  const newProps = virtualDOM.props || {}
  const oldProps = oldVirtualDOM.props || {}
  Object.keys(newProps).forEach(propName => {
    // 获取属性值
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if (newPropsValue !== oldPropsValue) {
      // 判断属性是否是否事件属性 onClick -> click
      if (propName.slice(0, 2) === "on") {
        // 事件名称
        const eventName = propName.toLowerCase().slice(2)
        // 为元素添加事件
        newElement.addEventListener(eventName, newPropsValue)
        // 删除原有的事件的事件处理函数
        if (oldPropsValue) {
          newElement.removeEventListener(eventName, oldPropsValue)
        }
      } else if (propName === "value" || propName === "checked") {
        newElement[propName] = newPropsValue
      } else if (propName !== "children") {
        if (propName === "className") {
          newElement.setAttribute("class", newPropsValue)
        } else {
          newElement.setAttribute(propName, newPropsValue)
        }
      }
    }
  })
  // 判断属性被删除的情况
  Object.keys(oldProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if (!newPropsValue) {
      // 属性被删除了
      if (propName.slice(0, 2) === "on") {
        const eventName = propName.toLowerCase().slice(2)
        newElement.removeEventListener(eventName, oldPropsValue)
      } else if (propName !== "children") {
        newElement.removeAttribute(propName)
      }
    }
  })
}
```

以上对比的仅仅是最上层元素，上层元素对比完成以后还需要递归对比子元素

```react
else if (oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
    // 递归对比 Virtual DOM 的子元素
    virtualDOM.children.forEach((child, i) => {
      diff(child, oldDOM, oldDOM.childNodes[i])
    })
  }
```

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/7.png"/>

####  Virtual DOM 类型不同

当对比的元素节点类型不同时，就不需要继续对比了，直接使用新的 Virtual DOM 创建 DOM 对象，用新的 DOM 对象直接替换旧的 DOM 对象。当前这种情况要将组件刨除，组件要被单独处理。

```react
// diff.js
else if (
  // 如果 Virtual DOM 类型不一样
  virtualDOM.type !== oldVirtualDOM.type &&
  // 并且 Virtual DOM 不是组件 因为组件要单独进行处理
  typeof virtualDOM.type !== "function"
) {
  // 根据 Virtual DOM 创建真实 DOM 元素
  const newDOMElement = createDOMElement(virtualDOM)
  // 用创建出来的真实 DOM 元素 替换旧的 DOM 元素
  oldDOM.parentNode.replaceChild(newDOMElement, oldDOM)
} 
```

####  删除节点

删除节点发生在节点更新以后并且发生在同一个父节点下的所有子节点身上。

在节点更新完成以后，如果旧节点对象的数量多于新 VirtualDOM 节点的数量，就说明有节点需要被删除。

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/5.png" width="40%" align="left"/>

```react
// 获取就节点的数量
let oldChildNodes = oldDOM.childNodes
// 如果旧节点的数量多于要渲染的新节点的长度
if (oldChildNodes.length > virtualDOM.children.length) {
  for (
    let i = oldChildNodes.length - 1;
    i > virtualDOM.children.length - 1;
    i--
  ) {
    oldDOM.removeChild(oldChildNodes[i])
  }
}
```

####  类组件状态更新

以下代码是要更新状态的类组件，在类组件的 state 对象中有默认的 title 状态，点击 change title 按钮调用 handleChange 方法，在 handleChange 方法中调用 this.setState 方法更改 title 的状态值。

```react
class Alert extends TinyReact.Component {
  constructor(props) {
    super(props)
    this.state = {
      title: "default title"
    }
    // 更改 handleChange 方法中的 this 指向 让 this 指向类实例对象
    this.handleChange = this.handleChange.bind(this)
  }
  handleChange() {
    // 调用父类中的 setState 方法更改状态
    this.setState({
      title: "changed title"
    })
  }
  render() {
    return (
      <div>
        <h2>{this.state.title}</h2>
        <p>{this.props.message}</p>
        <button onClick={this.handleChange}>change title</button>
      </div>
    )
  }
}
```

setState 方法是定义在父类 Component 中的，该方法的作用是更改子类的 state，产生一个全新的 state 对象。

```react
// Component.js
export default class Component {
  constructor(props) {
    this.props = props
  }
  setState (state) {
    // setState 方法被子类调用 此处this指向子类实例对象
    // 所以改变的是子类的 state 对象
    this.state = Object.assign({}, this.state, state)
  }
}
```

现在子类已经可以调用父类的 setState 方法更改状态值了，当组件的 state 对象发生更改时，要调用 render 方法更新组件视图。

在更新组件之前，要使用更新的 Virtual DOM 对象和未更新的 Virtual DOM 进行对比找出更新的部分，达到 DOM 最小化操作的目的。

在 setState 方法中可以通过调用 this.render 方法获取更新后的 Virtual DOM，由于 setState 方法被子类调用，this 指向子类，所以此处调用的是子类的 render 方法。

```react
// Component.js
setState(state) {
  // setState 方法被子类调用 此处this指向子类
  // 所以改变的是子类的 state
  this.state = Object.assign({}, this.state, state)
  // 通过调用 render 方法获取最新的 Virtual DOM
  let virtualDOM = this.render()
}
```

要实现对比，还需要获取未更新前的 Virtual DOM，按照之前的经验，我们可以从 DOM 对象中获取其对应的 Virtual  DOM 对象，未更新前的 DOM 对象实际上就是现在在页面中显示的 DOM 对象，我们只要能获取到这个 DOM 对象就可以获取到其对应的 Virtual DOM 对象了。

页面中的 DOM 对象要怎样获取呢？页面中的 DOM 对象是通过 mountNativeElement 方法挂载到页面中的，所以我们只需要在这个方法中调用 Component 类中的方法就可以将 DOM 对象保存在 Component 类中了。在子类调用 setState 方法的时候，在 setState 方法中再调用另一个获取 DOM 对象的方法就可以获取到之前保存的 DOM 对象了。

```react
// Component.js
// 保存 DOM 对象的方法
setDOM(dom) {
  this._dom = dom
}
// 获取 DOM 对象的方法
getDOM() {
  return this._dom
}
```

接下来我们要研究一下在 mountNativeElement 方法中如何才能调用到 setDOM 方法，要调用 setDOM 方法，必须要得到类的实例对象，所以目前的问题就是如何在 mountNativeElement 方法中得到类的实例对象，这个类指的不是Component类，因为我们在代码中并不是直接实例化的Component类，而是实例化的它的子类，由于子类继承了父类，所以在子类的实例对象中也是可以调用到 setDOM 方法的。

mountNativeElement 方法接收最新的 Virtual DOM 对象，如果这个 Virtual DOM 对象是类组件产生的，在产生这个 Virtual DOM 对象时一定会先得到这个类的实例对象，然后再调用实例对象下面的 render 方法进行获取。我们可以在那个时候将类组件实例对象添加到 Virtual DOM 对象的属性中，而这个 Virtual DOM 对象最终会传递给 mountNativeElement  方法，这样我们就可以在 mountNativeElement 方法中获取到组件的实例对象了，既然类组件的实例对象获取到了，我们就可以调用 setDOM 方法了。

在 buildClassComponent 方法中为 Virtual DOM 对象添加 component 属性， 值为类组件的实例对象。

```react
function buildClassComponent(virtualDOM) {
  const component = new virtualDOM.type(virtualDOM.props)
  const nextVirtualDOM = component.render()
  nextVirtualDOM.component = component
  return nextVirtualDOM
}
```

在 mountNativeElement 方法中获取组件实例对象，通过实例调用调用 setDOM 方法保存 DOM 对象，方便在对比时通过它获取它的 Virtual DOM 对象

```react
export default function mountNativeElement(virtualDOM, container) {
  // 获取组件实例对象
  const component = virtualDOM.component
  // 如果组件实例对象存在
  if (component) {
    // 保存 DOM 对象
    component.setDOM(newElement)
  }
}
```

接下来在 setState 方法中就可以调用 getDOM 方法获取 DOM 对象了

```react
setState(state) {
  this.state = Object.assign({}, this.state, state)
  let virtualDOM = this.render()
  // 获取页面中正在显示的 DOM 对象 通过它可以获取其对象的 Virtual DOM 对象
  let oldDOM = this.getDOM()
}
```

现在更新前的 Virtual DOM 对象和更新后的 Virtual DOM 对象就都已经获取到了，接下来还要获取到真实 DOM 对象父级容器对象，因为在调用 diff 方法进行对比的时候需要用到

```react
setState(state) {
  this.state = Object.assign({}, this.state, state)
  let virtualDOM = this.render()
  let oldDOM = this.getDOM()
  // 获取真实 DOM 对象父级容器对象
  let container = oldDOM.parentNode
}
```

接下来就可以调用 diff 方法进行比对了，比对后会按照我们之前写好的逻辑进行 DOM 对象更新，我们就可以在页面中看到效果了

```react
setState(state) {
    this.state = Object.assign({}, this.state, state)
    let virtualDOM = this.render()
    let oldDOM = this.getDOM()
    let container = oldDOM.parentNode
    // 比对
    diff(virtualDOM, container, oldDOM)
  }
```

#### 组件更新

在 diff 方法中判断要更新的 Virtual DOM 是否是组件。

如果是组件再判断要更新的组件和未更新前的组件是否是同一个组件，如果不是同一个组件就不需要做组件更新操作，直接调用 mountElement 方法将组件返回的 Virtual DOM 添加到页面中。

如果是同一个组件，就执行更新组件操作，其实就是将最新的 props 传递到组件中，再调用组件的render方法获取组件返回的最新的 Virtual DOM 对象，再将 Virtual DOM 对象传递给 diff 方法，让 diff 方法找出差异，从而将差异更新到真实 DOM 对象中。

在更新组件的过程中还要在不同阶段调用其不同的组件生命周期函数。

在 diff 方法中判断要更新的 Virtual DOM 是否是组件，如果是组件又分为多种情况，新增 diffComponent 方法进行处理

```react
else if (typeof virtualDOM.type === "function") {
  // 要更新的是组件
  // 1) 组件本身的 virtualDOM 对象 通过它可以获取到组件最新的 props
  // 2) 要更新的组件的实例对象 通过它可以调用组件的生命周期函数 可以更新组件的 props 属性 可以获取到组件返回的最新的 Virtual DOM
  // 3) 要更新的 DOM 象 在更新组件时 需要在已有DOM对象的身上进行修改 实现DOM最小化操作 获取旧的 Virtual DOM 对象
  // 4) 如果要更新的组件和旧组件不是同一个组件 要直接将组件返回的 Virtual DOM 显示在页面中 此时需要 container 做为父级容器
  diffComponent(virtualDOM, oldComponent, oldDOM, container)
}
```

在 diffComponent 方法中判断要更新的组件是未更新前的组件是否是同一个组件

```react
// diffComponent.js
export default function diffComponent(virtualDOM, oldComponent, oldDOM, container) {
  // 判断要更新的组件和未更新的组件是否是同一个组件 只需要确定两者使用的是否是同一个构造函数就可以了
  if (isSameComponent(virtualDOM, oldComponent)) {
    // 属同一个组件 做组件更新  
  } else {
    // 不是同一个组件 直接将组件内容显示在页面中
  }
}
// virtualDOM.type 更新后的组件构造函数
// oldComponent.constructor 未更新前的组件构造函数
// 两者等价就表示是同一组件
function isSameComponent(virtualDOM, oldComponent) {
  return oldComponent && virtualDOM.type === oldComponent.constructor
}
```

如果不是同一个组件的话，就不需要执行更新组件的操作，直接将组件内容显示在页面中，替换原有内容

```react
// diffComponent.js
else {
  // 不是同一个组件 直接将组件内容显示在页面中
  // 这里为 mountElement 方法新增了一个参数 oldDOM 
  // 作用是在将 DOM 对象插入到页面前 将页面中已存在的 DOM 对象删除 否则无论是旧DOM对象还是新DOM对象都会显示在页面中
  mountElement(virtualDOM, container, oldDOM)
}
```

在 mountNativeElement 方法中删除原有的旧 DOM 对象

```javascript
// mountNavtiveElement.js
export default function mountNativeElement(virtualDOM, container, oldDOM) {
 // 如果旧的DOM对象存在 删除
  if (oldDOM) {
    unmount(oldDOM)
  }
}
```

```react
// unmount.js
export default function unmount(node) {
  node.remove()
}
```

如果是同一个组件的话，需要执行组件更新操作，需要调用组件生命周期函数

先在 Component 类中添加生命周期函数，子类要使用的话直接覆盖就可以

```react
// Component.js
export default class Component {
  // 生命周期函数
  componentWillMount() {}
  componentDidMount() {}
  componentWillReceiveProps(nextProps) {}
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps != this.props || nextState != this.state
  }
  componentWillUpdate(nextProps, nextState) {}
  componentDidUpdate(prevProps, preState) {}
  componentWillUnmount() {}
}
```

新建 updateComponent 方法用于更新组件操作，并在 if 成立后调用

```react
// diffComponent.js
if (isSameComponent(virtualDOM, oldComponent)) {
  // 属同一个组件 做组件更新
  updateComponent(virtualDOM, oldComponent, oldDOM, container)
}
```

在 updateComponent 方法中调用组件的生命周期函数，更新组件获取最新 Virtual DOM，最终调用 diff 方法进行更新

```react
import diff from "./diff"

export default function updateComponent(
  virtualDOM,
  oldComponent,
  oldDOM,
  container
) {
  // 生命周期函数
  oldComponent.componentWillReceiveProps(virtualDOM.props)
  if (
    // 调用 shouldComponentUpdate 生命周期函数判断是否要执行更新操作
    oldComponent.shouldComponentUpdate(virtualDOM.props)
  ) {
    // 将未更新的 props 保存一份
    let prevProps = oldComponent.props
    // 生命周期函数
    oldComponent.componentWillUpdate(virtualDOM.props)
    // 更新组件的 props 属性 updateProps 方法定义在 Component 类型
    oldComponent.updateProps(virtualDOM.props)
    // 因为组件的 props 已经更新 所以调用 render 方法获取最新的 Virtual DOM
    const nextVirtualDOM = oldComponent.render()
    // 将组件实例对象挂载到 Virtual DOM 身上
    nextVirtualDOM.component = oldComponent
    // 调用diff方法更新视图
    diff(nextVirtualDOM, container, oldDOM)
    // 生命周期函数
    oldComponent.componentDidUpdate(prevProps)
  }
}
```

```react
// Component.js
export default class Component {
  updateProps(props) {
    this.props = props
  }
}
```

###  ref 属性

为节点添加 ref 属性可以获取到这个节点的 DOM 对象，比如在 DemoRef 类中，为 input 元素添加了 ref 属性，目的是获取 input DOM 元素对象，在点击按钮时获取用户在文本框中输入的内容

```react
class DemoRef extends TinyReact.Component {
  handle() {
    let value = this.input.value
    console.log(value)
  }
  render() {
    return (
      <div>
        <input type="text" ref={input => (this.input = input)} />
        <button onClick={this.handle.bind(this)}>按钮</button>
      </div>
    )
  }
}
```

实现思路是在创建节点时判断其 Virtual DOM 对象中是否有 ref 属性，如果有就调用 ref 属性中所存储的方法并且将创建出来的DOM对象作为参数传递给 ref 方法，这样在渲染组件节点的时候就可以拿到元素对象并将元素对象存储为组件属性了。

```react
// createDOMElement.js
if (virtualDOM.props && virtualDOM.props.ref) {
  virtualDOM.props.ref(newElement)
}
```

在类组件的身上也可以添加 ref 属性，目的是获取组件的实例对象，比如下列代码中，在 DemoRef 组件中渲染了 Alert 组件，在 Alert 组件中添加了 ref 属性，目的是在 DemoRef 组件中获取 Alert 组件实例对象。

```react
class DemoRef extends TinyReact.Component {
  handle() {
    let value = this.input.value
    console.log(value)
    console.log(this.alert)
  }
  componentDidMount() {
    console.log("componentDidMount")
  }
  render() {
    return (
      <div>
        <input type="text" ref={input => (this.input = input)} />
        <button onClick={this.handle.bind(this)}>按钮</button>
        <Alert ref={alert => (this.alert = alert)} />
      </div>
    )
  }
}
```

实现思路是在 mountComponent 方法中，如果判断了当前处理的是类组件，就通过类组件返回的 Virtual DOM 对象中获取组件实例对象，判断组件实例对象中的 props 属性中是否存在 ref 属性，如果存在就调用 ref 方法并且将组件实例对象传递给 ref 方法。

```react
// mountComponent.js
let component = null
  if (isFunctionalComponent(virtualDOM)) {}
	else {
    // 类组件
    nextVirtualDOM = buildStatefulComponent(virtualDOM)
    // 获取组件实例对象
    component = nextVirtualDOM.component
  }
	// 如果组件实例对象存在的话
	if (component) {
   	// 判断组件实例对象身上是否有 props 属性 props 属性中是否有 ref 属性
    if (component.props && component.props.ref) {
      // 调用 ref 方法并传递组件实例对象
      component.props.ref(component)
    }
  }

```

代码走到这，顺便处理一下组件挂载完成的生命周期函数

```react
// 如果组件实例对象存在的话
if (component) {
  component.componentDidMount()
}
```

### key 属性

在 React 中，渲染列表数据时通常会在被渲染的列表元素上添加 key 属性，key 属性就是数据的唯一标识，帮助 React 识别哪些数据被修改或者删除了，从而达到 DOM 最小化操作的目的。

key 属性不需要全局唯一，但是在同一个父节点下的兄弟节点之间必须是唯一的。

也就是说，在比对同一个父节点下类型相同的子节点时需要用到 key 属性。

####  节点对比

实现思路是在两个元素进行比对时，如果类型相同，就循环旧的 DOM 对象的子元素，查看其身上是否有key 属性，如果有就将这个子元素的 DOM 对象存储在一个 JavaScript 对象中，接着循环要渲染的 Virtual DOM 对象的子元素，在循环过程中获取到这个子元素的 key 属性，然后使用这个 key 属性到 JavaScript 对象中查找 DOM 对象，如果能够找到就说明这个元素是已经存在的，是不需要重新渲染的。如果通过key属性找不到这个元素，就说明这个元素是新增的是需要渲染的。

```react
// diff.js
else if (oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
  // 将拥有key属性的元素放入 keyedElements 对象中
  let keyedElements = {}
  for (let i = 0, len = oldDOM.childNodes.length; i < len; i++) {
    let domElement = oldDOM.childNodes[i]
    if (domElement.nodeType === 1) {
      let key = domElement.getAttribute("key")
      if (key) {
        keyedElements[key] = domElement
      }
    }
  }
}
```

```react
// diff.js
// 看一看是否有找到了拥有 key 属性的元素
let hasNoKey = Object.keys(keyedElements).length === 0

// 如果没有找到拥有 key 属性的元素 就按照索引进行比较
if (hasNoKey) {
  // 递归对比 Virtual DOM 的子元素
  virtualDOM.children.forEach((child, i) => {
    diff(child, oldDOM, oldDOM.childNodes[i])
  })
} else {
  // 使用key属性进行元素比较
  virtualDOM.children.forEach((child, i) => {
    // 获取要进行比对的元素的 key 属性
    let key = child.props.key
    // 如果 key 属性存在
    if (key) {
      // 到已存在的 DOM 元素对象中查找对应的 DOM 元素
      let domElement = keyedElements[key]
      // 如果找到元素就说明该元素已经存在 不需要重新渲染
      if (domElement) {
        // 虽然 DOM 元素不需要重新渲染 但是不能确定元素的位置就一定没有发生变化
        // 所以还要查看一下元素的位置
        // 看一下 oldDOM 对应的(i)子元素和 domElement 是否是同一个元素 如果不是就说明元素位置发生了变化
        if (oldDOM.childNodes[i] && oldDOM.childNodes[i] !== domElement) {
          // 元素位置发生了变化
          // 将 domElement 插入到当前元素位置的前面 oldDOM.childNodes[i] 就是当前位置
          // domElement 就被放入了当前位置
          oldDOM.insertBefore(domElement, oldDOM.childNodes[i])
        }
      } else {
        mountElement(child, oldDOM, oldDOM.childNodes[i])
      }
    }
  })
}
```

```react
// mountNativeElement.js
if (oldDOM) {
  container.insertBefore(newElement, oldDOM)
} else {
  // 将转换之后的DOM对象放置在页面中
  container.appendChild(newElement)
}
```

#### 节点卸载

在比对节点的过程中，如果旧节点的数量多于要渲染的新节点的数量就说明有节点被删除了，继续判断 keyedElements 对象中是否有元素，如果没有就使用索引方式删除，如果有就要使用 key 属性比对的方式进行删除。

实现思路是循环旧节点，在循环旧节点的过程中获取旧节点对应的 key 属性，然后根据 key 属性在新节点中查找这个旧节点，如果找到就说明这个节点没有被删除，如果没有找到，就说明节点被删除了，调用卸载节点的方法卸载节点即可。

```react
// 获取就节点的数量
let oldChildNodes = oldDOM.childNodes
// 如果旧节点的数量多于要渲染的新节点的长度
if (oldChildNodes.length > virtualDOM.children.length) {
  if (hasNoKey) {
    for (
      let i = oldChildNodes.length - 1;
      i >= virtualDOM.children.length;
      i--
    ) {
      oldDOM.removeChild(oldChildNodes[i])
    }
  } else {
    for (let i = 0; i < oldChildNodes.length; i++) {
      let oldChild = oldChildNodes[i]
      let oldChildKey = oldChild._virtualDOM.props.key
      let found = false
      for (let n = 0; n < virtualDOM.children.length; n++) {
        if (oldChildKey === virtualDOM.children[n].props.key) {
          found = true
          break
        }
      }
      if (!found) {
        unmount(oldChild)
        i--
      }
    }
  }
}
```

卸载节点并不是说将节点直接删除就可以了，还需要考虑以下几种情况

1. 如果要删除的节点是文本节点的话可以直接删除
2. 如果要删除的节点由组件生成，需要调用组件卸载生命周期函数
3. 如果要删除的节点中包含了其他组件生成的节点，需要调用其他组件的卸载生命周期函数
4. 如果要删除的节点身上有 ref 属性，还需要删除通过 ref 属性传递给组件的 DOM 节点对象
5. 如果要删除的节点身上有事件，需要删除事件对应的事件处理函数

```react
export default function unmount(dom) {
  // 获取节点对应的 virtualDOM 对象
  const virtualDOM = dom._virtualDOM
  // 如果要删除的节点时文本
  if (virtualDOM.type === "text") {
    // 直接删除节点
    dom.remove()
    // 阻止程序向下运行
    return
  }
  // 查看节点是否由组件生成
  let component = virtualDOM.component
  // 如果由组件生成
  if (component) {
    // 调用组件卸载生命周期函数
    component.componentWillUnmount()
  }
  
  // 如果节点具有 ref 属性 通过再次调用 ref 方法 将传递给组件的DOM对象删除
  if (virtualDOM.props && virtualDOM.props.ref) {
    virtualDOM.props.ref(null)
  }

  // 事件处理
  Object.keys(virtualDOM.props).forEach(propName => {
    if (propName.slice(0, 2) === "on") {
      const eventName = propName.toLowerCase().slice(2)
      const eventHandler = virtualDOM.props[propName]
      dom.removeEventListener(eventName, eventHandler)
    }
  })
	
  // 递归删除子节点
  if (dom.childNodes.length > 0) {
    for (let i = 0; i < dom.childNodes.length; i++) {
      unmount(dom.childNodes[i])
      i--
    }
  }
  	
  dom.remove()
}

```



# Node.js 全栈开发

# 泛客户端开发

# 商业技术解决方案与高阶技术

# 