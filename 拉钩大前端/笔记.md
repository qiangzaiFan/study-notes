# JavaScript 深度剖析

## 函数式编程

### 为什么要学习函数式编程以及什么是函数式编程

#### 为什么要学习函数式编程？

- 函数式编程随着React的流行受到越来越多的关注
- Vue3也开始拥抱函数式编程
- 函数式编程可以抛弃this
- 打包过程中可以更好的利用tree shaking过滤无用代码
- 方便测试，方便并行处理
- 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda

#### 什么是函数式编程

函数式编程(Functional Programming, FP)是编程范式之一，我们常听说的编程范式还有面向过程编程、面向对象编程。

- 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
- 函数式编程的思维方式：把现实世界的事物和事物之间的**联系**抽象到程序世界（对运算过程进行抽象）
- x->f(联系、映射)->y,y=f(x)
- **函数式编程中的函数指的不是程序中的函数（方法）**，而是数学中的函数即映射关系，例如：**y=sin(x)**,x和y的关系
- **相同的输入始终要得到相同的输出**（纯函数）
- 函数式编程用来描述数据（函数）之间的映射
- 函数式编程的一个好处就是可以让代码进行重用

- 



#### 函数是一等公民

- 函数可以存储在变量中

- 在JavaScript 中函数就是一个普通的对象（可以通过new Function()）,我们可以把函数存储到变量、数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过new Function('alert(1)')来构造一个新的函数。

- 代码

  ```javascript
  // 把函数赋值给变量
  let fn = function () {
    console.log(Hello First-class Function);
  };
  fu();
  
  // 一个示例
  
  const BlogController = {
    index(posts){return Views.index(posts)},
    show(post){return Views.show(post)},
    create(attrs){return Db.create(attrs)},
    update(post,attrs){return Db.update(post,attrs)},
    destroy(post){return Db.destroy(post)},
  }
  
  // 优化
  // 一个函数包裹另一个函数，并且它的形式也相同的时候，可以优化，就是正常的简写
  const BlogController = {
    index:Views.index,
    show:Views.show,
    create:Db.create,
    update:Db.update,
    destroy:Db.destroy,
  }
  
  ```

  

- 函数是一等公民是我们后面要学习的高阶函数、柯里化等的基础。



#### 高阶函数

- 什么是高阶函数

  - 高阶函数（Higher-order function）

    - 可以把函数作为参数传递给另一个函数
    - 可以把函数作为另一个函数的返回结果
    - React中有一个概念，Higher-order-component,本质上就是高阶函数

  - 函数作为参数

    ```javascript
    // 高阶函数-函数作为参数
    function forEach(array, fn) {
      for (let index = 0; index < array.length; index++) {
        fn(array[index]);
      }
    }
    let numberList = [1, 3, 5, 6, 7, 8];
    // forEach(numberList, function (value) {
    //   console.log(value);
    // });
    
    function filter(array, fn) {
      let results = [];
      for (let index = 0; index < array.length; index++) {
        if (fn(array[index])) {
          results.push(array[index]);
        }
      }
      return results;
    }
    
    let res = filter(numberList, function (value) {
      return value % 2 === 0;
    });
    
    console.log(res);
    
    ```

    - 更加灵活了

  - 函数作为返回值

    - 代码

      ```javascript
      function makeFn() {
        let msg = "hello function";
        return function () {
          console.log(msg);
        };
      }
      // const fn = makeFn();
      // console.log(fn());
      
      // makeFn()();
      
      // jQuery中有一个once函数，Lodash中也有一个这个函数。目的是为了让函数只调用一次，使用场景例如：支付的时候，无论点击多少次，就只能调用一次。
      
      function once(fn) {
        let done = false;
        return function () {
          if (!done) {
            done = true;
            return fn.apply(this, arguments);
          }
        };
      }
      
      let pay = once(function (money) {
        console.log("---支付,", money + "元");
      });
      
      pay(4);
      
      ```

      

    - 

- 使用高阶函数的意义

  - 抽象可以帮助我们屏蔽细节，只需要关注与我们的目标
  - 高阶函数是用来抽象通用的问题
  - 
    - ![image-20220507085540681](%E7%AC%94%E8%AE%B0.assets/image-20220507085540681.png)
  - 

- 常见的高阶函数（比如 map、every、some）

  - ```javascript
    // map every some 高阶函数实现
    
    // map
    let arr = [1, 2, 3, 5, 7, 8];
    function map(array, fn) {
      let results = [];
      for (let item of array) {
        results.push(fn(item));
      }
      return results;
    }
    
    // console.log(map(arr, (v) => v * v));
    
    // every
    function every(array, fn) {
      let flag = false;
      for (let item of array) {
        flag = fn(item);
        if (!flag) {
          break;
        }
      }
      return flag;
    }
    // console.log(every(arr, (v) => v > 3));
    
    // some
    function some(array, fn) {
      let flag = false;
      for (let item of array) {
        flag = fn(item);
        if (flag) {
          break;
        }
      }
      return flag;
    }
    
    console.log(some(arr, (v) => v > 3));
    
    ```

  - 

- 



#### 闭包

- 闭包（Closure）:函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包。
  - 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。
  - 
    - ![image-20220509011225249](%E7%AC%94%E8%AE%B0.assets/image-20220509011225249.png)
    - ![image-20220509011300349](%E7%AC%94%E8%AE%B0.assets/image-20220509011300349.png)
    -  
  - 闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。

##### 闭包-案例

- call Stack 调用栈 Scope作用域，进入makePower方法的时候，makePower函数进入栈顶，Local是这个函数内部的局部作用域， this指向的是window,
  - ![image-20220517215606890](%E7%AC%94%E8%AE%B0.assets/image-20220517215606890.png)
  - 当一个函数执行完之后，这个函数会在调用栈上移除掉
    - ![image-20220517215933417](%E7%AC%94%E8%AE%B0.assets/image-20220517215933417.png)
  - Closure闭包
    - ![image-20220517220139252](%E7%AC%94%E8%AE%B0.assets/image-20220517220139252.png)

#### 纯函数概念

- 纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

- 概念

  - ![image-20220517221141561](%E7%AC%94%E8%AE%B0.assets/image-20220517221141561.png)

  - 例子

    ```javascript
    // 纯函数和不纯的函数
    // slice / splice
    
    let array = [1, 2, 3, 4, 5];
    
    // 纯函数
    console.log(array.slice(0, 3));
    console.log(array.slice(0, 3));
    console.log(array.slice(0, 3));
    
    // 不纯的函数
    console.log(array.splice(0, 3));
    console.log(array.splice(0, 3));
    console.log(array.splice(0, 3));
    
    // 纯函数
    
    function getSum(n1, n2) {
      return n1 + n2;
    }
    console.log(getSum(1, 2));
    console.log(getSum(1, 2));
    console.log(getSum(1, 2));
    ```

    

  - 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的） 

  - 我们可以把一个函数的执行结果交给另一个函数去处理

#### Lodash

1. 初始化一个package.json
   npm init -y

2. 加载lodash 插件
   npm install lodash  或者 npm i lodash

3. 代码

   ```javascript
   // 演示lodash
   // first / last / toUpper / reverse /each /includes /find /findIndex
   const _ = require("lodash");
   
   const array = ["jack", "tom", "lucky", "kate"];
   
   console.log(_.first(array));
   console.log(_.last(array));
   console.log(_.toUpper(_.first(array)));
   console.log(_.reverse(array));
   console.log(
     _.each(array, (item, index) => {
       console.log(item, index);
     })
   );
   
   ```

   

4. 

#### 纯函数的好处

- 可缓存
  - 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来，比如我们有某个函数，这个函数执行起来特别耗时，每次调用这个函数的时候都要等一段时间才能获取到这个结果，我们想提交这个性能的话，可以把第一次的结果缓存起来。第二次调用的时候，直接拿这个结果。
    
    - 
    
  - 自己模拟一个memoize函数
  
    ```javascript
    // 记忆函数
    const _ = require("lodash");
    
    function getArea(r) {
      console.log(r);
      return Math.PI * r * r;
    }
    
    // let getAreaWithMemory = _.memoize(getArea);
    // console.log(getAreaWithMemory(4));
    // console.log(getAreaWithMemory(4));
    // console.log(getAreaWithMemory(4));
    
    //模拟memoize 方法的实现
    function memoize(f) {
      let cash = {};
      return function () {
        console.log("---arguments,", arguments, JSON.stringify(arguments));
        let key = JSON.stringify(arguments);
        cash[key] = cash[key] || f.apply(f, arguments);
        console.log("---cash,", cash);
        return cash[key];
      };
    }
    
    let getAreaWithMemory = memoize(getArea);
    console.log(getAreaWithMemory(4));
    console.log(getAreaWithMemory(4));
    console.log(getAreaWithMemory(4));
    
    ```
  
  - 其他有点
  
    - 可测试
      - 纯函数让测试更方便,因为纯函数始终有输入和输出，因为单元测试始终在调研这个函数的结果。
    - 并行处理
      - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
      - 纯函数不需要访问共享的内存数据（比如全局变量），所以并行环境下可以任意运行纯函数（Web worker），多数时候我们使用js的单线程去处理，ES6有一个Web worker多线程。
    - 
  
  - 
- 

#### 副作用

- 纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

  ```javascript
  // 不纯
  let mini = 18;
  
  function getAge(age) {
    return age > mini;
  }
  
  // 纯的，有硬编码，后续可以用柯里化来解决
  function checkAge(age) {
    let mini = 18;
    return age > mini;
  }
  ```

  

- 副作用会让一个函数变得不纯（如上例），纯函数根据相同的输入返回相同的输出，如果函数依赖外部的状态就无法保证输出相同，就会带来副作用。

- 副作用来源：

  - 配置文件
  - 数据库
  - 获取用户的输入
  - 。。。。。。

- 所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合拓展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

- 

#### 柯里化 （Haskell Brooks Curry）

- 使用柯里化解决上一个案例中硬编码的问题

  ```javascript
  // // 普通的纯函数
  // function checkAge(min, age) {
  //   return age >= min;
  // }
  // console.log(checkAge(18, 20));
  // console.log(checkAge(18, 24));
  // console.log(checkAge(22, 24));
  
  // 函数的柯里化
  // function checkAge(min) {
  //   return function (age) {
  //     return age >= min;
  //   };
  // }
  
  // 箭头函数改写
  
  const checkAge = (min) => (age) => age >= min;
  
  let checkAge18 = checkAge(18);
  let checkAge20 = checkAge(20);
  
  console.log(checkAge18(22));
  console.log(checkAge18(24));
  console.log(checkAge18(13));
  
  ```

  

- 柯里化（Curring）:

  - 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
  - 然后返回一个新的函数接收剩余的参数，返回结果

- 

#### Lodash中的柯里化

- _.curry(func)

  - 功能：创建一个函数，该函数接收 `func` 的参数，要么调用`func`返回的结果，如果 `func` 所需参数已经提供，则直接返回 `func` 所执行的结果。或返回一个函数，接受余下的`func` 参数的函数，可以使用 `func.length` 强制需要累积的参数个数。
  - 参数：需要柯里化的函数
  - 返回值：柯里化后的函数

- 代码

  ```javascript
  // // lodash 中curry的基本使用
  const _ = require("lodash");
  function getSum(a, b, c) {
    return a + b + c;
  }
  const curried = _.curry(getSum);
  console.log(curried(1, 2, 3));
  console.log(curried(1)(2, 3));
  console.log(curried(1, 2)(3));
  
  ```

  

- 

#### 柯里化案例

- 代码

  ```javascript
  // 柯里化案例
  // "".match(/\s+/g);
  // "".match(/\d+/g);
  
  const _ = require("lodash");
  
  // 普通方法匹配
  // function matchStr(reg, str) {
  //   return str.match(reg);
  // }
  
  // 使用柯里化的方式
  const match = _.curry(function (reg, str) {
    return str.match(reg);
  });
  
  const haveSpace = match(/\s+/g);
  const haveNumber = match(/\d+/g);
  
  // 会把空白字符给提取出来，返回一个数组的形式 [ ' ' ]
  // console.log(haveSpace("hello world"));
  // // 没有空格， 没有匹配到，返回null
  // console.log(haveSpace("helloworld"));
  // console.log(haveNumber("abc"));
  
  // 写一个filter的柯里化函数
  const filter = _.curry(function (fun, array) {
    return array.filter(fun);
  });
  
  console.log(filter(haveSpace, ["ab c", "ab_c"]));
  
  // 另一种写法
  
  const filterSpace = filter(haveSpace);
  console.log(filterSpace(["ab c", "ab_c"]));
  
  ```

  

- 

#### 柯里化原理模拟

- 代码

  ```javascript
  // 模拟实现lodash中的curry方法
  const _ = require("lodash");
  function getSum(a, b, c) {
    return a + b + c;
  }
  const curried = _.curry(getSum);
  console.log(curried(1, 2, 3));
  console.log(curried(1)(2, 3));
  console.log(curried(1, 2)(3));
  
  function curry(func) {
    return function curried(...args) {
      if (args.length < func.length) {
        return function () {
          return curried(...args.concat(Array.from(arguments)));
        };
      }
      return func(...args);
    };
  }
  
  const curriedmoni = curry(getSum);
  console.log(curriedmoni(1, 2, 3));
  console.log(curriedmoni(1)(2, 3));
  console.log(curriedmoni(1, 2)(3));
  
  ```

  

- 

#### 柯里化总结

- 总结
  - ![image-20220523212812664](%E7%AC%94%E8%AE%B0.assets/image-20220523212812664.png)
- 

#### 函数组合概念

- 函数组合

  - ![image-20220523212934993](%E7%AC%94%E8%AE%B0.assets/image-20220523212934993.png)

- 管道

  - ![image-20220523213106562](%E7%AC%94%E8%AE%B0.assets/image-20220523213106562.png)
  - 

- 函数组合

  - 函数组合（compose）:如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
    - 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果。
    - 函数组合默认是从右到左执行
  - 

- 代码

  ```javascript
  // 函数组合
  function compose(f, g) {
    return function (value) {
      return f(g(value));
    };
  }
  
  function reverse(array) {
    return array.reverse();
  }
  function first(array) {
    return array[0];
  }
  
  const last = compose(first, reverse);
  console.log(last([1, 2, 3, 4]));
  
  ```

  



#### Lodash 中的组合函数

- lodash中的组合函数

  - lodash中的组合函数flow()或flowRight(),他们都可以组合多个函数
  - flow() 是从左到右运行
  - flowRight()是从右到左运行，使用的更多一些

- 代码

  ```javascript
  // lodash中函数组合方法 _.flowRight()
  const _ = require("lodash");
  const reverse = (arr) => arr.reverse();
  const first = (arr) => arr[0];
  const upperCase = (s) => s.toUpperCase();
  const compose = _.flowRight(upperCase, first, reverse);
  
  console.log(compose(["one", "two", "three", "four"]));
  ```

  

- 

#### 函数组合的实现原理

- 代码

  ```javascript
  // 模拟lodash中的flowRight
  const _ = require("lodash");
  const reverse = (arr) => arr.reverse();
  const first = (arr) => arr[0];
  const upperCase = (s) => s.toUpperCase();
  // const f = _.flowRight(upperCase, first, reverse);
  // console.log(f(["one", "two", "three"]));
  
  function compose(...args) {
    return function (value) {
      return args.reverse().reduce((acc, fn) => {
        return fn(acc);
      }, value);
    };
  }
  let f = compose(upperCase, first, reverse);
  console.log(f(["one", "two", "three"]));
  
  ```

  

- 

#### 函数组合-结合律

- 代码

  ```javascript
  // lodash中函数组合方法 _.flowRight()
  const _ = require("lodash");
  
  // const f = _.flowRight(_.upperCase, _.first, _.reverse);
  // const f = _.flowRight(_.flowRight(_.upperCase, _.first), _.reverse);
  const f = _.flowRight(_.upperCase, _.flowRight(_.first, _.reverse));
  
  console.log(f(["one", "two", "three", "four"]));
  
  ```

  

- 

#### 函数组合-调试

- 调试

  - 如何调试组合函数

- 代码

  ```javascript
  // 函数组合 调试
  // NEVER SAY DIE --> never-say-die
  
  const { flowRight } = require("lodash");
  const _ = require("lodash");
  
  // const log = (v) => {
  //   console.log(v);
  //   return v;
  // };
  
  const trace = _.curry((tag, v) => {
    console.log(tag, v);
    return v;
  });
  
  // _.split()
  const split = _.curry((sep, str) => _.split(str, sep));
  
  // _.toLower()
  
  const join = _.curry((sep, array) => _.join(array, sep));
  const map = _.curry((fn, array) => _.map(array, fn));
  // 我们需要返回的是数组，
  const f = flowRight(
    join("-"),
    trace("map之后"),
    map(_.toLower),
    trace("split之后"),
    split(" ")
  );
  // const f = flowRight(join("-"), log, _.toLower, split(" "));
  
  console.log(f("NEVER SAY DIE"));
  
  ```

  

- 

#### Lodash-fp模块

- lodash/fp

  - lodash的fp模块提供了实用的对函数式编程友好的方法

  - 提供了不可变auto-curried iteratee-first data-last 的方法 （函数优先，数据滞后）

  - lodash 模块 与 lodash/fp模块 比对

    - ![image-20220528192202388](%E7%AC%94%E8%AE%B0.assets/image-20220528192202388.png)

  - 代码,可以与之前lodash写的做比对

    ```javascript
    // lodash 中的fp模块
    // NEVER SAY DIE --> never-say-die
    
    const fp = require('lodash/fp')
    
    const f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '))
    
    console.log(f('NEVER SAY DIE'))
    
    ```

    

  - 

- 

  

#### Lodash中的FP模块，map方法的区别

- 代码, 二进制的数字只有0 1

  ```javascript
  // lodash 和 lodash中的fp模块，map方法的区别
  // 小技巧，vscode，输入方法（）的时候，能看到方法需要传入的参数，iteratee 是函数的意思
  
  const _ = require('lodash')
  
  // 打印的值为 [ 23, NaN, 2 ]，为什么会这样，因为parseInt 的第二个参数是转化进制，
  console.log(_.map(['23', '8', '10'], parseInt))
  // 模拟上面函数parseInt的执行，0是10进制，1没有这个定义，2是二进制，所以打印出NaN
  // parseInt('23',0,array)
  // parseInt('8',1,array)
  // parseInt('10',2,array)
  
  const fp = require('lodash/fp')
  // [ 23, 8, 10 ],打印出正常的值，这个fp中的parseInt 只需要处理数组中的每一个元素，lodash中的parseInt的方法需要传入3个参数
  console.log(fp.map(parseInt, ['23', '8', '10']))
  
  ```

  

- 经典面试题

  ```javascript
  ["1", "2", "3"].map(parseInt)
  
  首先， map接受两个参数， 一个回调函数 callback， 一个回调函数的this值
  其中回调函数接受三个参数 currentValue， index， arrary;
  而题目中， map只传入了回调函数--parseInt.
  其次， parseInt 只接受两个两个参数 string， radix(基数).
  在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：
  如果字符串 string 以"0x"或者"0X"开头， 则基数是16 (16进制).
  如果字符串 string 以"0"开头， 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
  如果字符串 string 以其它任何值开头，则基数是10 (十进制)。
  所以本题即问
  parseInt('1', 0);
  parseInt('2',1);
  parseInt('3', 2);
  首先后两者参数不合法.
  所以答案是 [1, NaN, NaN]
  
  ```

  

- 

#### Point Free

- Point Free:我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

  - 不需要指明处理的数据
  - 只需要合成运算过程
  - 需要定义一些辅助的基本运算函数
  - 案例演示
    - ![image-20220529013454194](%E7%AC%94%E8%AE%B0.assets/image-20220529013454194.png)
  - 

- 代码

  ```javascript
  // point free
  // Hello   World --> hello_world
  
  // 非 point free 模式
  const _ = require('lodash')
  const fp = require('lodash/fp')
  
  const compoise = word => {
    return word.toLowerCase().replace(/\s+/g, '_')
  }
  console.log(compoise('Hello   World'))
  
  // point free 模式
  
  const f = fp.flowRight(fp.replace(/\s+/g, '_'), fp.toLower)
  console.log(f('Hello   World'))
  
  ```

  

- 

#### Pointfree 案例

- 代码

  ```javascript
  // 把一个字符串中的首字母提取并转换成大写，使用 . 作为分隔符
  // world wild web --> W. W. W
  
  const fp = require('lodash/fp')
  
  // 这边使用了两次fp.map，做了两次循环，我们能不能只做一次循环
  // const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.first), fp.map(fp.toUpper), fp.split(' '))
  
  const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(' '))
  console.log(firstLetterToUpper('world wild web'))
  
  ```

  

- 

#### Functor(函子)

- 为什么要学函子

  - 到目前为止已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。

- 什么是Functor

  - 容器：包含值和值的变形关系（这个变形关系就是函数）
  - 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理（变形关系）

- 代码

  ```javascript
  // Functor 函子
  
  // class Container {
  //   constructor(value) {
  //     this._value = value
  //   }
  
  //   map(fn) {
  //     return new Container(fn(this._value))
  //   }
  // }
  
  // 调用的时候不像函数式编程，像面向对象，所以创建static 静态方法内部使用构造函数创建对象
  // let r = new Container(5).map(x => x + 1).map(x => x * x)
  
  // console.log(r)
  
  class Container {
    static of(value) {
      return new Container(value)
    }
    constructor(value) {
      this._value = value
    }
    map(fn) {
      return Container.of(fn(this._value))
    }
  }
  
  let r = Container.of(5)
    .map(x => x + 2)
    .map(x => x * x)
  console.log(r)
  
  ```

  

- 

#### Functor总结

- 总结

  - 函数式编程的运算不直接操作值，而是由函子完成
  - 函子就是一个实现了map契约的对象
  - 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
  - 想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
  - 最终map方法返回一个包含新值的盒子（函子）

- 因为纯函数相同的输入必须要有相同的输出，输入null，报错，就变得不纯了

  - 代码

    ```javascript
    class Container {
      static of(value) {
        return new Container(value)
      }
      constructor(value) {
        this._value = value
      }
      map(fn) {
        return Container.of(fn(this._value))
      }
    }
    
    // let r = Container.of(5)
    //   .map(x => x + 2)
    //   .map(x => x * x)
    // console.log(r)
    
    // 演示 null undefined 的问题
    
    // Cannot read property 'toUpperCase' of null
    Container.of(null).map(x => x.toUpperCase())
    ```

    



#### MayBe函子

- 可能会是空值的情况，我们使用MayBe函子 

- MayBe函子

  - 我们在编程的过程中可能会遇到很多错误，需要对这些错误做相对应的处理
  - MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在合理的范围内）

- 代码

  ```javascript
  // MayBe 函子
  
  class MayBe {
    static of(value) {
      return new MayBe(value)
    }
    constructor(value) {
      this._value = value
    }
  
    map(fn) {
      // 返回前对this._value进行空值判断
      return this.isNothing ? MayBe.of(null) : fn(this._value)
    }
  
    isNothing() {
      return this._value === null || this._value === undefined
    }
  }
  
  // MayBe { _value: null }
  // let r = MayBe.of('hello world').map(x => x.toUpperCase())
  
  // 会得到null的结果，但是我们不知道什么时候出现的（虽然我们可以出现空值，但是多次调用map的时候，哪一次出现空值，我们是不明确的），这个时候我们需要Either函子
  // MayBe { _value: null }
  let r = MayBe.of('hello world')
    .map(x => x.toUpperCase())
    .map(x => null)
    .map(x => x.split(' '))
  console.log(r)
  
  ```

  



#### Either函子

- Either函子

  - Either两者中的任何一个，类似于if...else...的处理
  - 异常会让函数变得不纯，Either函子可以用来做异常处理

- 代码

  ```javascript
  // Either 函子
  
  class Left {
    static of(value) {
      return new Left(value)
    }
    constructor(value) {
      this._value = value
    }
    map() {
      return this
    }
  }
  
  class Right {
    static of(value) {
      return new Right(value)
    }
    constructor(value) {
      this._value = value
    }
    map(fn) {
      return Right.of(fn(this._value))
    }
  }
  
  function parseJSON(str) {
    try {
      return Right.of(JSON.parse(str))
    } catch (e) {
      return Left.of({ error: e.message })
    }
  }
  
  // 演示错误案例
  // Left { _value: { error: 'Unexpected token n in JSON at position 1' } }
  // let r = parseJSON('{name:ds}')
  // console.log(r)
  
  // Right { _value: 'DS' }
  let r = parseJSON('{"name":"ds"}').map(x => x.name.toUpperCase())
  console.log(r)
  
  ```

  

- 

#### IO函子

- IO函子
  - IO函子中的_value 是一个函数，这里是把函数作为值来处理
  - IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作为纯函数
  - 把不纯的操作交给调用者来处理
  - 截图
    - ![image-20220529223515174](%E7%AC%94%E8%AE%B0.assets/image-20220529223515174.png)
  - 
  
- 代码

  ```javascript
  // IO 函子
  const fp = require('lodash/fp')
  
  class IO {
    static of(value) {
      return new IO(function () {
        return value
      })
    }
  
    constructor(fn) {
      this._value = fn
    }
  
    map(fn) {
      return new IO(fp.flowRight(fn, this._value))
    }
  }
  
  // 因为当前使用node 运行，有进程这个值
  let r = IO.of(process).map(p => p.execPath)
  console.log(r)
  console.log(r._value())
  
  ```

  

- 

#### Folktale

- Task异步执行

  - 异步任务的实现过于复杂，我们使用folktale中的Task来演示
  - [folktale](https://folktale.origamitower.com/)一个标准的函数式编程库
    - 和lodash、ramda不同的是，他没有提供很多功能函数
    - 只提供了一些函数式处理的操作，例如：compose、curry等，一些函子 Task、Either、MayBe等
    - ![image-20220608224938315](%E7%AC%94%E8%AE%B0.assets/image-20220608224938315.png)

- 步骤

  - npm install folktale

  - 代码

    ```javascript
    // folktale 中的compose 、 curry
    
    const { compose, curry } = require('folktale/core/lambda')
    const { first, toUpper } = require('lodash/fp')
    
    // curry 使用
    // let f = curry(2, function (x, y) {
    //   return x + y
    // })
    
    // 3 3
    // console.log(f(1, 2))
    // console.log(f(1)(2))
    
    // compose 使用
    
    // 跟lodash/fp中的flowRight一样，也是从右往左执行
    let r = compose(toUpper, first)
    // ONE
    console.log(r(['one', 'two']))
    
    ```

    

  - 

- 

#### s

#### d

#### e

#### 3 

### 函数式编程的特性（纯函数、柯里化、函数组合等）

### 函数式编程的应用场景

### 函数式编程库 Lodash

## 

# 前端工程化实战

### 

# Vue.js 框架源码与进阶

# React 框架原理与实战

What is React

React是一个用于构建用户界面的JavaScript库，它只负责应用的视图层，帮助开发人员构建快速且交互式的Web应用程序。

React使用组件的方式构建用户界面。

## JSX 语法 

在React中使用JSX语法描述用户界面，它是一种JavaScript语法拓展。

在React代码执行之前，Babel会将JSX语法转换为标准的JavaScript API。

JSX语法就是一种语法糖，让开发人员使用更加舒服的代码构建用户界面。

### 在JSX中使用表达式

```javascript
const user = {
    firstName:'liu',
    lastName:'cao'
}
function formatName(user){
    return user.firstName + '' + user.lastName;
}
const element = <h1>Hello,{formatName(user)}</h1>;
```

JSX本身其实也是一种表达式，将它赋值给变量，当做参数传入，作为返回值都可以。

```javascript
function formatName(user){
    if(user){
        return <h1>Hello,{formatName(user)}</h1>;
       }
   return <h1>Hello,Stranger</h1>;
}
```

### 属性

- ![image-20220524123005336](%E7%AC%94%E8%AE%B0.assets/image-20220524123005336.png)
- ![image-20220524123158083](%E7%AC%94%E8%AE%B0.assets/image-20220524123158083.png)
- ![image-20220524123629721](%E7%AC%94%E8%AE%B0.assets/image-20220524123629721.png)
- ![image-20220524123718408](%E7%AC%94%E8%AE%B0.assets/image-20220524123718408.png)
- ![image-20220524123753737](%E7%AC%94%E8%AE%B0.assets/image-20220524123753737.png)
- ![ ](%E7%AC%94%E8%AE%B0.assets/image-20220524123803003.png)
- 

## 组件

- <img src="%E7%AC%94%E8%AE%B0.assets/image-20220524123856042.png" style="zoom:200%;" />
- ![image-20220524123924412](%E7%AC%94%E8%AE%B0.assets/image-20220524123924412.png)
- ![image-20220524123947922](%E7%AC%94%E8%AE%B0.assets/image-20220524123947922.png)
- ![image-20220524124003319](%E7%AC%94%E8%AE%B0.assets/image-20220524124003319.png)
- ![image-20220524124019387](%E7%AC%94%E8%AE%B0.assets/image-20220524124019387.png)
- ![image-20220524124042174](%E7%AC%94%E8%AE%B0.assets/image-20220524124042174.png)
- ![image-20220524124050325](%E7%AC%94%E8%AE%B0.assets/image-20220524124050325.png)
- 生命周期
  - ![image-20220524124127011](%E7%AC%94%E8%AE%B0.assets/image-20220524124127011.png )
  - ![image-20220524124145243](%E7%AC%94%E8%AE%B0.assets/image-20220524124145243.png)
  - ![image-20220524124202161](%E7%AC%94%E8%AE%B0.assets/image-20220524124202161.png)
  - 
- 

## 表单

### 受控表单

- ![image-20220524124311566](%E7%AC%94%E8%AE%B0.assets/image-20220524124311566.png)

### 非受控表单

- ![image-20220524124320730](%E7%AC%94%E8%AE%B0.assets/image-20220524124320730.png)

### 路由

#### 路由基本使用

- ![image-20220524124435639](%E7%AC%94%E8%AE%B0.assets/image-20220524124435639.png)

### 都是

### 是

# Node.js 全栈开发

# 泛客户端开发

# 商业技术解决方案与高阶技术

# 