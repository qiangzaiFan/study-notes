函数式编程

### 为什么要学习函数式编程以及什么是函数式编程

#### 为什么要学习函数式编程？

- 函数式编程随着React的流行受到越来越多的关注
- Vue3也开始拥抱函数式编程
- 函数式编程可以抛弃this
- 打包过程中可以更好的利用tree shaking过滤无用代码
- 方便测试，方便并行处理
- 有很多库可以帮助我们进行函数式开发：lodash、underscore、ramda

#### 什么是函数式编程

函数式编程(Functional Programming, FP)是编程范式之一，我们常听说的编程范式还有面向过程编程、面向对象编程。

- 面向对象编程的思维方式：把现实世界中的事物抽象成程序世界中的类和对象，通过封装、继承和多态来演示事物事件的联系
- 函数式编程的思维方式：把现实世界的事物和事物之间的**联系**抽象到程序世界（对运算过程进行抽象）
- x->f(联系、映射)->y,y=f(x)
- **函数式编程中的函数指的不是程序中的函数（方法）**，而是数学中的函数即映射关系，例如：**y=sin(x)**,x和y的关系
- **相同的输入始终要得到相同的输出**（纯函数）
- 函数式编程用来描述数据（函数）之间的映射
- 函数式编程的一个好处就是可以让代码进行重用

- 



#### 函数是一等公民

- 函数可以存储在变量中

- 在JavaScript 中函数就是一个普通的对象（可以通过new Function()）,我们可以把函数存储到变量、数组中，它还可以作为另一个函数的参数和返回值，甚至我们可以在程序运行的时候通过new Function('alert(1)')来构造一个新的函数。

- 代码

  ```javascript
  // 把函数赋值给变量
  let fn = function () {
    console.log(Hello First-class Function);
  };
  fu();
  
  // 一个示例
  
  const BlogController = {
    index(posts){return Views.index(posts)},
    show(post){return Views.show(post)},
    create(attrs){return Db.create(attrs)},
    update(post,attrs){return Db.update(post,attrs)},
    destroy(post){return Db.destroy(post)},
  }
  
  // 优化
  // 一个函数包裹另一个函数，并且它的形式也相同的时候，可以优化，就是正常的简写
  const BlogController = {
    index:Views.index,
    show:Views.show,
    create:Db.create,
    update:Db.update,
    destroy:Db.destroy,
  }
  
  ```

  

- 函数是一等公民是我们后面要学习的高阶函数、柯里化等的基础。



#### 高阶函数

- 什么是高阶函数

  - 高阶函数（Higher-order function）

    - 可以把函数作为参数传递给另一个函数
    - 可以把函数作为另一个函数的返回结果
    - React中有一个概念，Higher-order-component,本质上就是高阶函数

  - 函数作为参数

    ```javascript
    // 高阶函数-函数作为参数
    function forEach(array, fn) {
      for (let index = 0; index < array.length; index++) {
        fn(array[index]);
      }
    }
    let numberList = [1, 3, 5, 6, 7, 8];
    // forEach(numberList, function (value) {
    //   console.log(value);
    // });
    
    function filter(array, fn) {
      let results = [];
      for (let index = 0; index < array.length; index++) {
        if (fn(array[index])) {
          results.push(array[index]);
        }
      }
      return results;
    }
    
    let res = filter(numberList, function (value) {
      return value % 2 === 0;
    });
    
    console.log(res);
    
    ```

    - 更加灵活了

  - 函数作为返回值

    - 代码

      ```javascript
      function makeFn() {
        let msg = "hello function";
        return function () {
          console.log(msg);
        };
      }
      // const fn = makeFn();
      // console.log(fn());
      
      // makeFn()();
      
      // jQuery中有一个once函数，Lodash中也有一个这个函数。目的是为了让函数只调用一次，使用场景例如：支付的时候，无论点击多少次，就只能调用一次。
      
      function once(fn) {
        let done = false;
        return function () {
          if (!done) {
            done = true;
            return fn.apply(this, arguments);
          }
        };
      }
      
      let pay = once(function (money) {
        console.log("---支付,", money + "元");
      });
      
      pay(4);
      
      ```

      

    - 

- 使用高阶函数的意义

  - 抽象可以帮助我们屏蔽细节，只需要关注与我们的目标
  - 高阶函数是用来抽象通用的问题
  - 
    - ![image-20220507085540681](%E7%AC%94%E8%AE%B0.assets/image-20220507085540681.png)
  - 

- 常见的高阶函数（比如 map、every、some）

  - ```javascript
    // map every some 高阶函数实现
    
    // map
    let arr = [1, 2, 3, 5, 7, 8];
    function map(array, fn) {
      let results = [];
      for (let item of array) {
        results.push(fn(item));
      }
      return results;
    }
    
    // console.log(map(arr, (v) => v * v));
    
    // every
    function every(array, fn) {
      let flag = false;
      for (let item of array) {
        flag = fn(item);
        if (!flag) {
          break;
        }
      }
      return flag;
    }
    // console.log(every(arr, (v) => v > 3));
    
    // some
    function some(array, fn) {
      let flag = false;
      for (let item of array) {
        flag = fn(item);
        if (flag) {
          break;
        }
      }
      return flag;
    }
    
    console.log(some(arr, (v) => v > 3));
    
    ```

  - 

- 



#### 闭包

- 闭包（Closure）:函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包。
  - 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员。
  - 
    - ![image-20220509011225249](%E7%AC%94%E8%AE%B0.assets/image-20220509011225249.png)
    - ![image-20220509011300349](%E7%AC%94%E8%AE%B0.assets/image-20220509011300349.png)
    -  
  - 闭包的本质：函数在执行的时候会放到一个执行栈上当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员。

##### 闭包-案例

- call Stack 调用栈 Scope作用域，进入makePower方法的时候，makePower函数进入栈顶，Local是这个函数内部的局部作用域， this指向的是window,
  - ![image-20220517215606890](%E7%AC%94%E8%AE%B0.assets/image-20220517215606890.png)
  - 当一个函数执行完之后，这个函数会在调用栈上移除掉
    - ![image-20220517215933417](%E7%AC%94%E8%AE%B0.assets/image-20220517215933417.png)
  - Closure闭包
    - ![image-20220517220139252](%E7%AC%94%E8%AE%B0.assets/image-20220517220139252.png)

#### 纯函数概念

- 纯函数：相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

- 概念

  - ![image-20220517221141561](%E7%AC%94%E8%AE%B0.assets/image-20220517221141561.png)

  - 例子

    ```javascript
    // 纯函数和不纯的函数
    // slice / splice
    
    let array = [1, 2, 3, 4, 5];
    
    // 纯函数
    console.log(array.slice(0, 3));
    console.log(array.slice(0, 3));
    console.log(array.slice(0, 3));
    
    // 不纯的函数
    console.log(array.splice(0, 3));
    console.log(array.splice(0, 3));
    console.log(array.splice(0, 3));
    
    // 纯函数
    
    function getSum(n1, n2) {
      return n1 + n2;
    }
    console.log(getSum(1, 2));
    console.log(getSum(1, 2));
    console.log(getSum(1, 2));
    ```

    

  - 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的） 

  - 我们可以把一个函数的执行结果交给另一个函数去处理

#### Lodash

1. 初始化一个package.json
   npm init -y

2. 加载lodash 插件
   npm install lodash  或者 npm i lodash

3. 代码

   ```javascript
   // 演示lodash
   // first / last / toUpper / reverse /each /includes /find /findIndex
   const _ = require("lodash");
   
   const array = ["jack", "tom", "lucky", "kate"];
   
   console.log(_.first(array));
   console.log(_.last(array));
   console.log(_.toUpper(_.first(array)));
   console.log(_.reverse(array));
   console.log(
     _.each(array, (item, index) => {
       console.log(item, index);
     })
   );
   
   ```

   

4. 

#### 纯函数的好处

- 可缓存
  - 因为纯函数对相同的输入始终有相同的结果，所以可以把纯函数的结果缓存起来，比如我们有某个函数，这个函数执行起来特别耗时，每次调用这个函数的时候都要等一段时间才能获取到这个结果，我们想提交这个性能的话，可以把第一次的结果缓存起来。第二次调用的时候，直接拿这个结果。
    
    - 
    
  - 自己模拟一个memoize函数
  
    ```javascript
    // 记忆函数
    const _ = require("lodash");
    
    function getArea(r) {
      console.log(r);
      return Math.PI * r * r;
    }
    
    // let getAreaWithMemory = _.memoize(getArea);
    // console.log(getAreaWithMemory(4));
    // console.log(getAreaWithMemory(4));
    // console.log(getAreaWithMemory(4));
    
    //模拟memoize 方法的实现
    function memoize(f) {
      let cash = {};
      return function () {
        console.log("---arguments,", arguments, JSON.stringify(arguments));
        let key = JSON.stringify(arguments);
        cash[key] = cash[key] || f.apply(f, arguments);
        console.log("---cash,", cash);
        return cash[key];
      };
    }
    
    let getAreaWithMemory = memoize(getArea);
    console.log(getAreaWithMemory(4));
    console.log(getAreaWithMemory(4));
    console.log(getAreaWithMemory(4));
    
    ```
  
  - 其他有点
  
    - 可测试
      - 纯函数让测试更方便,因为纯函数始终有输入和输出，因为单元测试始终在调研这个函数的结果。
    - 并行处理
      - 在多线程环境下并行操作共享的内存数据很可能会出现意外情况
      - 纯函数不需要访问共享的内存数据（比如全局变量），所以并行环境下可以任意运行纯函数（Web worker），多数时候我们使用js的单线程去处理，ES6有一个Web worker多线程。
    - 
  
  - 
- 

#### 副作用

- 纯函数：对于相同的输入永远会得到相同的输出，而且没有任何可观察的副作用

  ```javascript
  // 不纯
  let mini = 18;
  
  function getAge(age) {
    return age > mini;
  }
  
  // 纯的，有硬编码，后续可以用柯里化来解决
  function checkAge(age) {
    let mini = 18;
    return age > mini;
  }
  ```

  

- 副作用会让一个函数变得不纯（如上例），纯函数根据相同的输入返回相同的输出，如果函数依赖外部的状态就无法保证输出相同，就会带来副作用。

- 副作用来源：

  - 配置文件
  - 数据库
  - 获取用户的输入
  - 。。。。。。

- 所有的外部交互都有可能带来副作用，副作用也使得方法通用性下降不适合拓展和可重用性，同时副作用会给程序中带来安全隐患给程序带来不确定性，但是副作用不可能完全禁止，尽可能控制它们在可控范围内发生。

- 

#### 柯里化 （Haskell Brooks Curry）

- 使用柯里化解决上一个案例中硬编码的问题

  ```javascript
  // // 普通的纯函数
  // function checkAge(min, age) {
  //   return age >= min;
  // }
  // console.log(checkAge(18, 20));
  // console.log(checkAge(18, 24));
  // console.log(checkAge(22, 24));
  
  // 函数的柯里化
  // function checkAge(min) {
  //   return function (age) {
  //     return age >= min;
  //   };
  // }
  
  // 箭头函数改写
  
  const checkAge = (min) => (age) => age >= min;
  
  let checkAge18 = checkAge(18);
  let checkAge20 = checkAge(20);
  
  console.log(checkAge18(22));
  console.log(checkAge18(24));
  console.log(checkAge18(13));
  
  ```

  

- 柯里化（Curring）:

  - 当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）
  - 然后返回一个新的函数接收剩余的参数，返回结果

- 

#### Lodash中的柯里化

- _.curry(func)

  - 功能：创建一个函数，该函数接收 `func` 的参数，要么调用`func`返回的结果，如果 `func` 所需参数已经提供，则直接返回 `func` 所执行的结果。或返回一个函数，接受余下的`func` 参数的函数，可以使用 `func.length` 强制需要累积的参数个数。
  - 参数：需要柯里化的函数
  - 返回值：柯里化后的函数

- 代码

  ```javascript
  // // lodash 中curry的基本使用
  const _ = require("lodash");
  function getSum(a, b, c) {
    return a + b + c;
  }
  const curried = _.curry(getSum);
  console.log(curried(1, 2, 3));
  console.log(curried(1)(2, 3));
  console.log(curried(1, 2)(3));
  
  ```

  

- 

#### 柯里化案例

- 代码

  ```javascript
  // 柯里化案例
  // "".match(/\s+/g);
  // "".match(/\d+/g);
  
  const _ = require("lodash");
  
  // 普通方法匹配
  // function matchStr(reg, str) {
  //   return str.match(reg);
  // }
  
  // 使用柯里化的方式
  const match = _.curry(function (reg, str) {
    return str.match(reg);
  });
  
  const haveSpace = match(/\s+/g);
  const haveNumber = match(/\d+/g);
  
  // 会把空白字符给提取出来，返回一个数组的形式 [ ' ' ]
  // console.log(haveSpace("hello world"));
  // // 没有空格， 没有匹配到，返回null
  // console.log(haveSpace("helloworld"));
  // console.log(haveNumber("abc"));
  
  // 写一个filter的柯里化函数
  const filter = _.curry(function (fun, array) {
    return array.filter(fun);
  });
  
  console.log(filter(haveSpace, ["ab c", "ab_c"]));
  
  // 另一种写法
  
  const filterSpace = filter(haveSpace);
  console.log(filterSpace(["ab c", "ab_c"]));
  
  ```

  

- 

#### 柯里化原理模拟

- 代码

  ```javascript
  // 模拟实现lodash中的curry方法
  const _ = require("lodash");
  function getSum(a, b, c) {
    return a + b + c;
  }
  const curried = _.curry(getSum);
  console.log(curried(1, 2, 3));
  console.log(curried(1)(2, 3));
  console.log(curried(1, 2)(3));
  
  function curry(func) {
    return function curried(...args) {
      if (args.length < func.length) {
        return function () {
          return curried(...args.concat(Array.from(arguments)));
        };
      }
      return func(...args);
    };
  }
  
  const curriedmoni = curry(getSum);
  console.log(curriedmoni(1, 2, 3));
  console.log(curriedmoni(1)(2, 3));
  console.log(curriedmoni(1, 2)(3));
  
  ```

  

- 

#### 柯里化总结

- 总结
  - ![image-20220523212812664](%E7%AC%94%E8%AE%B0.assets/image-20220523212812664.png)
- 

#### 函数组合概念

- 函数组合

  - ![image-20220523212934993](%E7%AC%94%E8%AE%B0.assets/image-20220523212934993.png)

- 管道

  - ![image-20220523213106562](%E7%AC%94%E8%AE%B0.assets/image-20220523213106562.png)
  - 

- 函数组合

  - 函数组合（compose）:如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
    - 函数就像是数据的管道，函数组合就是把这些管道连接起来，让数据穿过多个管道形成最终结果。
    - 函数组合默认是从右到左执行
  - 

- 代码

  ```javascript
  // 函数组合
  function compose(f, g) {
    return function (value) {
      return f(g(value));
    };
  }
  
  function reverse(array) {
    return array.reverse();
  }
  function first(array) {
    return array[0];
  }
  
  const last = compose(first, reverse);
  console.log(last([1, 2, 3, 4]));
  
  ```

  



#### Lodash 中的组合函数

- lodash中的组合函数

  - lodash中的组合函数flow()或flowRight(),他们都可以组合多个函数
  - flow() 是从左到右运行
  - flowRight()是从右到左运行，使用的更多一些

- 代码

  ```javascript
  // lodash中函数组合方法 _.flowRight()
  const _ = require("lodash");
  const reverse = (arr) => arr.reverse();
  const first = (arr) => arr[0];
  const upperCase = (s) => s.toUpperCase();
  const compose = _.flowRight(upperCase, first, reverse);
  
  console.log(compose(["one", "two", "three", "four"]));
  ```

  

- 

#### 函数组合的实现原理

- 代码

  ```javascript
  // 模拟lodash中的flowRight
  const _ = require("lodash");
  const reverse = (arr) => arr.reverse();
  const first = (arr) => arr[0];
  const upperCase = (s) => s.toUpperCase();
  // const f = _.flowRight(upperCase, first, reverse);
  // console.log(f(["one", "two", "three"]));
  
  function compose(...args) {
    return function (value) {
      return args.reverse().reduce((acc, fn) => {
        return fn(acc);
      }, value);
    };
  }
  let f = compose(upperCase, first, reverse);
  console.log(f(["one", "two", "three"]));
  
  ```

  

- 

#### 函数组合-结合律

- 代码

  ```javascript
  // lodash中函数组合方法 _.flowRight()
  const _ = require("lodash");
  
  // const f = _.flowRight(_.upperCase, _.first, _.reverse);
  // const f = _.flowRight(_.flowRight(_.upperCase, _.first), _.reverse);
  const f = _.flowRight(_.upperCase, _.flowRight(_.first, _.reverse));
  
  console.log(f(["one", "two", "three", "four"]));
  
  ```

  

- 

#### 函数组合-调试

- 调试

  - 如何调试组合函数

- 代码

  ```javascript
  // 函数组合 调试
  // NEVER SAY DIE --> never-say-die
  
  const { flowRight } = require("lodash");
  const _ = require("lodash");
  
  // const log = (v) => {
  //   console.log(v);
  //   return v;
  // };
  
  const trace = _.curry((tag, v) => {
    console.log(tag, v);
    return v;
  });
  
  // _.split()
  const split = _.curry((sep, str) => _.split(str, sep));
  
  // _.toLower()
  
  const join = _.curry((sep, array) => _.join(array, sep));
  const map = _.curry((fn, array) => _.map(array, fn));
  // 我们需要返回的是数组，
  const f = flowRight(
    join("-"),
    trace("map之后"),
    map(_.toLower),
    trace("split之后"),
    split(" ")
  );
  // const f = flowRight(join("-"), log, _.toLower, split(" "));
  
  console.log(f("NEVER SAY DIE"));
  
  ```

  

- 

#### Lodash-fp模块

- lodash/fp

  - lodash的fp模块提供了实用的对函数式编程友好的方法

  - 提供了不可变auto-curried iteratee-first data-last 的方法 （函数优先，数据滞后）

  - lodash 模块 与 lodash/fp模块 比对

    - ![image-20220528192202388](%E7%AC%94%E8%AE%B0.assets/image-20220528192202388.png)

  - 代码,可以与之前lodash写的做比对

    ```javascript
    // lodash 中的fp模块
    // NEVER SAY DIE --> never-say-die
    
    const fp = require('lodash/fp')
    
    const f = fp.flowRight(fp.join('-'), fp.map(fp.toLower), fp.split(' '))
    
    console.log(f('NEVER SAY DIE'))
    
    ```

    

  - 

- 

  

#### Lodash中的FP模块，map方法的区别

- 代码, 二进制的数字只有0 1

  ```javascript
  // lodash 和 lodash中的fp模块，map方法的区别
  // 小技巧，vscode，输入方法（）的时候，能看到方法需要传入的参数，iteratee 是函数的意思
  
  const _ = require('lodash')
  
  // 打印的值为 [ 23, NaN, 2 ]，为什么会这样，因为parseInt 的第二个参数是转化进制，
  console.log(_.map(['23', '8', '10'], parseInt))
  // 模拟上面函数parseInt的执行，0是10进制，1没有这个定义，2是二进制，所以打印出NaN
  // parseInt('23',0,array)
  // parseInt('8',1,array)
  // parseInt('10',2,array)
  
  const fp = require('lodash/fp')
  // [ 23, 8, 10 ],打印出正常的值，这个fp中的parseInt 只需要处理数组中的每一个元素，lodash中的parseInt的方法需要传入3个参数
  console.log(fp.map(parseInt, ['23', '8', '10']))
  
  ```

  

- 经典面试题

  ```javascript
  ["1", "2", "3"].map(parseInt)
  
  首先， map接受两个参数， 一个回调函数 callback， 一个回调函数的this值
  其中回调函数接受三个参数 currentValue， index， arrary;
  而题目中， map只传入了回调函数--parseInt.
  其次， parseInt 只接受两个两个参数 string， radix(基数).
  在没有指定基数，或者基数为 0 的情况下，JavaScript 作如下处理：
  如果字符串 string 以"0x"或者"0X"开头， 则基数是16 (16进制).
  如果字符串 string 以"0"开头， 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决- 定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。
  如果字符串 string 以其它任何值开头，则基数是10 (十进制)。
  所以本题即问
  parseInt('1', 0);
  parseInt('2',1);
  parseInt('3', 2);
  首先后两者参数不合法.
  所以答案是 [1, NaN, NaN]
  
  ```

  

- 

#### Point Free

- Point Free:我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

  - 不需要指明处理的数据
  - 只需要合成运算过程
  - 需要定义一些辅助的基本运算函数
  - 案例演示
    - ![image-20220529013454194](%E7%AC%94%E8%AE%B0.assets/image-20220529013454194.png)
  - 

- 代码

  ```javascript
  // point free
  // Hello   World --> hello_world
  
  // 非 point free 模式
  const _ = require('lodash')
  const fp = require('lodash/fp')
  
  const compoise = word => {
    return word.toLowerCase().replace(/\s+/g, '_')
  }
  console.log(compoise('Hello   World'))
  
  // point free 模式
  
  const f = fp.flowRight(fp.replace(/\s+/g, '_'), fp.toLower)
  console.log(f('Hello   World'))
  
  ```

  

- 

#### Pointfree 案例

- 代码

  ```javascript
  // 把一个字符串中的首字母提取并转换成大写，使用 . 作为分隔符
  // world wild web --> W. W. W
  
  const fp = require('lodash/fp')
  
  // 这边使用了两次fp.map，做了两次循环，我们能不能只做一次循环
  // const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.first), fp.map(fp.toUpper), fp.split(' '))
  
  const firstLetterToUpper = fp.flowRight(fp.join('. '), fp.map(fp.flowRight(fp.first, fp.toUpper)), fp.split(' '))
  console.log(firstLetterToUpper('world wild web'))
  
  ```

  

- 

#### Functor(函子)

- 为什么要学函子

  - 到目前为止已经学习了函数式编程的一些基础，但是我们还没有演示在函数式编程中如何把副作用控制在可控的范围内、异常处理、异步操作等。

- 什么是Functor

  - 容器：包含值和值的变形关系（这个变形关系就是函数）
  - 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理（变形关系）

- 代码

  ```javascript
  // Functor 函子
  
  // class Container {
  //   constructor(value) {
  //     this._value = value
  //   }
  
  //   map(fn) {
  //     return new Container(fn(this._value))
  //   }
  // }
  
  // 调用的时候不像函数式编程，像面向对象，所以创建static 静态方法内部使用构造函数创建对象
  // let r = new Container(5).map(x => x + 1).map(x => x * x)
  
  // console.log(r)
  
  class Container {
    static of(value) {
      return new Container(value)
    }
    constructor(value) {
      this._value = value
    }
    map(fn) {
      return Container.of(fn(this._value))
    }
  }
  
  let r = Container.of(5)
    .map(x => x + 2)
    .map(x => x * x)
  console.log(r)
  
  ```

  

- 

#### Functor总结

- 总结

  - 函数式编程的运算不直接操作值，而是由函子完成
  - 函子就是一个实现了map契约的对象
  - 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
  - 想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
  - 最终map方法返回一个包含新值的盒子（函子）

- 因为纯函数相同的输入必须要有相同的输出，输入null，报错，就变得不纯了

  - 代码

    ```javascript
    class Container {
      static of(value) {
        return new Container(value)
      }
      constructor(value) {
        this._value = value
      }
      map(fn) {
        return Container.of(fn(this._value))
      }
    }
    
    // let r = Container.of(5)
    //   .map(x => x + 2)
    //   .map(x => x * x)
    // console.log(r)
    
    // 演示 null undefined 的问题
    
    // Cannot read property 'toUpperCase' of null
    Container.of(null).map(x => x.toUpperCase())
    ```

    



#### MayBe函子

- 可能会是空值的情况，我们使用MayBe函子 

- MayBe函子

  - 我们在编程的过程中可能会遇到很多错误，需要对这些错误做相对应的处理
  - MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在合理的范围内）

- 代码

  ```javascript
  // MayBe 函子
  
  class MayBe {
    static of(value) {
      return new MayBe(value)
    }
    constructor(value) {
      this._value = value
    }
  
    map(fn) {
      // 返回前对this._value进行空值判断
      return this.isNothing ? MayBe.of(null) : fn(this._value)
    }
  
    isNothing() {
      return this._value === null || this._value === undefined
    }
  }
  
  // MayBe { _value: null }
  // let r = MayBe.of('hello world').map(x => x.toUpperCase())
  
  // 会得到null的结果，但是我们不知道什么时候出现的（虽然我们可以出现空值，但是多次调用map的时候，哪一次出现空值，我们是不明确的），这个时候我们需要Either函子
  // MayBe { _value: null }
  let r = MayBe.of('hello world')
    .map(x => x.toUpperCase())
    .map(x => null)
    .map(x => x.split(' '))
  console.log(r)
  
  ```

  



#### Either函子

- Either函子

  - Either两者中的任何一个，类似于if...else...的处理
  - 异常会让函数变得不纯，Either函子可以用来做异常处理

- 代码

  ```javascript
  // Either 函子
  
  class Left {
    static of(value) {
      return new Left(value)
    }
    constructor(value) {
      this._value = value
    }
    map() {
      return this
    }
  }
  
  class Right {
    static of(value) {
      return new Right(value)
    }
    constructor(value) {
      this._value = value
    }
    map(fn) {
      return Right.of(fn(this._value))
    }
  }
  
  function parseJSON(str) {
    try {
      return Right.of(JSON.parse(str))
    } catch (e) {
      return Left.of({ error: e.message })
    }
  }
  
  // 演示错误案例
  // Left { _value: { error: 'Unexpected token n in JSON at position 1' } }
  // let r = parseJSON('{name:ds}')
  // console.log(r)
  
  // Right { _value: 'DS' }
  let r = parseJSON('{"name":"ds"}').map(x => x.name.toUpperCase())
  console.log(r)
  
  ```

  

- 

#### IO函子

- IO函子
  - IO函子中的_value 是一个函数，这里是把函数作为值来处理
  - IO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作为纯函数
  - 把不纯的操作交给调用者来处理
  - 截图
    - ![image-20220529223515174](%E7%AC%94%E8%AE%B0.assets/image-20220529223515174.png)
  - 
  
- 代码

  ```javascript
  // IO 函子
  const fp = require('lodash/fp')
  
  class IO {
    static of(value) {
      return new IO(function () {
        return value
      })
    }
  
    constructor(fn) {
      this._value = fn
    }
  
    map(fn) {
      return new IO(fp.flowRight(fn, this._value))
    }
  }
  
  // 因为当前使用node 运行，有进程这个值
  let r = IO.of(process).map(p => p.execPath)
  console.log(r)
  console.log(r._value())
  
  ```

  

- 

#### Folktale

- Task异步执行

  - 异步任务的实现过于复杂，我们使用folktale中的Task来演示
  - [folktale](https://folktale.origamitower.com/)一个标准的函数式编程库
    - 和lodash、ramda不同的是，他没有提供很多功能函数
    - 只提供了一些函数式处理的操作，例如：compose、curry等，一些函子 Task、Either、MayBe等
    - ![image-20220608224938315](%E7%AC%94%E8%AE%B0.assets/image-20220608224938315.png)

- 步骤

  - npm install folktale

  - 代码

    ```javascript
    // folktale 中的compose 、 curry
    
    const { compose, curry } = require('folktale/core/lambda')
    const { first, toUpper } = require('lodash/fp')
    
    // curry 使用
    // let f = curry(2, function (x, y) {
    //   return x + y
    // })
    
    // 3 3
    // console.log(f(1, 2))
    // console.log(f(1)(2))
    
    // compose 使用
    
    // 跟lodash/fp中的flowRight一样，也是从右往左执行
    let r = compose(toUpper, first)
    // ONE
    console.log(r(['one', 'two']))
    
    ```

    

  - 

- 

#### Task函子执行异步任务

可以通过folktale官网来查看

```javascript
// Task 处理异步任务
const fs = require('fs')
const { task } = require('folktale/concurrency/task')
const { split, find } = require('lodash/fp')

function readFile(filename) {
  // task 返回的Task类型的对象
  return task(resolver => {
    fs.readFile(filename, 'utf-8', (err, data) => {
      if (err) resolver.reject(err)
      resolver.resolve(data)
    })
  })
}

readFile('package.json')
  .map(split('\n'))
  .map(find(x => x.includes('dependencies')))
  .run()
  .listen({
    onRejected: err => {
      console.log(err)
    },
    onResolved: value => {
      console.log(value)
    }
  })

```



#### d

#### e

#### 3 

### 函数式编程的特性（纯函数、柯里化、函数组合等）

### 函数式编程的应用场景

### 函数式编程库 Lodash

## 

# 前端工程化实战

## 的

## 模块化开发与规范化标准

### 模块化开发

模块化只是思想，

#### 模块化的演变过程

早期在没有工具和规范的情况下对模块化的落地方式: Stage1-3。

1. stage1-文件划分方式,最早期通过约束一个文件就是一个模块，通过script标签引入。
   ![image-20230708172303392](%E7%AC%94%E8%AE%B0.assets/image-20230708172303392.png)

   - 早期模块化完全依靠约定
   - 缺点
     - 污染全局作用域
     - 命名冲突问题
     - 无法管理模块依赖关系

2. Stage-2 命名空间方式 
   ![image-20230708174324835](%E7%AC%94%E8%AE%B0.assets/image-20230708174324835.png)

   ![image-20230708174616013](%E7%AC%94%E8%AE%B0.assets/image-20230708174616013.png)

3. Stage-3  IIFE

   立即执行函数，实现了私有成员的概念。

   - ![image-20230708174704168](%E7%AC%94%E8%AE%B0.assets/image-20230708174704168.png)

4. Stage-4 

   - 

5. 

- 





#### 模块化规范

模块化的标准+模块加载器，

1. CommonJS规范，它是nodeJs提出的标准。

   CommonJS是以同步模式加载模块，因为node的执行机制是启动时加载模块，执行过程中是不需要去加载的。它只会使用到模块。所以这种方式在node中不会有问题，但是在浏览器端使用CommonJS规范，必然导致效率低下。因为我们每次页面加载，都会导致大量的同步模式请求出现，所以在早期的前端模块化当中，并没有使用CommonJS，为浏览器端、结合浏览器的特定设计了AMD规范（Asynchronus Module Definition）：异步的模块定义规范，同期还出现了Require.js库，它实现了AMD规范，另外它本身又是强大的模块加载器

   ```
   commonJS 特点
   - 一个文件就是一个模块
   - 每个模块都有单独的作用域
   - 通过module.exports导出成员
   - 通过require函数载入模块
   ```

   

2.  AMD
   ![image-20230708180335429](%E7%AC%94%E8%AE%B0.assets/image-20230708180335429.png)

   规定我们定义模块必须要以define这个函数去定义。这个函数的定义是为 这个函数提供私有的空间。这个函数向外面导出成员是通过return的方式。

   通过require函数自动加载这个模块。
   ![image-20230708180547232](%E7%AC%94%E8%AE%B0.assets/image-20230708180547232.png)

   目前绝大多数第三方库都支持AMD规范，

   - AMD使用起来相对复杂
   - 模块JS文件请求频繁

3.  Sea.js + CMD

   

   ![image-20230708180834919](%E7%AC%94%E8%AE%B0.assets/image-20230708180834919.png)

4.  



##### 模块化标准规范

上面虽然都实现了模块化，但是或多或少都存在一些让我们开发者难以接受的问题。

- 模块化的最佳实践
  ![image-20230708181203148](%E7%AC%94%E8%AE%B0.assets/image-20230708181203148.png)

  在Node环境中使用CommonJS规范组织模块，在浏览器坏境中采用ES Modules 规范，我们只需要掌握这两种规范就行。

1. CommonJS in Node 
   正常使用 require module.export就行
2.  ECMAScript 2015(ES6)
    刚开始推出的时候，所有主流的浏览器不支持这个特性，后来webpack等打包工具流行的时候，这一特性才开始普及。现在ESM 是最主流的规范了。
3.  

##### ES Modules 特性

ES Modules基本特性

- 自动采用严格模式，忽略‘use stript’ 
- 每个ESM模块都是单独的私有作用域
- ESM是通过CORS去请求外部JS模块的 （使用CORS跨域的方式进行请求，请求的地址必须要支持CORS）就是服务端需要支持CORS，CORS不支持文件的形式去访问，需要http-server的形式访问，正常生产中是不会遇到。
- ESM的script标签会延迟执行脚本

1.  

   - 通过serve . 命令行工具就可以启动http serve ,通过这个地址就可以打开这个页面。我没有试成功，需要验证。html文件直接拿浏览器打开。
     ![image-20230708182430461](%E7%AC%94%E8%AE%B0.assets/image-20230708182430461.png)

     ![image-20230708182521533](%E7%AC%94%E8%AE%B0.assets/image-20230708182521533.png)

   - 

     - ![image-20230708183730421](%E7%AC%94%E8%AE%B0.assets/image-20230708183730421.png)



##### ES Modules 导出和导入

1. export 使用方式，可以看ES6语法
   ![image-20230708184943126](%E7%AC%94%E8%AE%B0.assets/image-20230708184943126.png)

   - 重命名
     ![image-20230708185020963](%E7%AC%94%E8%AE%B0.assets/image-20230708185020963.png)

   - default重命名
     导出的时候命名为default

     ![image-20230708185130138](%E7%AC%94%E8%AE%B0.assets/image-20230708185130138.png)
     导入的时候重命名

     import {default as fooName} from './modules'

   - export default 默认导出，可以是对象，也可以是一个值

2. 导入导出注意

   - 这边的导出是是个引用，不是复制
     - ![image-20230708185946867](%E7%AC%94%E8%AE%B0.assets/image-20230708185946867.png)

   - 导出 export{name,age} 这个后面{} 不是一个对象，固定写法。
     export default {name,age} 这个导出就是一个对象了。
     - ![image-20230708185418191](%E7%AC%94%E8%AE%B0.assets/image-20230708185418191.png)
   -  export default 导出之后，import再导入这个的时候，这边并不是解构。import 就是个固定的用法。
     ![image-20230708185642395](%E7%AC%94%E8%AE%B0.assets/image-20230708185642395.png)
   - 

3. 导出的成员是个只读的

   - ![image-20230708190051948](%E7%AC%94%E8%AE%B0.assets/image-20230708190051948.png)

4.  

   

- 引入browser-sync 模块，对文件下所有js进行监控，可以产生热更新的效果。
  
  - ```javascript
    Browsersync能让浏览器实时、快速响应您的文件更改（html、js、css、sass、less等）并自动刷新页面。
    1. 安装 Node.js
    BrowserSync是基于Node.js的, 是一个Node模块， 如果您想要快速使用它，也许您需要先安装一下Node.js
    http://www.runoob.com/nodejs/nodejs-install-setup.html
    
    2.安装 BrowserSync
    1）全局安装：
    npm install -g browser-sync 
    2）如果想要在项目中添加项目依赖，不适用全局安装，那么需要：
    
    npm install browser-sync --save-dev
    3）也可以结合gulpjs或gruntjs构建工具来使用，在您需要构建的项目里运行下面的命令:
    
    npm install --save-dev browser-sync
    备注：建议使用NPM淘宝镜像
    
    3.使用
    1.进入文件夹目录
    假设需要监听的是E:\Jqclub\MUI文件夹
    
    1.打开win+r,输入cmd    回车
    2.e:                  回车
    3.cd E:\Jqclub\MUI    回车
    2.输入：
    
    browser-sync start --server --files "*.html , css/*.css , js/*.js" 
    回车
    
    只针对JS文件
    browser-sync start --server --files "*.html , css/*.css , **/*.js" 
    ```
  
  - 
  
  - ![image-20230708184744643](%E7%AC%94%E8%AE%B0.assets/image-20230708184744643.png)



###### ESM 导入 import用法

![image-20230709070043369](%E7%AC%94%E8%AE%B0.assets/image-20230709070043369.png)



- from 后面的路径要写的具体
  - import {name } from './utils/index.js'
  - commonjs 中不带路径/index.js 是能加载出来的
-  去掉./ 会被认为加载模块，与commonjs一致，也可以添加绝对路径
  - import {name } from 'module.js'
  - import {name } from './module.js'
  - import {name } from '/04-import/module.js'
  - 也可以使用完整的url 路径
-  import 只能出现在最顶层
  - 这样是不行的，需要动态导入模块
    - ![image-20230709070157586](%E7%AC%94%E8%AE%B0.assets/image-20230709070157586.png)
  - 是一个异步的，
    - ![image-20230709070300006](%E7%AC%94%E8%AE%B0.assets/image-20230709070300006.png)
-  abc 就是export 成员中的default,可以使用这种方式简写，不需要 as 别名了
  - ![image-20230709070421202](%E7%AC%94%E8%AE%B0.assets/image-20230709070421202.png)

###### ESM 导出导入成员

用index.js 把需要导出的成员集中起来导出

- 

  -  ```javascript
    improt xxx
    improt xxx
    export {abc, name}
    ```

  - 

- 

  - 
    ```javascript
    export {button} from 'xxx'
    export {avator} from 'xxx'
    ```

    

- 如果某个模块有export default,需要起别名
  ![image-20230709071254384](%E7%AC%94%E8%AE%B0.assets/image-20230709071254384.png)

- 

##### ESM 浏览器环境Polyfill

ie不兼容esm script标签，也可以使用编译插件将es6代码编译成es5的代码，这样就能正常了。 只是适合在本地玩玩，不能在生产中使用，浪费加载时间。

- 通过unpkg.com拿到 babel 、module 的polyfill cdn文件，目的是将module 在线babel 转化。

  - ![image-20230709071934134](%E7%AC%94%E8%AE%B0.assets/image-20230709071934134.png)

  - ![image-20230709071734626](%E7%AC%94%E8%AE%B0.assets/image-20230709071734626.png)
  - nomodule 这个会在不支持module的浏览器中工作
    - ![image-20230709072031286](%E7%AC%94%E8%AE%B0.assets/image-20230709072031286.png)
    - ![image-20230709072238762](%E7%AC%94%E8%AE%B0.assets/image-20230709072238762.png)
    - 

##### ESM in Node

- 
  - ![image-20230709072613061](%E7%AC%94%E8%AE%B0.assets/image-20230709072613061.png) 
  - node中内置模块可以import导入，第三方的不支持，因为内置模块兼容了 ESM 的提取成员方式
    - ![image-20230709072834090](%E7%AC%94%E8%AE%B0.assets/image-20230709072834090.png)

###### node ESM 中载入commonjs 模块

- ![image-20230709073241065](%E7%AC%94%E8%AE%B0.assets/image-20230709073241065.png)
- ![image-20230709073250225](%E7%AC%94%E8%AE%B0.assets/image-20230709073250225.png)
-  node 中源码，实际上是伪全局对象
  - ![image-20230709073734069](%E7%AC%94%E8%AE%B0.assets/image-20230709073734069.png)

- 新版本更好的支持了ESM 
  - ![image-20230709074005223](%E7%AC%94%E8%AE%B0.assets/image-20230709074005223.png)
  - 但是引入commonjs会报错，需要对 文件后缀修改成 cjs
    - ![image-20230709074107375](%E7%AC%94%E8%AE%B0.assets/image-20230709074107375.png)



- 

###### node ESM 与 CommonJS 的差异

- 
  - ![image-20230709073622117](%E7%AC%94%E8%AE%B0.assets/image-20230709073622117.png)

###### ESM in node babel 兼容方案

1. 安装babel 预设插件
   - ![image-20230709074351100](%E7%AC%94%E8%AE%B0.assets/image-20230709074351100.png)
2. 真正起作用的是一个插件，并不是preset， preset是一个 集合，需要单独使用，命令行可以使用 --presets=@babel/preset-env,不想这么使用的话，使用babelrc文件中配置，这边是个json文件。
   - ![image-20230709074532903](%E7%AC%94%E8%AE%B0.assets/image-20230709074532903.png)
3. 具体使用一个插件来实现，先移除preset-env
   - yarn remove @babel/preset-env
   - 再添加具体插件
     yarn add @babel/plugin-transform-modules-commonjs --dev
     - ![image-20230709075119719](%E7%AC%94%E8%AE%B0.assets/image-20230709075119719.png)
   - 再使用babel-node， 也有其他的编译器
     - ![image-20230709075200252](%E7%AC%94%E8%AE%B0.assets/image-20230709075200252.png)
   - 



### webpack打包

#### 模块打包工具

ES Modules 存在环境兼容问题，虽然主流浏览器已经支持，但是还没有统一所有用户使用情况，模块过多，网络请求频繁。

所有的前端资源都需要模块化。html 、css 文件等等

- 
  - ![image-20230709080409998](%E7%AC%94%E8%AE%B0.assets/image-20230709080409998.png)

-  
  - ![image-20230709075654982](%E7%AC%94%E8%AE%B0.assets/image-20230709075654982.png)
  - 对于模块化文件划分，我们只需要在开发阶段需要它， 因为它能更好的帮我们组织我们的代码。但是对于运行环境是没有必要的，所有在开发 阶段还是通过模块化的方式去编写，生产阶段还是把他们打包到同一个文件当中。
    - ![image-20230709075702838](%E7%AC%94%E8%AE%B0.assets/image-20230709075702838.png)
    - 需要支持不同种类的前端资源。样式、图片、字体等资源文件都当做模块去使用， 对于我们前端应用，就有了一个统一的模块化方案。这个方案可以通过代码去控制，那就可以用我们的业务代码去维护，这样更合理一些。 
    - ![image-20230709080038344](%E7%AC%94%E8%AE%B0.assets/image-20230709080038344.png)

####  模块打包工具--概要

其他的打包工作也是类似的实现webpack这些需求，所有的打包工具都是以模块化为目标，这里说的模块化指的是：**打包工具解决的是前端整体的模块化 ，并不单指JavaScript模块化**。

1. webpack

   模块打包器（module bundler）

   - 模块加载器（Loader）
     - 对于代码中有环境兼容的代码，可以使用Loader对其进行编译转换。
   - 代码拆分（code Splitting）
     - 所有的代码按照我们的需要去打包，不用担心将所有的代码全部打包到一起，产生的文件比较大这样问题。把应用加载过程中，初次运行的时候所必须的模块打包到一起。其他的模块再单独存放。等到应用工作过程中，所需要的某个模块，再异步的加载这个模块，从而实现增量加载，渐进式加载。这样就不用担心文件太碎或文件太大两个极端的问题。
     - 
   - 资源模块（Asset Module）
     - 对于前端文件类型的问题，webpack支持我们在JavaScript当中，以模块化的方式载入任意类型的文件。如直接import一个css类型的文件，那这些css文件会通过style便签的形式去工作。其他的这种类型的文件也可以有类似这种方式去实现。
   - 

2. 

3. 

####   Webpack快速上手

有代码模板参考。

它提供了一整套前端项目的模块化方案，而不仅仅局限于对JavaScript的模块化，通过webpack的前端模块化方案，可以轻松的对前端项目开发中，对所有的静态资源进行模块化。

- 
  ```javascript
   // npm 包serve的使用
  1.首先需要安装node 
  2.使用npm命令行来安装serve 
          npm install -g serve
  3. 创建一个文件夹. 
          mkdir serve-demo
  4. 打开文件夹  
          cd serve-demo
  5. 然后将其他项目打好的包放进这个文件夹，比如放入一个build文件夹，然后在package.json中添加一行npm脚本：
          "serve": "serve ./build"
  6. 最后    
          serve dist
  会在命令行下出现这句：INFO: Accepting connections at http://localhost:5000
  在浏览器输入http://localhost:5000即可查看到你打包好的项目
  
  ```

- 进入文件目录  serve .  ，开启服务，查看页面可以正常工作
  ![image-20230710212620284](%E7%AC%94%E8%AE%B0.assets/image-20230710212620284.png)

- 引入webpack去处理我们的JS模块
  webpack是一个npm 的工具模块

  - yarn init --yes 初始化 package.json
  - 安装webpack所需要的核心模块和对应的cli模块,--dev 指定为我们的开发依赖
    - yarn add webpack webpack-cli  --dev
    -  webpack-cli 出现在bin目录当中
      - ![image-20230710213249121](%E7%AC%94%E8%AE%B0.assets/image-20230710213249121.png)
      - 通过yarn 命令快速找到cli,以及去运行它，yarn webpack是执行
        ![image-20230710213511031](%E7%AC%94%E8%AE%B0.assets/image-20230710213511031.png)
      - 
  - 由于打包后，import 和 export 被转化，就不需要script 中type='module' 这样模块化方式引入
    - ![image-20230710213700308](%E7%AC%94%E8%AE%B0.assets/image-20230710213700308.png)
  - 如果嫌弃yarn webpack 不方便，可以放到package.json中建立一个build的任务
    ![image-20230710213825532](%E7%AC%94%E8%AE%B0.assets/image-20230710213825532.png)
  - 

-  

#### webpack配置文件  

webpack 4 以后支持0配置的方式直接启动打包。

- 
  - 按照约定将src 下的index.js 作为我们打包的入口文件，最终打包的结果会存放到dist/main.js
    - ![image-20230710215953170](%E7%AC%94%E8%AE%B0.assets/image-20230710215953170.png)
- 如果是以scr/main.js作为入口文件，需要为webpack添加专门的配置文件。
  - 做法
    - 添加 webpack.config.js文件，这个文件是运行在node中的js文件，那也就是说我们需要使用commonjs的方式去编写代码。这个文件导出一个对象
    - path需要绝对路径
      - ![image-20230710220702908](%E7%AC%94%E8%AE%B0.assets/image-20230710220702908.png)
  - 
    - 
- 

####  Webpack工作模式

webpack4新增了工作模式 的用法，大大减少了配置的复杂难度。可以理解为针对不同环境的几组预设的配置。可以去官网查看工作模式的用法。

![image-20230710222822766](%E7%AC%94%E8%AE%B0.assets/image-20230710222822766.png)

- 三种模式，默认production模式，
  - webpack --mode development   
  - webpack --mode none   最原始的状态打包代码
- 也可以在webpack.confog.js 配置文件中配合工作模式
  - ![image-20230710222915052](%E7%AC%94%E8%AE%B0.assets/image-20230710222915052.png)



#### webpack 打包结果运行原理

1.  yarn webpack

   - ![image-20230710223737745](%E7%AC%94%E8%AE%B0.assets/image-20230710223737745.png)

2. 查看源码，ctrl+k ctrl+0 折叠更方便的查看

   ![image-20230710223823486](%E7%AC%94%E8%AE%B0.assets/image-20230710223823486.png)

3.  启动一个http server 服务，  server .，找到文件位置，打断点

   ![image-20230710223955224](%E7%AC%94%E8%AE%B0.assets/image-20230710223955224.png)

4. 调试

   ![image-20230710223554515](%E7%AC%94%E8%AE%B0.assets/image-20230710223554515.png)

5. 

#### webpack资源模块加载

webpack不仅仅是javascript的模块化打包工具，也是前端项目或者说前端工程的打包工具。 

loader是webpack的核心特性，借助于Loader可以加载任何类型的资源。

webpack打包css文件

1.  使用webpack直接打包CSS文件，入口文件直接就是CSS文件，发现报错，在解析的过程中，遇到了非法字符，那是因为webpack内部只会处理JavaScript文件，也就是说会把我们打包过程遇到的所有的文件都当成JavaScript去解析。此时我们处理的是css文件，里面是css代码，自然会报这样的错误，我们需要使用适当的加载器去处理这种类型的文件。

   - 执行 yarn webpack

   - ![image-20230711215108159](%E7%AC%94%E8%AE%B0.assets/image-20230711215108159.png)
   - ![image-20230711215435591](%E7%AC%94%E8%AE%B0.assets/image-20230711215435591.png)

2. 执行 yarn add css-loader --dev 

   - 在webpack.config.js中添加配置
     ![image-20230711215654229](%E7%AC%94%E8%AE%B0.assets/image-20230711215654229.png)
   - css-loader的作用就是将css文件转化为一个js模块
     - ![image-20230711215818013](%E7%AC%94%E8%AE%B0.assets/image-20230711215818013.png)
   - 转化之后的js模块并没有挂载，还需要使用style-loader去挂载到页面上，需要注意，如果配置了多个loader，配置的时候是从后往前去执行。先去执行最后一个laoder,打包到 bundle，最后执行的，会在bundle.js源码的最后展示。
     - yarn add style-loader --dev
     - ![image-20230711215958101](%E7%AC%94%E8%AE%B0.assets/image-20230711215958101.png)

3. 

####   Webpack导入资源模块

学习一个新事物，不是说学会它的所有用法就会提高，照着文档，谁都可以，新事物的思想才是突破点。搞明白新事物为何这样设计，那基本上就算是出道了。

打包入库某种程度上来说是运行入口。 前端的业务是由JavaScript去驱动的。还是把js文件作为打包的入口，通过import的方式去引入css文件。这样的话，css-loader会正常工作。

1. 修改配置，import css文件，打包
   - ![image-20230711220641843](%E7%AC%94%E8%AE%B0.assets/image-20230711220641843.png)
2. webpack不仅仅是让我们在js中引入css，而是建议我们在编写代码的过程中引入任何当前代码所需要的资源文件。需要资源的不是应用，而是你此时正在编写的代码。是你这边的代码想要工作，就必须加载对应的资源。这就是webpack哲学。
   - ![image-20230711220900625](%E7%AC%94%E8%AE%B0.assets/image-20230711220900625.png)

意义：

- 逻辑合理，JS确实需要这些资源文件

- 确保上线资源不缺失，都是必要的

  

  

####   webpack文件资源加载器

总结:webpack在打包时遇到了图片文件，然后根据配置文件中的配置，匹配到对应的文件加载器，此时文件加载器开始工作，先是将我们导入的文件拷贝到输出目录，然后再将文件拷贝到输出目录的路径作为当前这个模块的返回值返回，对于应用而言，所需的资源就被发布出来了。我们也可以通过模块的导出成员拿到这个访问路径。

webpack社区提供了很多文件资源加载器。基本上合理的需要都会有loader加载器。尝试一些非常有代表性的loader。

1. file-loader 文件加载器

   大部分的loader都是类似于css-loader,都是将资源文件转化js代码的实现方式。但是还有一些资源文件，比如图片、字体，这些文件是没法通过js的方式去表示的，那这些资源需要用file-laoder。

   - yarn add file-loader --dev

     - ![image-20230711222118745](%E7%AC%94%E8%AE%B0.assets/image-20230711222118745.png)
     - 发现打完包的图片不能正常的展示，f12查看发现，是因为直接加载了我们网页根目录下的图片。而我们网站根目录下就没有这张图片。应该是在dist目录当中， 
       - ![image-20230711222203012](%E7%AC%94%E8%AE%B0.assets/image-20230711222203012.png)
     - ![image-20230711222333825](%E7%AC%94%E8%AE%B0.assets/image-20230711222333825.png)
     - ![image-20230711222437113](%E7%AC%94%E8%AE%B0.assets/image-20230711222437113.png)

   - 这个问题实际上是由于在演示的时候，index.html并没有生成到dist目录，而是放在了项目的根目录下，所以就把项目的根目录当成网站的根目录。而webpack默认认为打包的目录都放在网站的根目录下面。解决方法也很简单，通过配置文件去告诉webpack你打包的文件在最终在我们网站中的位置。

     -  publicPath:''  ，默认值是一个空字符串，表示网站的根目录，我们这边是因为生成的文件放在dist目录下面，所以设置为dist/

       - ![image-20230711223041543](%E7%AC%94%E8%AE%B0.assets/image-20230711223041543.png)
       - ![image-20230711223116150](%E7%AC%94%E8%AE%B0.assets/image-20230711223116150.png)

        

       

#### webpack Data URLs 与 url-loader

base64，这中url的文本包含了文件的内容。

- ![image-20230712222448249](%E7%AC%94%E8%AE%B0.assets/image-20230712222448249.png)
- url-loader,编译成dataurl
  - ![image-20230712222617364](%E7%AC%94%E8%AE%B0.assets/image-20230712222617364.png)
  - ![image-20230712222625596](%E7%AC%94%E8%AE%B0.assets/image-20230712222625596.png)
- 最佳实践
  - 小文件使用Data URLs,小于10kb,减少发送请求的次数。大于10kb会交给file-loader处理
    - ![image-20230712222850023](%E7%AC%94%E8%AE%B0.assets/image-20230712222850023.png)
  - 大文件单独存放，提高加载速度。
  - 超出10kb文件单独提取存放
  - 小于10kb文件转化为Data URLs嵌入代码中。
- 

####  webpack常用加载器

1. 编译转换类
   ![image-20230713222549138](%E7%AC%94%E8%AE%B0.assets/image-20230713222549138.png)

2. 文件操作类

   ![image-20230713222636629](%E7%AC%94%E8%AE%B0.assets/image-20230713222636629.png)

   加载到的资源模块拷贝到输出目录，再返回访问文件的路径

3.  代码检查类

   ![image-20230713222710902](%E7%AC%94%E8%AE%B0.assets/image-20230713222710902.png)

   

####  webpack处理ES2015(ES6)

webpack默认会处理import,export,以为webapck会自动编译es6的代码，其实不然。因为模块打包需要，所有处理import和export。并不能处理其他es6代码。

webpack只是打包工具

加载器用来编译转换代码 

- babel-loader 处理其他es6代码
  - 添加依赖,babel/preset-env具体特性转换插件的集合
    yarn add babel-laoder @babel-core @babel/preset-env --dev
  - 
- babel 只是转换特性的一个平台，需要通过插件来转换代码中具体的特性。
  - ![image-20230713223756365](%E7%AC%94%E8%AE%B0.assets/image-20230713223756365.png)
- 

####   webpack模块加载方式

除非必要，不要混合使用下面的标准。

![image-20230713224636914](%E7%AC%94%E8%AE%B0.assets/image-20230713224636914.png)

1. 遵循ES Modules 标准的import声明

   - ![image-20230713223935112](%E7%AC%94%E8%AE%B0.assets/image-20230713223935112.png)

2. 遵循ComminJs 标准的require函数
   ![image-20230713223959104](%E7%AC%94%E8%AE%B0.assets/image-20230713223959104.png)

3. 遵循AMD标准的define函数和require函数

   - ![image-20230713224057774](%E7%AC%94%E8%AE%B0.assets/image-20230713224057774.png)

4. Loader加载的JS也会触发资源加载
   样式代码中的@import 指令和url函数（background：url(backgrond.png)）

   - ![image-20230713224331453](%E7%AC%94%E8%AE%B0.assets/image-20230713224331453.png)

     ![image-20230713224404049](%E7%AC%94%E8%AE%B0.assets/image-20230713224404049.png)

   HTML代码中图片标签的src属性,a标签的href属性
   ![image-20230713224431682](%E7%AC%94%E8%AE%B0.assets/image-20230713224431682.png)

   ![image-20230713224453647](%E7%AC%94%E8%AE%B0.assets/image-20230713224453647.png)

   配置html-loader ，a:href属性

   ![image-20230713224517121](%E7%AC%94%E8%AE%B0.assets/image-20230713224517121.png)

   ![image-20230713224602528](%E7%AC%94%E8%AE%B0.assets/image-20230713224602528.png)

5. 

####  webpack核心工作原理

![image-20230713224726476](%E7%AC%94%E8%AE%B0.assets/image-20230713224726476.png)

一般情况下，打包入口文件是个js文件，顺着入口的文件出现的代码， 根据文件出现的import 、require之类的语句，解析推断出这个文件所依赖的资源模块，分别去解析每个资源模块对应的依赖。最后形成了整个项目中所有用到文件之间的依赖关系的一个依赖树。 递归这个依赖树，找个每个节点所对应的资源文件。最后根据我们配置文件中的rules属性找到这个模块对应的加载器。

![image-20230713225231819](%E7%AC%94%E8%AE%B0.assets/image-20230713225231819.png)

####  Loader的工作原理（开发一个自己的loader）  

需求：markdown-loader，我希望有了这个loader之后，我们就可以在代码当中直接去导入markdown文件，那我们都应该知道，markdown文件一般是被转换为html过后，再去呈现到页面上的，所以说这里我希望我们导入的markdown文件。得到的结果呢，就是markdown转换过后的html字符串。

- 我们就不再单独去创建一个npm的模块了，直接在项目的根部下去新建一个markdown-loader的这样一个文件。完成以后呢，你可以再把这个模块发布到npm上，作为一个独立的模块去使用。那每个webpack的loader都需要去导出一个函数，这个函数就是我们这个loader对我们所加载到的资源的一个处理过程。
  它的输入呢，就是我们所加载到的资源文件的内容

- webpack的配置文件当中去添加一个加载器的规则配置，配到的扩展名就是.md

  - ![image-20230715171707206](%E7%AC%94%E8%AE%B0.assets/image-20230715171707206.png)
  - ![image-20230715171817589](%E7%AC%94%E8%AE%B0.assets/image-20230715171817589.png)

- 我们还需要一个额外的加载器来去处理我们当前的加载结果，其实webpack加载资源的过程有点类似于一个工作管道,你可以在这个过程当中一次去使用多个loader,但是要求我们最终这个管道工作过后的结果
  必须是一段JavaScript的代码,这边返回的内容是一个hello字符串。 

    ![image-20230715172856109](%E7%AC%94%E8%AE%B0.assets/image-20230715172856109.png)

  - 第一种方法

    - 我们将返回的这个内容修改为console-log
      一个引号引起来的hello，那这也就是一段标准的JavaScript的代码

    - ![image-20230715172927229](%E7%AC%94%E8%AE%B0.assets/image-20230715172927229.png)
    - ![image-20230715173149475](%E7%AC%94%E8%AE%B0.assets/image-20230715173149475.png)
    - 我们打开bounder.js当中，然后呢，我们找到最后一个模块，那这里呢，其实也非常简单
      ，webpack打包的时候,就是把我们刚刚loader加载过后的结果,也就是返回的那个字符串
      直接拼接到我们这个模块当中了

  - 第一种方法 

    - yarn add marked --dev
    - 我们先去安装一个markdown解析的模块叫做markd,回到代码当中去导入这个模块,在我们的加载器当中去使用这个模块,去解析来自参数当中的这个source,返回值就是一段html字符串
      也就是转换过后的结果。如果说我们直接去返回这个html的话，那就会面临刚刚同样的问题
      ，那正确的做法呢，就是把这一段html变成一段JavaScript的代码。
    - 其实我们希望是把这一段html，作为我们当前这个模块导出的字符串，也就是我们希望通过module export 等于这样一个字符串。但是如果说我们只是简单的拼接的话，那我们html当中存在的换行符，还有它内部的一些引号，我们拼接到一起，就有可能造成语法上的错误。
      所以说这里我使用一个小技巧，就是通过json stringify，先将这个字符串，转换为一个标准的json格式字符串，那此时呢，它内部的引号以及换行符都会被转移过来，然后，我们再参与拼接，那这样的话就不会有问题了。
    - ![image-20230715173626089](%E7%AC%94%E8%AE%B0.assets/image-20230715173626089.png)
    - ![image-20230715173810079](%E7%AC%94%E8%AE%B0.assets/image-20230715173810079.png)
    - 那例如我们这将module export = 修改为export default，以es module的方式去导出后面的这个字符串，然后呢，我们再运行打包，那结果同样也是可以的，wepack内部呢，会自动转换我们导出的这一段代码当中的 es module代码
      - ![image-20230715174036613](%E7%AC%94%E8%AE%B0.assets/image-20230715174036613.png)
    - 

  - 第二种方法 (html-loader)

    - 那就是在我们markdown loader当中,去返回一个html的字符串,然后呢,我们交给下一个loader去处理这个html的字符串,那这里呢,我们直接去返回markdown解析过后的html,然后呢,我们再去安装一个用于去处理html加载的loader,叫做html loader,安装完成过后呢,我们回到配置文件当中,那这里呢,我们把use属性修改为一个数组,这样的话,我们的loader工作过程当中就会依次去使用多个loader了。
    - 那不过这里需要注意就是，它的执行顺序是从数组的后面往前面，那也就是说，我们应该把先执行的loader放在数组的后面。我们再次回到命令行中端，再次打包。那这里呢，我们打包的结果仍然是可以的，我们markdown loader，他处理完的结果呢，是一个html的字符串，然后这个html字符串交给了下一个loader，也就是html-loader，那这个loader呢
      又把它转换成了一个导出这个字符串的一个JS代码。
      - ![image-20230715174457824](%E7%AC%94%E8%AE%B0.assets/image-20230715174457824.png)

  - 

- 我们就发现了loader，它内部的一个工作原理，其实非常简单，就是一个从输入到输出之间的一个转换，那除此之外呢，我们还了解了loader，它实际上是一种管道的概念我们可以将我们此次的这个loader的结果，交给下一个loader去处理，然后我们通过多个loader去完成一个功能。那例如我们之前所使用的css loader和style loader之间的一个配合，包括我们后面还会使用到的像sass或者less这种loader，他们也需要去配合我们刚刚所说的这两种loader，那这个呢就是我们loader工作管道这样一个特性



#### webpack插件机制

增强webpack自动化能力，plugin就是用来解决项目中资源加载以外其他自动化的工作。

1. 清除dist目录
2. 拷贝静态文件至输出目录
3. 压缩输出代码

#### webpack常用插件 （clean-webpack-plugin）

首先第一个就是用来自动清除输出目录的插件，通过之前的演示，你可能已经发现，webpack每次打包的结果都是覆盖到Dist的目录,而在打包之前,Dist终究可能已经存在一些之前的遗留文件。

我们再次打包，它只能覆盖掉那些同名的文件，对于其他那些已经移除的资源文件，就会一直积累在里面，非常不合理，更为合理的做法就是在每次打包之前，自动去清理Dist的目录
，这样的话，Dist终究只会存在那些我们需要的文件，CleanWebpackPlugin这个插件，就很好的实现了这样一个需求，它是一个第三方的插件。

我们先来通过一样去安装一下，安装过后，我们回到webpack的配置文件当中,然后去导入这个插件,这个插件模块它导出了一个叫做clean-webpack-plugin的一个成员。我们把它解构出来，然后回到配置对象当中，这里使用插件，我们需要去为配置对象，添加一个plugins的属性，这个属性就是专门用来去配置插件的地方，它是一个数组，我们去添加一个插件，就是在这个数组当中去添加一个元素，绝大多数插件模块导出的都是一个类型。我们这里的CleanWebpackPlugin它也不例外，所以我们使用它，通过这个类型去创建一个实例，然后将这个实例，放入到plugins的这个数组当中，完成以后，我们再次运行Webpack打包命令，此时之前的那些打包结果，就不会存在了，Dist中就都是我们本次打包的结果，非常的干净。

- ![image-20230715223954842](%E7%AC%94%E8%AE%B0.assets/image-20230715223954842.png)

####  webpack常用插件（html-webpack-plugin）

除了清理Dist目录以外，还有一个非常常见的需求，就是自动去生成使用打包结果的HTML。那在这之前，我们的HTML都是通过硬编码的方式，单独去存放在项目的根目录下的，那这种方式有两个问题。

第一就是我们在项目发布时，我们需要同时去发布根目录下的HTML文件，和Dist目录下所有的打包结果，那这样的话相对麻烦一些，而且我们上线过后还需要去确保，HTML代码当中路径引用都是正确的

那第二个问题就是，如果说我们输出的目录，或者是输出的文件名，那也就是我们打包结果的配置发生了变化，那HTML代码当中，script标签所引用的那个路径，也就需要我们手动的去修改，那这是硬编码的方式存在的两个问题。

解决这两个问题最好的办法，就是通过Webpack自动去生成我们的HTML文件，也就是让HTML也去参与到Webpack的构建过程，那在构建过程中，Webpack它知道它生成了多少个bounder，它会自动将这些打包的bounder，添加到我们的页面当中，那这样的话，一来我们的HTML它也输出到了Dist目录，那上线时我们就只需要把Dist目录发布出去就可以了，二来我们HTML当中对于bounder的引用，它是动态的注入进来的，它不需要我们手动的去硬编码，所以说它可以确保路径的引用是正常的。

自动生成使用bundle.js的HTML ，上面之前的文档都是手动的指定html对生成之后的文件进行引用，设置publicPath。html-webpack-plugin目的是为了将html也打包到dist目录，里面的文件引用也自动引用。

因为我们之前去尝试其他特性的时候，我们去把output的属性当中的这个，public path设置成了dist

- ![image-20230716120535110](%E7%AC%94%E8%AE%B0.assets/image-20230716120535110.png)

- ![image-20230716120434089](%E7%AC%94%E8%AE%B0.assets/image-20230716120434089.png)



##### 设置html的标题

- 有了html-webpack-plugin过后，我们就可以动态生成我们应用所需要的HTML文件了，但是这里仍然存在一些需要改进的地方，首先就是我们对于默认生成的HTML当中的标题，它是必须要修改的，另外我们很多时候还需要去自定义，页面当中的一些原数据标签和一些基础的DOM结构，对于简单的自定义的话，我们可以通过修改html-webpack-plugin，这个插件的一些属性来去实现，我们回到Webpack的配置文件当中，这里我们给HTML Webpack plugin这个构造函数，去传入一个对象参数，用于去指定我们的配置选项，Title属性就是用来去设置我们HTML的标题，然后Meta属性可以以对象的形式，去设置页面当中的一些原数据标签，例如我这里尝试为页面当中去添加一个Viewport的设置。
  - ![image-20230716121955299](%E7%AC%94%E8%AE%B0.assets/image-20230716121955299.png)
  - ![image-20230716122003541](%E7%AC%94%E8%AE%B0.assets/image-20230716122003541.png)
- 更好的做法就是在原代码当中去添加一个，用于去生成HTML文件的一个模板，然后让html-webpack-plugin这个插件，根据我们这个模板去生成页面，我们尝试着在SRC目录下去新建一个，index.html的一个HTML模板，然后我们可以根据我们的需要，在这个文件当中去添加一些相应的元素，对于这个模板当中我们希望动态输出的一些内容，我们可以使用loadash模板语法的方式去输出，这儿我们就可以通过html-webpack-plugin.options这个属性，去访问到我们这个插件的配置数据，那配置数据当中的title，我们就可以直接输出出来，当然html-webpack-plugin这个变量，实际上是它内部提供的一个变量，你也可以通过另外一个属性，去添加一些自定义变量，有了这个模板文件过后，我们回到配置文件当中，那这儿我们通过template的属性，去指定我们这里所使用的模板为，src目录下的index.html文件，以上就是我们自定义输出html文件内容的一些方式
  - ![image-20230716122027387](%E7%AC%94%E8%AE%B0.assets/image-20230716122027387.png)
  - ![image-20230716122036535](%E7%AC%94%E8%AE%B0.assets/image-20230716122036535.png)



##### 同时输出多个页面文件

除了自定义输出文件的内容
同时去输出多个页面文件也是一个非常常见的需求
除非说我们的应用是一个单一页面应用程序

- ![image-20230716122633047](%E7%AC%94%E8%AE%B0.assets/image-20230716122633047.png)

####  webpack常用插件(copy-webpack-plugin & 总结)

- 插件copy-webpack-plugin是用来复制文件的。在我们使用Webpack的时候，有一些本地资源，例如图片和音视频，在打包过程中没有任何模块使用到它们，但我们却想要把它们放在打包后的资源输出目录。预处理器loader是不适合做这种事情的，这个时候需要使用插件，copy-webpack-plugin这个插件就可以帮助我们完成这个事情。

- ![image-20230716122944754](%E7%AC%94%E8%AE%B0.assets/image-20230716122944754.png)
- ![image-20230716122957798](%E7%AC%94%E8%AE%B0.assets/image-20230716122957798.png)
- github 根据关键词搜索 webpack 插件
  - ![image-20230716123032786](%E7%AC%94%E8%AE%B0.assets/image-20230716123032786.png)
- 

####  webpack开发一个插件（plugin）

通过在生命周期的钩子中挂载函数实现拓展。

因为 loader 只是在加载模块的环节去工作，而插件的作用范围几乎可以触及到 webpack工作的每一个环节

webpack的插线机制其实就是我们在软件开发中,最常见到的钩子机制,钩子机制也特别容易理解,它有点类似于我们web当中的"事件",在webpack工作的过程当中会有很多环节,为了便于插线的扩展,webpack几乎给每一个环节都埋下了一个钩子,这样的话,我们在去开发插件的时候,我们就可以通过往这些不同的节点上去挂载,不同的任务就可以轻松地去扩展webpack的能力.
具体有哪些预先定义好的钩子,我们可以参考官方的 API 文档 (hook)

- 我们来定义一个插件，来去看一看具体如何往这些钩子上去挂载任务，webpack要求我们的插件必须是一个函数，或者是一个包含 Apply 方法的对象，一般我们都会把这个插件定义为一个类型，然后在这个类型当中去定义一个 Apply 方法，我们使用的时候就是通过这个类型去构建一个实例，然后去使用。
- 我们这里定义一个 MyPlugin 的一个类型,然后我们在这个类型当中去定义一个 Apply 方法，这个方法会在 webpack启动时自动被调用它接受一个 Compiler 对象参数，这个对象就是 webpack工作过程当中最核心的一个对象，这个对象里面包含了我们此次构建的所有的配置信息，我们也是通过这个对象去注册钩子函数，这里我的需求是我们希望这个插件可以用来去，清除 webpack在打包生成的 JS 当中那些没有必要的注释，这样一来的话,我们 Bundle.js 当中去除了这些注释过后就可以更加容易阅读
- 对打包之后的js文件去除注释
  ![image-20230716124356401](%E7%AC%94%E8%AE%B0.assets/image-20230716124356401.png)
- ![image-20230716124738954](%E7%AC%94%E8%AE%B0.assets/image-20230716124738954.png)

#### webpack开发体验问题（提高开发效率）

如果以目前的状态去应对日常的开发工作还远远不够，因为通过编写源代码、然后webpack打包、再运行应用、最后刷新浏览器 这种周而复始的方式过于原始。

如果说我们在实际的开发中还按照这种方式去使用，那必然会大大降低我们的开发效率。

- 那究竟该如何去提高我们的开发效率呢?
  - 这里我们先对我们理想的开发环境做出设想，首先我们希望这样一个环境它必须能够使用HTTP服务去运行，而不是以文件的形式去预览，那这样的话我们一来可以更加接近生产环境的状态，二来我们可能会需要去使用 ajax 之类的一些API，那这些API文件的形式去访问它是不被支持的，那其次我们希望这样一个环境当中，我们去修改原代码过后，webpack就可以自动帮我们完成构建，然后我们的浏览器可以及时显示最新的结果，那这样的话就可以大大减少我们在开发过程中，额外的那些重复操作。
  - 那最后我们还需要这样一个环境，它能够去提供sourcemap支持，那这样一来的话我们运行过程当中一旦出现错误，就可以根据错误的对战信息，快速定位到原代码当中对应的位置，便于我们调试应用，那对以上这些需求webpack都已经有相对应的功能去实现了，那接下来我们一起重点了解具体如何去增强，我们使用webpack的开发体验
- 

####  webpack自动编译（增强开发体验）

- 目前呢,我们每次修改完原代码,都是通过命令行手动重复去运行webpack命令
  ,从而得到最新的打包结果,那这种办法呢,特别的麻烦。
- yarn webpack --watch
- webpack 就会以监视模式去运行,那在打包完成过后呢,我们的CLI不会立即退出
  他会等待文件的变化,然后再次工作,那一直到我们手动结束这个CLI,那在这种模式下面,
  我们就只需要专注编码,不必再去手动完成这些重复的工作了

#### webpack自动刷新浏览器

BrowserSync

- 全局范围安装BrowserSync工具，监听dist文件改变，自动刷新浏览器。
- browser-sync dist --files "**/*"
  - ![image-20230716213033042](%E7%AC%94%E8%AE%B0.assets/image-20230716213033042.png)
- 它的原理就是webpack 自动打包原代码到Dist当中,Dist文件的变化又被Browser Sync监听了,从而去实现了我们的自动编译并且自动刷新浏览器,不过这种方式去解决有很多弊端,第一就是我们操作上太麻烦了,因为我们需要同时使用两个工具,第二就是我们在开发效率上会有一些降低,因为这个过程当中webpack 会不断的将文件写入磁盘,然后Browser Sync再从磁盘中把它读出来,这个过程当中一次就会多出两步的磁盘读写操作,所以说我们还需要继续去改善开发体验

####  Webpack Dev Server

webpack dev server 是webpack 官方推出的一个开发工具,它提供了一个开发服务器,
并且它将自动编译和自动刷新浏览器等一系列,对开发非常友好的功能,都全部集成在了一起。

- 因为这是一个高度集成的工具，所以说它使用起来也非常的简单，我们这儿打开命令行
  ，然后我们通过yarn去将Webpack Dev Server，作为我们项目的开发依赖去安装
  安装完成过后，这个模块它为我们提供了一个，Webpack Dev Server的CLI程序。

- 我们同样可以直接通过yarn去运行CLI，或者你可以把它定义到npm scripts当中
  我们去运行这个命令，它内部就会自动使用Webpack 去打包我们的应用，并且会启动一个HTTP Server，去运行我们的打包结果，在运行过后，它还会去监听我们的代码变化，一旦我们的语言文件发生变化，它就会自动立即重新打包，这一点跟我们的watch模式是一样的。
- Webpack Dev Server它为了提高工作效率，所以它并没有将打包结果写入到磁盘当中
  ，我们根据我们左侧的文件树，我们应该发现并没有出现dist的目录，它是将打包结果暂时存放在内存当中，而内部的HTTP Server，也就是从内存当中把这些文件读出来
  然后发送给浏览器，这样一来的话，它就会减少很多不必要的磁盘读写操作
  从而大大提高我们的构建效率，这里我们还可以为这个命令，传入一个--open的参数，然后它可以用于去自动唤起我们的浏览器，去打开我们的运行地址
  - yarn webpack-dev-server --open
- 

#### webpack dev server静态资源访问

- webpack dev server默认会将构建结果输出的文件，全部作为开发服务器的资源文件
  那也就是说，只要是通过webpack 打包能够输出的文件，都可以正常被访问到，但是如果说你还有一些静态资源，也需要作为开发服务器的资源被访问的话，那你就需要额外的去告诉webpack dev server，具体的方法就是在webpack 配置文件当中，去添加一个对应的配置。
- 配置文件当中，这里我们在配置对象当中，去添加一个dev server的属性，这个属性是专门用来为webpack dev server，去指定相关的配置选项，我们可以通过这个配置对象的Content-based属性，来去指定额外的静态资源路径，这个属性可以是一个字符串或者是一个数组，也就是说我们可以配置一个或者是多个路径，我们这里将这个路径设置为
  项目根目录当中的Public目录。
- 可能有人会有疑问，因为之前我们已经通过插件，将这个目录输出到了我们的输出目录
  按照刚刚的说法，我们所有输出的文件都可以直接被Serve，也就是直接可以在浏览器端访问到，按道理来讲的话，这里这些文件就不需要再作为，开发服务器的额外的资源路径了，事实情况确实如此，如果说你能这么想的话，也就证明你确实理解了这样一个点，但是我们在实际去使用webpack的时候，我们一般都会把CopyWebpackPlugin，这样的插件留在上线前的那一次打包中使用，在平时的开发过程当中，我们一般不会去使用它，这是因为在开发过程中，我们会频繁重复执行打包任务，假设我们需要拷贝的文件比较多，或者是比较大，如果说我们每次都去执行这个插件的话，我们打包过程当中的开销就会比较大，速度自然也就会降低了。
- 由于这是额外的话题，所以说具体的操作方式,就是具体怎么样去让我们在开发阶段，不去使用CopyWebpackPlugin，然后在上线前那一刻我们再去使用这种插件，这种操作方式我们在后续再来介绍，这里我们先注释掉CopyWebpackPlugin，这样确保我们在打包过程当中，不会再去输出Public目录当中的静态资源文件。
- - !image-20230716222134758](%E7%AC%94%E8%AE%B0.assets/image-20230716222134758.png)
  - ![image-20230716222425447](%E7%AC%94%E8%AE%B0.assets/image-20230716222425447.png)

####  Webpack Dev Server代理API服务

由于开发服务器的缘故，我们这里会将应用运行在localhost的一个端口上面，而最终上线过后，我们的应用一般又和我们的API，会部署到同源地址下面，这样的话就会有一个非常常见的问题，那就是我们在实际生产环境当中，我们可以直接去访问API，但是回到我们的开发环境当中，就会产生跨域请求问题。

可能有人会说我们可以使用跨域资源共享的方式（CORS）去解决这个问题，事实也确实如此，我们如果请求的API，它支持CORS的话，我们这个问题就不成立了，但是并不是每种情况下，我们的服务端的API都一定要支持CORS的，如果说我们前后端同源部署的话，也就是我们的域名，然后协议和端口是一致的话，这种情况下，我们根本没有必要去开启CORS，所以以上这个问题还是经常会出现。

解决这个问题最好的办法，就是在我们的开发服务器当中，去配置代理服务，也就是把我们的接口服务，代理到本地的开发服务地址，Webpack Dev Server，它就支持直接通过配置的方式，去添加代理服务，具体的用法我们一起来尝试一下，我们这里的目标，就是将GitHub的API，代理到我们本地的开发服务器当中，我们先在浏览器当中尝试去访问一下其中的一个接口。

endPoint 可以理解为接口端点/入口





- ![image-20230716224432113](%E7%AC%94%E8%AE%B0.assets/image-20230716224432113.png)

- 开发环境

  - ![image-20230716223058667](%E7%AC%94%E8%AE%B0.assets/image-20230716223058667.png)

- 最终上线过后呢

  - ![image-20230716223111281](%E7%AC%94%E8%AE%B0.assets/image-20230716223111281.png)

-  GitHub的接口的endpoint，它一般都是在根目录下，例如我们这里所使用的，users endpoint，知道了接口的地址过后，我们回到配置文件当中

  - 这里我们在DevServer当中，去添加一个proxy属性，这个属性就是专门用来
    去添加代理服务配置的，这个属性它是一个对象，其中每一个属性，就是一个代理规则的配置，属性的名称，我们需要被代理的请求路径前缀，也就是我们请求以哪一个地址开始，它就会走代理请求，一般为了容易辨别，我都会将其设置为/api。
    
  - 也就是我们请求我们开发服务器当中的，/api开头的这种地址，我们都会让它代理到我们的接口当中，它的值是为前缀所匹配到的代理规则配置，我们将代理目标设置为
    https://api.github.com，也就是说当我们请求以斜线开头，我们的代理目标就是
    https://api.github.com，这样一个地址，此时如果我们去请求https://localhost8080，也就是webpack dev server的地址，然后请求/users，我们就相当于请求了 https://api.github.com/api/users
    
  - 这也就意思是什么，我们请求的路径是什么。它最终代理的地址路径是会完全一致的
    而我们需要请求的接口地址，实际上是在api.github.com，斜线也就是根路径下面的users，没有/api，所以说我们对于代理路径当中的 /api，我们需要通过重写的方式把它去掉，我们可以在这再去添加一个，pathRewrite属性，来去实现代理路径的重写，重写规则就是把我们路径当中，以斜线API开头的这段字符串，给它替换为空，因为pathRewrite这个属性，它最终会以正则的方式来去替换，我们请求的路径，所以说我们这以上间号表示开头，除此之外我们还需要设置，change origin属性为true,这是因为默认我们代理服务器，会以我们实际在浏览器当中，请求的主机名，我们这也就是localhost:8080作为代理请求的主机名.什么意思?
    也就是我们在浏览器端，对我们的代理过后的地址发起请求，这个请求背后，它肯定还需要去请求到GitHub的服务器，请求的过程当中会带一个主机名，这个主机名默认情况下，使用的是我们用户在浏览器端，发起请求的主机名，也就是localhost的:8080，而一般情况下，服务器那头，它是需要根据主机名去判断，我这一台服务器，因为你一个请求，请到服务器过后，服务器一般会有多个网站，它会根据主机名去判断，请求是属于哪一个网站，从而把请求，指派到对应的网站，localhost:8080，对于GitHub的服务器来说，肯定是不认识的，所以说我们这需要去修改
    change origin等于true的这种情况下，就会以实际我们代理请求，这一次发生的过程当中的主机名，去请求，我们请求GitHub的地址，我们真正请求的，应该是api.github.com。这样一个地址所以说它的主机名，肯定就会保持原有的状态，这个时候我们就不用再关心，我们最终把它代理成了什么样，我们只需要去正常的去请求就可以了。
    
    完成以后，我们再回到命令行终端，然后去运行webpack dev server,然后我们再去打开浏览器
    我们看到此时这个地址,它就被代理到,我们GitHub的用户数据接口,我们这个地方
    可以再次回到代码当中,来去使用代理过后的地址,去请求接口,这种地址,它就不用再担心,因为它是同源地址,它就不用担心跨域的问题了,可能在这个过程当中,针对于ChangeOrigin,也就是主机名那一块,可能会有一些,只是了解过一些前端基础的同学
    会不会特别清楚,这个原因是因为,我们在http里面,有一些相关的知识点,可能你之前没有了解过,你可以再去查一下,就是host,也就是主机名相关的一些概念,那就可以解决这些问题了
    
  - ![image-20230716223727020](%E7%AC%94%E8%AE%B0.assets/image-20230716223727020.png)

#### Source Map 

- 通过构建编译之类的操作，我们可以将开发阶段的原代码，转换为能够在生产环境当中运行的代码。意味着我们在实际生产环境当中运行的代码，与我们开发阶段所编写的代码之间会有很大的差异。调试我们的应用，又或是我们运行应用的过程当中出现了意料之外的错误，难以找到报错的地方。
- Source Map就是解决这一类问题最好的一个办法，它就是用来去映射我们转换过后的代码与源代码之间的一个关系，通过转换过程当中生成的Source Map文件，逆向得到源代码。



##### Webpack 配置 Source Map

- Webpack 的打包过程同样支持为我们的打包结果生成对应的Source Map文件，用法上也非常简单，不过它提供了很多不同的模式，这就导致大部分的初学者可能会比较懵。
- Webpack 对Source Map的风格支持啊，它支持了很多种，也就是说它有很多实现方式
  ，那每种方式所生成的Source Map的效果，以及生成Source Map的速度都是不一样的
  ，那很简单也很明显的一个道理就是，效果最好的一般它的生成速度也就会最慢，而速度最快的一般生成出来的Source Map文件，也就没有什么效果，那具体哪种方式才是最好或者说最适合我们的，那这里呢我们还需要继续去探索
- ![image-20230802222846014](%E7%AC%94%E8%AE%B0.assets/image-20230802222846014.png)

![image-20230802222812274](%E7%AC%94%E8%AE%B0.assets/image-20230802222812274.png)

- serve dist可以把打包结果直接运行起来。

##### Webpack eval 模式的 Source Map

- 不同模式之间的对比表，这张表中分别从初次构建速度，监视模式重新打包速度，还有是否适合在生产环境当中使用，以及所生成的sourceMap的质量，这四个维度去对比了这些不同方式之间的差异

![image-20230821205234255](%E7%AC%94%E8%AE%B0.assets/image-20230821205234255.png)

eval()函数可以执行js代码

- ![image-20230821205506430](%E7%AC%94%E8%AE%B0.assets/image-20230821205506430.png)

- eval模式
  - 它会运行在一个临时的虚拟机环境当中，我们可以通过source.url来去声明这段代码所属的文件路径
  - 我们这儿再来尝试执行一下，我们在这段JS代码字符串当中，去添加一个注释内容
    就是#source.url=./foo/bar，然后我们回车执行，此时我们这段代码它所运行的环境，就是./foo/bar,这也就意味着什么呢?意味着我们可以通过source.url来去改变,我们通过eval执行的这段代码所属的环境的一个名称，其实它还是运行在虚拟机环境当中，只不过它告诉了执行引擎，我这段代码所属的文件路径，这只是一个标识而已
  
- 将DevTool属性设置为eval，再次运行打包，打包完成过后，我们去运行一下这个应用，根据控制台的提示，我们就能找到这个错误所出现的文件，但是当我们打开这个文件，我们看到的却是打包过后的模块代码,

- 因为在这种模式下，它会将我们每个模块所转换过后的代码，都放在eval函数当中去执行，并且在eval函数执行的字符串，最后通过Source URL的方式去说明所对应的文件路径。
  这样的话，浏览器在通过eval去执行这段代码的时候，就知道这段代码所对应的原代码是哪一个文件，从而去实现我们定位错误所出现的文件，只能去定位文件，这种模式下，它不会去生成Source Map文件。
  
  也就是说它实际上跟Source Map没有什么太大关系，
  所以说它的构建速度，也就是最快的，但是它的效果也就很简单，它只能定位我们原代码文件的名称，而不知道具体的行列信息

##### Webpack devtool 模式对比（上）

![image-20230821210422477](%E7%AC%94%E8%AE%B0.assets/image-20230821210422477.png)

- 介绍
  - 为了可以更好的对比不同模式的sourceMap之间的差异
    这里我们使用一个新的项目来去同时创建出不同模式下的打包结果
    然后通过具体的实验来去横向对比它们之间的差异
  - 
- 

##### Webpack devtool 模式对比（下）

- eval 模式

  - 有了这些不同模式下的打包结果过后，接下来我们就可以一个一个仔细去对比了，我这里先带着大家去看几个比较典型的模式，然后找出它们之间的一些关系，首先我们看一下eval模式，这个模式我们刚刚已经单独看过了，它就是将我们的模块代码放到eval函数当中去执行，并且通过source URL去标注我们这个模块文件的路径。这种模式下它并没有生成对应的source map，它只能定位我们是哪一个文件出了错误。

    ![image-20230829214108402](%E7%AC%94%E8%AE%B0.assets/image-20230829214108402.png)

- eval-source-map

  - 然后我们再回来去看一个叫做eval-source-map的模式，这个模式它同样也是使用eval函数去执行模块代码，不过这里有所不同的是，它除了可以帮我们定位我们错误出现的文件，还可以定位到具体的行和列的信息，因为在这种模式下相比于eval,它生成了source map。
  - ![image-20230829214825503](%E7%AC%94%E8%AE%B0.assets/image-20230829214825503.png)

- cheap-eval-source-map

  - 再回过来我们再来看一个叫做cheap-eval-source-map的模式，这个模式的名字我们差不多就可以推断出来一些信息了，它其实就是在刚刚的eval-source-map的基础之上加了一个cheap，也就是便宜的或者叫廉价的，用我们计算机行业经常说的一个词就是阉割版的source map，为什么这么说呢，因为它虽然也生成了source map，但是这种模式下的source map，它只能帮我们定位到行而没有列的信息，那也就是少了一点效果，少了一点效果的话，它的生成速度自然也就会快很多
  - ![image-20230829214527697](%E7%AC%94%E8%AE%B0.assets/image-20230829214527697.png)

- cheap-module-eval-source-map

  - 接下来我们再来看一个叫做cheap-module-eval-source-map的模式，根据这个名字我们慢慢的就发现了，Webpack这些模式的名字好像不是乱起的，它好像有某种规律，这里其实就是刚刚的模式基础之上多了一个module，在这种模式下的特点可能乍一看不会那么明显，因为它也就只能定位到行，我们这里再来把刚刚cheap-eval-source-map的模式也找出来，然后我们仔细做一个对比，通过仔细对比，你会发现cheap-module-eval-source-map它定位原代码，跟我们编写的原代码是一模一样的
    而cheap-eval-source-map，它显示的是我们经过ES6转换过后的结果，这样的话这两者之间的差异也就出来了。
  - 这也是为什么我之前在配置的时候，会给JS文件单独配一个loader的原因，因为带有module这种模式下，它解析出来的源代码是没有经过loader加工，也就是我们真正手写的那些原代码，而不带module它是加工过后的一个结果，如果说我们想要真正跟我们手写代码一样的原代码的话，我们就需要选择cheap-module-eval-source-map这种模式，了解了以上这些模式过后，基本上你就可以算是通盘了解了所有的模式，因为其他的模式无外乎就是把这几个特点再次排列组合罢了，例如我们这还有一个叫做cheap-source-map，它没有eval也就意味着，它没有用eval的方式去执行模块代码，没有module的话也就意味着它反过来的源代码，是loader处理过后的代码。
  - ![image-20230829215029581](%E7%AC%94%E8%AE%B0.assets/image-20230829215029581.png)
  - 这几个特点
    - ![image-20230829215503763](%E7%AC%94%E8%AE%B0.assets/image-20230829215503763.png)
  - 

- 另外还有几个模式 

  - inline-source-map

    它跟普通的source-map其实效果上是一样的，只不过source-map的模式下，它的source map文件是以物理文件的方式存在，而我们inline-source-map的话，它使用的是data url的方式，去将我们的source-map，以data url嵌入到我们的代码当中
    我们之前遇到的eval-source-map，它其实也是使用这种行内的这种方式，把我们的source map嵌入进来了，这种方式实际上我个人觉得是最不可能用到的，因为它把source map放到原代码当中过后，这个时候就导致代码体积会变大很多

    ![image-20230829215656026](%E7%AC%94%E8%AE%B0.assets/image-20230829215656026.png)

  - hidden-source-map

    这个模式下我们在开发工具当中，是看不到source map的效果的，但是我们回到开发工具当中，我们去找一下这个文件，我们会发现它确实生成了source map文件
    这就跟jQuery是一样的，在构建过程当中生成了source map文件，但是它在代码当中，并没有通过注释的方式去引入这个文件，所以说我们在开发工具当中看不到效果
    这个模式实际上是我们在开发一些第三方包的时候，会比较有用，我们需要去生成source-map，但是我们不想在我们的代码当中直接去引用它们，一旦当使用我们这个包的开发者出现了问题，他可以再把source map再引入回来，或者通过其他的方式去使用source-map,source-map还有很多其他的使用方式。
    通过HTTP的响应头也可以去使用，这些我们就不在这扩展了，然后回过来我们再看。

    - ![image-20230829215957908](%E7%AC%94%E8%AE%B0.assets/image-20230829215957908.png)

  - 

-  nosources-source-map

  这个模式下我们能看到错误出现的位置，但是我们点击这个错误信息，我们点进去过后是看不到原代码的，这个no source指的就是没有源代码，但是它同样给我们提供了行列信息，这样的话对于我们来讲的话，我们还是结合我们自己编写的原代码，还是可以找到错误出现的位置，只是我们在开发工具当中看不到源代码而已，这是为了在生产环境当中去保护我们的原代码，不会被暴露的这样一种情况，这是no source source map这个模式。

  ![image-20230829220549110](%E7%AC%94%E8%AE%B0.assets/image-20230829220549110.png)

  ![image-20230829220529393](%E7%AC%94%E8%AE%B0.assets/image-20230829220529393.png)

  以上我们介绍了很多种的source map，也做了一些具体的对比，通过这些对比大家要能总结出来，source map里面这几个核心关键词，它们的一些特点，然后对于其他几个模式，我们没有介绍到的，你就很容易能知道它们一些特点了，大家可能了解很多的这些模式过后，对大家来讲的话，最痛苦的一件事情就是，选择一个合适的source map模式
  这个我们再接着来看。

#### Webpack 选择 Source Map 模式

虽然Webpack可支持各种各样的Source Map模式，但是其实我们掌握它们的特点过后
我们发现一般我们在应用开发时，也就只会用到其中的几种，根本就没有选择上需要纠结的点，这里我来介绍一下我个人在开发时的一些选择。
首先先说开发过程中，也就是开发环境下，在开发环境下我会选择cheap-Module-eval-Source Map，具体的原因有三点。

![image-20230830213725265](%E7%AC%94%E8%AE%B0.assets/image-20230830213725265.png)

第一就是我编写代码的风格，一般会要求每一行代码不会超过80个字符，对我而言的话，能够帮我定位到行也就够了，因为每一行里面最多也就80个字符，我能够很容易找到对应的位置。

第二就是我使用框架的情况会比较多，我们以React和Vue来说，无论是我们使用JSX，还是Vue的单文件组件，Loader转换过后的代码，和我们转换之前都会有很大的差别，我这儿需要去调试我转换之前的原代码，而不是转换过后的，所以我们要选择有Module的这种方式。
第三点就是虽然这种cheap-module- eval-source-map，它的启动就是打包启动速度会慢一些，但是大多数时间我都是在使用webpack-dev-server。以监视模式去重新打包，而不是每次都启动打包，所以说这种模式下它重新打包速度比较快，这也是我选择它的一个原因。
**综上所述我选择就是，在开发环境我选择cheap-module- eval-source-map，至于发布前的打包，也就是我们针对于生产环境的打包，我会选择None，也就是不生成的source map**，原因也很简单，因为source map它会暴露我原代码到生产环境，这样的话但凡是有一点技术的人，都可以很容易去复原我项目当中，绝大多数的原代码，而这一点其实被很多开发者可能都忽略掉了，他们就光认为source map能够带来便利，但是便利的同时也会有一些隐患，所以这个点是需要注意的。
其次我个人认为调试和报错找错误，这些都应该是开发阶段的事情，你应该在开发阶段就尽可能把所有的问题和隐患都找出来，而不是到了生产环境让全民去帮你公测，**所以说这种情况我就尽量避免不在生产环境去使用source map，如果说你对你的代码实在是没有信心的话，我建议你选择nosources-source-map模式，这样的话出现错误的话，在控制台当中就可以找到源代码对应的位置，但是不至于去向外暴露你的源代码内容，**当然了这个过程当中我的这些选择实际上也没有绝对，我们去理解这些模式之间的差异的目的，就是为了可以让我们在不同环境当中，然后快速去选择一个合适的模式，而不是去寻求一个通用的法则，在开发行业没有绝对的通用法则。

#### Webpack 自动刷新的问题  

![image-20230830220245971](%E7%AC%94%E8%AE%B0.assets/image-20230830220245971.png)

在此之前我们已经简单了解了Webpack Dev Server的一些基本用法和特性，
它主要就是为我们使用Webpack Dev Server构建的项目提供了一个比较友好的开发环境，
和一个可以用来调试的开发服务器，使用Webpack Dev Server就可以让我们的开发过程更加专注于编码，因为它可以监视到我们的代码的变化，然后自动进行打包，最后再通过自动刷新的方式同步到浏览器，以便于我们可以及时预览。
但是当你实际去使用这样一个特性去完成一些具体的开发任务时，那你会发现这里还是会有一些不舒服的地方，那例如这里是一个编辑器的应用，我想要在这里能够及时去调试编辑器当中文本内容的样式，那正常的操作我肯定是先尝试在这个编辑器里面去添加一些文本作为展示样例，然后我们回到开发工具当中,找到控制这个编辑器样式的CSS文件，那在这个样式文件当中我们简单去添加一些样式，那这个时候我们就能发现问题了。
当我们修改完样式过后呢，原本想着可以及时看到最新的界面效果，但是这个时候我们编辑器当中的内容却没有了，那这里呢我们不得不再来编辑器当中再去添加一些文本，那如果说此时你对我们的样式还是不满意的话，那我们还需要继续来去调整样式，而且调整完了过后又会面临文本内容丢失的这样一个问题，那久而久之的话你就会发现自动刷新这样一个功能还是很鸡肋，它并没有我们想象的那么好用
那这是因为我们每次修改完代码，Webpack监视到文件的变化过后就会自动打包，然后自动刷新到浏览器，那一旦页面整体刷新，那页面中之前的任何操作状态都会丢失，所以说就会出现刚刚我们所看到的这样一个情况

但是聪明的人一般都会有一些小办法，例如我们可以在代码当中先去写死一个文本到我们的编辑器当中，那这样的话即便是我们页面刷新也不会有丢失的这种情况出现，那又或是我们通过一些额外的代码，把我们的内容先保存到local storage之类的一些地方
然后刷新过后我们再去取回来，那总之就是你有问题我有办法
那确实这些都是好办法，但是又都不是特别的好，因为这些都是典型的有动不动的操作
并不能根治我们页面刷新过后导致的页面状态丢失的这样一个问题
而且这些方法都需要我们去编写一些跟我们业务本身无关的一些代码，那更好的办法自然是能够在页面不刷新的这种情况下，我们代码也可以及时的更新进去，那针对这样的需求Webpack同样也可以满足，那接下来我们就一起去了解一下Webpack当中，如何去在页面不刷新的情况下，及时的去更新我们的代码模块。

####  Webpack HMR 体验

HMR介绍，模块热替换

HMR全称是Hot Module Replacement，翻译过来叫做模块热替换，或者叫做模块热更新
计算机行业我们经常听到一个叫做热拔插的名词，指的就是我们可以在一个正在运行的机器上，随时去插拔设备，而我们机器的运行状态是不会受插拔设备的影响，而且我们插上的设备可以立即开始工作。
那例如我们在电脑上的USB端口就是可以热拔插的，那模块热替换当中的这个热，跟我们刚刚提到的热拔插实际上是一个道理，它们都是在运行过程中的即时变化,那Webpack中的模块热替换指的就是
我们可以在应用程序运行的过程中,实时的去替换掉我们应用中的某个模块，而我们应用的运行状态不会因此而改变，那例如我们在应用程序的运行过程中，我们修改了某个模块，那通过自动刷新就会导致我们整个应用整体的刷新，那页面中的状态信息都会丢失掉，而如果我们这个地方使用的是热替换的话，我们就可以实现只将刚刚修改的这个模块，实时的去替换到应用当中，不必去完全刷新应用。
那这里我们可以先来对比一下，使用热更新和使用自动刷新，这两种方式之间的体验差异。
那屏幕上所显示的这个项目，我已经开启了HMR这样一个特性，那这里我们同样先在我们的页面当中，先去添加一些内容。也就是为我们的页面去制造一些运行的状态。
然后我们回到开发工具当中，那这里我们尝试去修改我们文本的样式，我们先将它的颜色修改为红色，那保存过后我们就可以立即看到最新的样式结果，而我们整个页面并没有整体的刷新，那这种体验是非常友好的。
那对于项目中其他代码文件的修改，也可以有相同的热替换的这样一种体验，那我们这里再来尝试修改一下JS文件，那这里我们打开editor.js文件，然后我们随意去修改一下这里的代码，然后保存，那此时我们浏览器当中也没有刷新页面，而是直接执行了我们刚刚所修改的模块。
那不仅如此，对于我们项目当中那些非文本文件，同样也可以使用热更新，那例如我们这里所显示的一张是背景图片，我们可以回到文件夹当中找到它，那这里我们先就通过简单的画图板来去修改一下这个图片，保存过后呢，我们浏览器当中同样也可以及时更新过来我们最新的这张图片，而我们整个应用的运行状态呢，也没有因此而发生变化，那这就是HMR的作用和它的一个体验。
那HMR可以算是webpack中最强大的特性之一，同时呢它也是最受欢迎的一个特性，因为呢它确实极大程度的提高了开发者的工作效率，所以说我们接下来呢要重点来去看如何去使用HMR。



#### Webpack开启 HMR

对于热更新这么强大的功能而言，它的使用并不算特别的复杂，接下来我们就一起来了解一下具体如何去使用HMR。
HMR已经集成在了WebpackActiveServer这样一个工具当中，所以说我们就不需要再去单独安装什么模块了，
使用这个特性我们需要在去运行WebpackActiveServer这个命令时，然后我们通过"--hot"这个参数去开启这个特性，
或者你也可以在我们的配置文件当中去添加对应的配置，来去开启这样一个功能。
我们这里打开配置文件，这里我们需要配置的地方有两个，第一个就是我们先要将DevServer当中的"hot"属性设置为true，
然后我们需要去载入一个插件，这个插件是WebpackActiveServer内置的一个插件，所以说我们这里先去导入WebpackActiveServer模块，有了这个模块过后，我们这里使用的是这个模块当中的"hot module replacement plugin"这样一个插件。
我们把插件配置进来，配置好了过后我们打开命令行终端，因为我们已经开启了HMR，所以说我们这直接去运行WebpackActiveServer，然后去启动WebpackActiveServer开发的服务器，接下来我们就可以尝试在浏览器当中去体验HMR所带来的这样一个优势了。

我们再回到开发工具当中，这里我们先尝试去修改一下样式文件，保存过后，这个样式模块就可以以热更新的方式直接去作用到我们的页面当中了，然后我们再来尝试去修改一下JS模块文件，我们这里打开editor.js，我这随便在console.log里面去添加点内容，保存，此时我们就会发现这里的页面它却自动刷新了，好像并没有我们刚刚所看到的那种热更新的体验。
我们再到页面当中的编辑器当中去添加一些文字，这样的话我们可以更容易去确认是否有刷新，完成过后我们再回到开发工具当中，
这里我们再来修改一下JS文件，我们在这Alert一个内容，这一次我们仔细去观察一下浏览器的图标，看看它是否刷新了页面，保存一下，
这里因为它有Alert的缘故，所以说我们刷新的状态会被阻塞住，所以我们能看到它确实是自动刷新页面了，
这到底是为什么呢？
我们这的样式文件修改它确实已经有热更新了，但是JS文件它好像又有问题，具体我们该如何去实现所有模块资源的热替换，
我们接着再来看，我们再来看一下JS文件的图标

#### Webpack HMR的疑问

通过一开始的体验我们发现了模块热替换，确实提供了非常友好的开发体验，但是当我们自己尝试开启HMR过后，
我们发现效果却不尽如人意。
这里是因为HMR它并不像Webpack其他的特性一样，可以开箱即用，也就是说我们的HMR还需要我们做一些额外的操作才可以正常工作，Webpack中的HMR需要我们手动通过代码去处理。当模块更新过后，我们需要如何把更新过后的模块去替换到我们运行的页面当中。
可能会有人问，为什么当我开启了HMR过后，我们的样式文件就可以直接去热更新呢，我们好像也没有手动的去处理样式模块的更新。
这是因为样式文件它是经过loader处理的，在style loader当中就已经自动处理了样式文件的热更新，所以说我们就不需要我们自己去额外做手动的操作。
可能你会想凭什么样式文件就可以自动处理，而我的脚本文件就需要我们自己手动处理呢？
这个原因也很简单，因为在样式模块更新过后，它只需要把更新过后的CSS及时替换到页面当中，它就可以覆盖掉之前的样式，从而实现样式文件的更新。
而我们所编写的JavaScript模块它是没有任何规律的，因为你可能在一个模块当中导出的是一个对象，也有可能导出的是一个字符串，
还有可能导出的是一个函数，那我们对导出的成员我们的使用也是各不相同的，所以说Webpack面对这些毫无规律的JS模块，
它就根本不知道如何去处理你更新过后的模块。
那也就没有办法去帮你实现一个，可以通用所有情况的模块替换方案，那这就是为什么样式文件可以直接热更新，而JS文件更新过后我们页面还是自动刷新的原因。
那可能有一些使用过View-CLI或者是Create React App的，一些交流一下这种工具的人来说，
他会觉得我的项目当中并没有手动的去处理我们JS模块的更新，我的代码照样可以做热替换，没有我们刚刚说的这么麻烦，那这是因为你使用的是框架，那我们使用框架开发时我们项目中的每一个文件，它自然就有了规律，因为框架它提供的就是一些规则。
那例如我们在React当中要求每一个模块文件，必须要去导出一个函数或者是导出一个类，那有了这样一个规律，那就可能会有通用的替换办法。

例如每一个文件它导出的都是一个函数的话，那我们就自动的把这个函数再拿过来再去执行一下，对吧，
而且这些工具内部都已经帮你提供好了这种通用的HMR替换模块，所以说我们就不需要自己手动处理了，那如果你之前没有接触过这样的工具，也无所谓，你可以忽略掉这一条，这并不影响我们后面的理解，
那综上所述，我们还需要自己手动来去处理，当JS模块更新过后，我们需要去做的事情。

#### Webpack 使用 HMR API

HotModule Replacement Plugin为我们的JS提供了一套用于去处理HMR的API，
那我们需要在自己的代码当中去使用这套API来去处理，当某一个模块更新过后应该如何替换到当前正在运行的页面当中。
那接下来呢我们一起回到代码当中，尝试通过HMR的API来去手动处理模块更新过后的热替换，
那这里呢我们打开MendirJS，那这是我们打包的Rook文件，
也就是在这个文件当中才开始去加载其他的模块，那就是因为这个文件当中使用了这些导入的模块，
那一旦当这些模块更新了过后我们就必须要去重新使用这些模块，所以说我们需要在这个文件当中去处理，它所依赖的这些模块更新过后的热替换。
在这套API当中它为我们的Module对象提供了一个Hot属性，那这个属性呢也是一个对象，
它就是我们HMR API的核心对象，那它提供了一个Accept方法，用于去注册当我们某一个模块更新过后的处理函数，
那这个方法的第一个参数呢，接收的就是我们依赖模块的路径，第二个参数呢就是依赖路径更新过后的处理函数，
那我们这里先来尝试注册一下，
当我们的edit模块更新过后的处理函数，那这里第一个参数就是edit模块的路径,然后第二个参数呢我们传入一个函数，
然后在这个函数当中我们去打印一个消息，表示一下我们这个edit模块更新了，完成过后呢我们打开命令行终端，
再次启动Webpack Dev Server，然后回到浏览器再去打开开发人员工具。

那这个时候呢我们就可以尝试回到开发工具当中，
去修改editor这个模块了，那我们打开editor.js，我们随便尝试做一些修改,然后保存。
那此时浏览器的控制台当中就会自动打印，我们刚刚所打印的那个消息了，而且呢也就不会再去触发自动刷新了，
那也就是说一旦当这个模块的更新，被我们这样手动的处理了，那它就不会去触发自动刷新，
反之如果我们没有手动处理这个模块的热替换，那HMR就会自动fallback到自动刷新，从而导致我们页面的刷新。

####  Webpack 处理 JS 模块热替换

了解了 API 的作用过后
我们就需要去考虑具体该怎样实现
edit 模块热替换的逻辑
这个模块导出的是一个函数
我们这儿先直接把它打印到控制台当中
然后在模块更新过后我们再去打印一次
这个时候我们回到 editor.js 当中
我们尝试去修改这个模块
保存
此时你会发现当我们的模块更新过后
我们这里拿到的函数也就更新为了最新的结果
知道这样一个特点过后就好办了
因为我们在这儿是使用这个函数去创建了一个界面的元素
一旦当这个模块更新了
我们界面上的元素也应该被重新创建
所以说我们这里先直接去移除原来的元素
然后我们再次去调用 create edit 这个函数
去创建一个新的元素追加到页面当中
这样的话就相当于我们这个模块重新工作了
并且我们这儿还需要去记录下来
我们新创建的这个元素把它放在一个变量当中
否则的话我们下一次热替换的时候
就找不到这一次所创建的这个元素了
那完成以后我们再来尝试修改一下 edit 模块
这里我们尝试为这个元素添加一个 ID 属性
然后保存
保存过后我们回到浏览器当中来查看一下
这里界面当中的元素确实立即更新为了我们最新的结果
我们再尝试在界面上输入一些内容
然后回到代码当中
再来接着去修改 edit 模块
此时你就会发现跟我们之前同样的问题
由于热替换时我们把界面上之前的编辑器元素已经移除掉了
那我们之前所输入的状态自然也就丢失掉了
然后替换为了一个新的元素
所以说我们界面上的这些状态都会丢失
那这也就证明我们的热替换操作还需要继续改进
那我们必须要在替换掉原来的元素之前
先把它的状态保留下来
那想要保留我们这个编辑器当中的状态也非常简单
我们就是把这个编辑器当中之前的内容先给它存下来
然后在替换过后我们再把它放回去就可以了
那因为这儿我使用的是一个可编辑元素
并不是一个文本框
所以说我需要通过 innerHTML
拿到我们之前所添加的内容
然后我们在创建新元素过后
我们再把它设置到新元素当中
那这样的话就可以解决我们这个文本框状态的丢失问题
那我们再次回到浏览器当中
这里我们再输入一些内容
完成过后我们再回到开发工具当中去修改 edit 模块
那此时这个模块就可以以正常的热替换的方式更新进去了
而不用担心我们状态丢失的问题
因为我们模块重新工作的时候
我们已经把上一次的状态给它记录下来
那这就是我们针对于js模块热替换的一个处理过程
注意这不是一个通用的方式
这只是针对于我们当前的editor.js这个模块
那通过这样一个过程我们就应该能够发现
那为什么Webpack它的HTML需要我们自己去处理js模块的热更新
因为不同的模块它有不同的逻辑
不同的业务逻辑又导致我们在这儿
它的处理过程肯定也是不同的
那我们这里是一个文本编辑器
所以说我们需要去保留状态
那如果说你这儿不是这种类型的
那你就不需要这么做
所以说Webpack根本没有办法去提供一个通用的替换方案
(Webpack的功能)

#### Webpack  处理 图片 模块热替换

相比于JS模块的热替换
图片模块的热替换逻辑就会简单得多
这里我们快速来看一下
我们同样通过module.hot.accept的方法
去注册一下图片模块的热替换处理函数
在这个函数当中
我们只需要将图片元素的SRC
设置为新的图片路径就可以了
因为在图片修改过后
我们的图片文件名是会发生变化的
而我们这儿呢
background它拿到的就是更新过后的路径
所以说我们直接重新设置图片元素的SRC
就可以实现图片的热替换
那以上呢
就是我们针对于两种不同类型资源的
热替换的处理过程
那可能你会觉得比较麻烦
因为我们需要去写一些额外的代码
甚至有人会觉得我们不如不用
那我个人的想法呢
是利大于弊
这个道理呢
就像是为什么现在的开发者都愿意去写一些单元测试一样
对于一个长期开发的项目
这点额外的工作并不算什么
而且如果说你能够为自己的代码设计一些规律的话
那你也可以去实现一些通用的替换方案
那当然如果说你使用的是框架去开发的话
那使用HMR将十分简单
因为大部分框架当中都有成熟的HMR方案
那你只需要去使用就可以了
但是我们这儿使用的是纯原生的方式去做的开发
所以说HMR使用起来相对会麻烦一点
那这也正是为什么大部分人都喜欢选择集成式框架的原因
因为足够简单
那我们就来看一下

#### Webpack  HMR 注意事项

那刚开始去使用HMR
肯定会遇到一些问题
下面我们来看几个最有可能发生的问题
和大家容易产生疑惑的地方
那首先呢
大家容易出问题的地方就是
如果说我们处理热替换的代码有错误
那就不容易发现
那例如我们在这儿
故意在代码当中去加入一个运行是错误
那结果呢也会导致我们页面自动刷新
而自动刷新过后呢
页面当中的这个错误信息已经被清除了
那这样一来的话
我们就不容易发现我们到底是哪个地方出错了
那这种情况下的话
我推荐大家使用hot only的方式来去解决
因为我们默认使用的这种hot的方式
那如果说热替换失败
那它就自动会回退去使用自动刷新这样一个功能
而hot only的情况
它就不会去使用自动刷新
那我们回到配置文件当中
那这里呢我们将div server当中的hot=true
修改为hot only=true
然后呢我们再重新启动webpack div server
那此时呢我们再去修改我们的代码
那无论说这个代码
它是否被处理了模块的热替换
那浏览器都不会去自动刷新了
那这样的话
我们这些错误信息就可以很容易的直接看到了
那第二个问题就是
如果我们在代码当中使用了HMR提供的API
但是呢我们在启动webpack div server的时候
我们没有开启HMR的选项
那此时我们在运行环境当中就会爆出一个
cannot read property except of undefined的一个错误
那原因是因为module.hot这个对象
它是HMR这个插件所提供的
那我们没有开启这个插件
也就自然没有这个对象
那解决的办法呢也非常简单
就跟我们在业务代码当中去判断API兼容一样
我们这应该先去判断是否存在这个对象
然后再去使用它
这样的话就可以解决我们这样一个错误的问题
那除此之外
大家可能还会有一个疑问
那就是我们在我们的代码当中
写了很多与业务功能本身无关的代码
那这会不会有影响
那这个答案呢也很简单
我们通过一个简单的尝试来去告诉你
我们回到配置文件当中
那这里呢我们确保我们已经将热替换这个特性给它关闭掉了
并且呢我们已经移除掉了热替换这个插件
然后呢我们打开命令行中端
这样呢我们再去运行一下Webpack打包
注意是运行一下Webpack打包
那打包完成过后呢
我们找到打包生成的bundler.js这样一个文件
然后呢我们在这个文件当中去找我们mundir.js所对应的那个模块
那找到过后呢你就会发现
其实我们代码当中所编写的那些处理热替换的代码
它都已经被移除掉了
那只剩下一个if first的一个空判断
那这种没有意义的判断呢
在我们代码压缩过后呢也会自动去掉
所以说它根本不会影响我们生产环境当中的运行状态
那至此呢我们对HMR的一个使用基本上就完全了解了

####  Webpack  生产环境优化

前面了解到的一些用法和特性都是为了可以让我们在开发阶段拥有更好的开发体验
而这些体验提升的同时,我们的打包结果也会随之变得越来越臃肿
这是因为在这个过程中,WipeEgg为了实现这些特性
它会自动往打包结果中添加一些额外的内容
例如我们之前所使用到的SoftMap和HMR
它们都会往输出结果中添加额外的代码来实现各自的功能
但是这些额外的代码对于生产环境来讲是冗余的
因为生产环境跟开发环境有着很大的差异
在生产环境中,我们强调的是以更少量、更高效的代码去完成业务功能
也就是说我们会更注重运行效率
而在开发环境中,我们会只注重开发效率
针对于这个问题,WipeEgg4当中就推出了Mode的用法
它为我们提供了不同模式下的一些预设配置
其中,生产模式中就已经包括了很多我们在生产环境中所需要的优化配置
同时,WipeEgg也建议我们为不同的工作环境去创建不同的配置
以便于让我们的打包结果可以适用于不同的环境
接下来,我们一起探索一下生产环境中有哪些值得我们优化的地方以及一些注意事项
我们下期再见
(字幕由Amara.org社区提供)
(字幕由Amara.org社区提供)

#### Webpack  不同环境下的配置

接下来我们先来尝试为不同的工作环境去创建不同的webpack配置
创建不同的环境配置的方式主要有两种
第一种就是在我们的配置文件当中去添加相应的判断条件
然后根据环境的判断条件不同导出不同的配置
第二种就是为我们不同的环境去单独添加一个配置文件
这样的话就确保我们每一个环境下面都会有一个对应的配置文件
我们分别来尝试一下这两种方式下
如何为我们的开发环境和生产环境去创建不同的配置
首先来看我们在配置文件当中去添加判断的这种方式
我们回到配置文件当中
webpack的配置文件还支持导出一个函数
然后在这个函数当中去返回我们所需要的配置对象
这个函数可以接受到两个参数
第一个是env
也就是我们通过CRI传递的一个环境名参数
第二个是argv
argv是指我们运行CRI过程中所传递的所有参数
我们就可以借助于这样一个特点来实现
为我们的开发环境和生产环境去分别返回不同的配置
我们先将这里的开发模式下的配置定义在config这样一个变量当中
然后我们再去判断一下env是不是等于production
这里我们约定的生产环境的env就是production
如果说是生产环境的话
我们这里就将mode的属性设置为production
然后我们再将divtool设置为first
也就是禁用掉sourcemap
最后我们再来添加clean webpack plugin和copy webpack plugin这两个插件
这两个插件我们之前介绍的时候也说到了
它实际上是在开发阶段可以省略的插件
它只是在上线打包之前有它实际的价值
这里我使用的是ES6扩展运算服的方式
把这两个插件和之前所有的插件放在一起去创建一个新的输出
完成以后我们打开命令行终端
然后我们先尝试直接去运行webpack
此时我们并没有传递任何参数
这里我们的webpack就会以开发模式运行打包
打包完成过后我们可以展开一下disk的目录
此时我们的目录下并不会有public目录当中拷贝过来的文件
然后我们再回到命令行
我们这运行一下webpack --env production
这时候就相当于给webpack传递了一个env的参数
这个参数的值是production
我们的配置文件接收到这样一个参数
就会返回生产模式下的配置
也就意味着我们此时webpack会以生产模式运行打包
我们这些额外的插件也就会工作起来
这里我们就能看到public目录下的文件已经被拷贝到disk的目录了
这就是我们通过在导出函数中对环境进行判断
从而去实现为不同的环境导出不同的配置
当然你也可以直接在全局去判断环境面量
然后直接导出不同的配置
这样也是可以的
(字幕由Amara.org社区提供)
(字幕由Amara.org社区提供)

#### Webpack  不同环境的配置文件

通过判断环境名参数去返回不同的配置对象
这种方式只适用于中小型项目
因为一旦项目变得复杂
那我们的配置文件也会一起变得复杂起来
所以说对于大型的项目
我们还是建议大家使用不同环境去对应不同配置文件的方式来实现
一般在这种方式下面
我们项目当中至少会有三个Webpack配置文件
其中两个是用来适配不同的环境的
另外一个是一个公共的配置
因为我们的开发环境和生产环境
并不是所有的配置都完全不同
所以说我们需要一个公共的文件来去抽象两者之间相同的配置
那么具体来看
首先我们先在项目的根部落下去新建一个Webpack.common.js
在这个文件当中我们把刚刚复制的公共配置粘贴进来
然后我们再去新建一个Webpack.dev.js和一个Webpack.prod.js
分别去用来为我们的开发和生产环境去定义特殊的配置
在生产环境的配置当中我们先去导入公共的配置对象
然后这里我们可以使用object-assign的方法
把我们公共配置对象复制到我们这里的配置对象当中
并且我们可以通过最后一个对象去覆盖掉公共配置当中的一些配置
但是熟悉object-assign的方法的人都应该知道
这个方法它是完全覆盖掉前一个对象当中的同名属性
这样一个特点对于我们普通的直类型的属性覆盖它都没有什么问题
但是像我们配置当中的plugins这种数组
我们是希望是可以在公共配置的原有基础之上
我们去添加一两个插件
而object-assign这个方法它会导致我们这里的特殊配置会覆盖掉公共配置
所以说object-assign是不合适的
这里我们就需要一个更合适的方法来去合并我们这里的配置和公共的配置
你可以使用loadash所提供的merge方法来去实现
不过社区当中提供了更为专业的Webpack Merge这样一个模块
这个模块它可以专门用来满足我们这里合并Webpack配置的这样一个需求
我们打开命令行中端
然后通过YAR去安装一下Webpack-merge这样一个模块到我们的开发依赖当中
安装完成过后我们回到配置文件当中
这里我们先去载入这个模块
这个模块它导出的就是一个merge函数
我们这使用这个函数来去合并我们这里的配置和公共的配置
使用Webpack-merge这个模块过后
我们这里所配置的对象它就可以跟普通的Webpack配置一样
你需要什么就配置什么
merge函数内部会自动去处理合并的逻辑
同理Webpack-dv.js这样一个配置文件当中
也可以通过这种方式来去实现一些额外的配置
这里我就不再重复去尝试了
完成过后我们再次回到命令行中端
然后尝试运行Webpack-dv.js
不过这里因为我们已经没有了默认的配置文件
所以说我们这运行Webpack-dv.js时
我们需要通过--config这样一个参数来去指定我们所使用的配置文件
就是我们刚刚的Webpack.product.js
回车
此时我们就可以以生产环境这种模式的配置去打包我们的应用了
当然如果说你觉得这样去使用的话
我们的命令变得复杂了
你同样可以把构建的命令定义到npm scripts当中
方便我们的使用
[音乐]
[音乐]

#### Webpack  DefinePlugin

在WiFi4中新增的Production模式下面
内部就自动开启了很多通用的优化功能
对于使用者而言
这种开箱即用的体验是非常方便的
但是对于学习者而言
这种开箱即用
它会导致我们忽略掉很多需要了解的东西
以至于我们出现问题过后无从下手
如果说我们需要深入了解WiPAC的使用
我建议你可以去单独研究一下每一个配置背后的作用
我们这里先一起来学习其中几个主要的优化配置
顺便去了解一下WiPAC是如何去优化我们的打包结果的
首先第一个是一个插件叫做Define Plugin
Define Plugin是用来为我们的代码去注入全局成员的
在Production模式下
默认这个插件它就会启用起来
并且往我们的代码当中注入了一个process.env.node
像env的这样一个算是一个常量吧
很多第三方的模块都是通过这个成员去判断当前的运行环境
从而去决定是否去执行例如打印日志这样的一些操作
这里我们先来单独使用一下这个插件
我们回到配置文件当中
Define Plugin它是一个内置的插件
所以说我们先要导入WiPAC模块
然后我们再到Plugins这个数组当中去添加一个插件
这个插件它的构造函数接收的是一个对象
这个对象中每一个建值都会被注入到我们的代码当中
那例如我们这里在这个对象当中去定义一个
API_BASE_URL的这样一个值
用来为我们的代码去注入我们的API服务地址
那它的值是一个字符串
我们这儿就使用https://api.example.com
然后我们回到我们的代码当中
简单的来把这个API_BASE_URL打印出来
那完成以后我们打开命令行终端
然后运行WiPAC打包
那打包过后我们找到我们的打包结果
然后去找到刚刚的这个Mendir.js所对应的模块函数
那这里我们发现Define Plugin
它其实就是把我们注入成员的值直接替换到了代码当中
而我们刚刚设置的这个值
内容就是https://api.example.com这样一个字符串
那字符串中并没有包含引号
所以说我们这儿替换进来
它是没有引号的
那语法上就自然会有问题
那其实Define Plugin的设计
它并不是只是用来帮我们替换一个数据进来
我们这儿所传递的字符串内容
它要求的实际上是一个代码片段
也就是一段符合JS语法的代码
所以说我们这样去传的话是不对的
那正确的做法是传入一个字符串
这个字符串的内容就是一个我们JS代码当中的字符串字面量语句
当然了如果说你需要注入其他的代码
其实也是可以的
那完成以后我们再来尝试重新打包
那此时我们的打包结果就已经变成了我们想要的样子了
那另外这里还有一个非常常用的小技巧
就是如果说我们需要注入的是一个值的话
那我们可以先通过JSON StreamFile的方式
来去将这个值去转换成一个表示这个值的代码片段
那这样的话就不容易错了
那这个插件的作用非常简单
但是它却非常有用
那我们可以用它为我们的代码去注入一些可能会发生变化的值
例如我们刚刚使用的这种API的跟路径
那我们在开发环境跟生产环境
它的路径肯定是不一样的
那么就可以借助于Define Plugin去注入我们想要的API Base URL
谢谢大家
(字幕由Alias "J" 提供)
(字幕由Alias "J" 提供)

#### Webpack  体验Tree Shaking

Tree Shacking
字面意思就是摇树
一般伴随着摇树这样一个动作
我们树上的这些枯树枝和树叶就会掉落下来
我们这里要说的Tree Shacking
它也是相同的道理
不过我们这儿摇掉的是我们代码当中那些没有用到的部分
这部分代码更专业的说法叫做未引用代码
也就是Dead Code
WipeEgg生产模式优化中就有这么一个非常有用的功能
它可以自动检测出我们代码中那些未引用的代码
然后移除掉它们
我们这里先来体验一下这样一个功能的效果
我们这里的代码也非常简单
只有两个文件
其中Components.js这样一个文件当中
它导出了一些函数
然后每一个函数分别模拟了一个组件
其中Button组件函数中
在return过后还执行了一个console.log语句
很明显这就属于未引用代码
除此之外还有一个index文件
这个index文件当中就是导入了Components
但是需要注意的是
我们这儿只是导入了Components当中的Button这样一个成员
这也就会导致我们代码当中
特别是Components里面
它会有很多的地方都用不到
这些用不到的地方对于我们打包过后的结果就是冗余的
去除冗余代码是我们生产环境优化当中非常重要的一个工作
而Webpack的Tree Shocking就很好的实现了这样一点
我们这打开mini行中端
然后这里我们尝试以production模式去运行打包
打包完成过后我们去打开输出的bounder.js
这里我们一起来看一看这些冗余的代码到底有没有输出
我们设置一下自动换行
然后我们可以搜索一下刚刚我们代码当中的Console.log
以及那些没有使用到的组件函数
这时候通过搜索你会发现
我们刚刚这些未引用的代码它根本就没有输出
这就是Tree Shocking这样一个特性工作过后的一个效果
Tree Shocking这个功能它会在生产模式下自动去开启
我们下期再见
拜拜
(字幕:Sara)
(字幕:Sara)

#### Webpack 使用Tree Shaking

需要注意的是Tree Shacking它并不是Webpack中的某一个配置选项
它是一组功能搭配使用过后的一个效果
这组功能会在生产模式下自动启用
但是由于目前官方文档当中对于Tree Shacking的介绍有点混乱
所以说我们这儿再来介绍一下它在其他模式下
如何一步一步手动的去开启
顺便通过这样一个过程我们去了解Tree Shacking的工作过程
以及一些其他的优化功能
这里我们还是与刚刚相同的一个项目
然后我们再次回到命令行终端
运行Webpack打包
不过这一次我们不再使用Production模式
而是使用None
也就是我们不开启任何内置功能和插件
打包完成过后我们再次找到输出的Bounder.js这样一个文件
这里的打包结果跟我们之前所看到的是一样的
也就是我们一个模块会对应这里的一个函数
这里我们需要注意看一下Components.js这样一个模块所对应的函数
这里的Link函数和Heading函数虽然外部并没有使用
但是我们这仍然是导出了
很明显这些导出是没有意义的
我们这可以借助一些优化功能把它们去掉
我们这打开Webpack的配置文件
这里我们在配置文件当中去添加一个Optimization的属性
这个属性就是集中去配置Webpack内部的一些优化功能的
在这个属性当中我们可以先开启一个叫做Use the X-Pulse选项
表示我们在输出结果中只导出那些外部使用了的成员
完成过后我们回到命令行重新运行打包
打包过后我们再来看一下输出的Bounder.js
此时你就会发现Components模块所对应的函数中
就不再会去导出Link和Heading这两个函数了
而且我们的VSCode也非常友好的将这两个函数的字体变淡
表示它们未被使用
此时我们就可以去开启Webpack的代码压缩功能
去压缩掉这些没有用到的代码
我们再回到配置文件当中
这里我们在Optimization属性当中去开启Minimize
然后我们回到命令行再次重新打包
此时我们Bounder.js当中
这些未引用的代码就都被移除掉了
这就是Tree Sharking的实现
整个过程我们用到了两个优化功能
一个是Use the X-Pulse
另外一个是Minimize
如果说要是真把我们的代码看作一棵大树的话
那你可以理解成我们Use the X-Pulse
就是用来在这个大树上标记哪些是枯树叶枯树枝
然后Minimize就是负责把这些枯树叶树枝全部摇下来
这就是我们的效果
(字幕由Amara.org社区提供)
(字幕由Amara.org社区提供)

#### Webpack 合并模块

除了 use the X-Pulse UI
我们还可以使用一个
Concatenate Modules 属性
去继续优化我们的输出
那普通的打包结果呢
它是将我们的每一个模块
最终放在一个单独的函数当中
那这样的话如果我们的模块很多
也就意味着我们在输出结果中
会有很多这样的模块函数
那我们回到配置文件当中
这里开启Concatenate Modules
为了可以更好的看到效果
我们这儿先去关闭掉minimize
然后我们回到命令行中端
重新运行打包
那此时我们bounder.js当中
就不再是一个模块对应一个函数了
而是把所有的模块
都放到了同一个函数当中
那Concatenate Modules这样一个配置的作用
就是尽可能将所有的模块
全部合并到一起
然后输出到一个函数中
那这样的话既提升了运行效率
又减少了我们输出代码的体积
那这个特性又被称之为Scope Hosting
也就是作用域提升
那它是WipeX3当中去添加的一个特性
那如果说此时我们再去配合minimize
那这样的话我们的代码体积
就会又减小很多
(字幕:Sky Vision Media)
(字幕:Sky Vision Media)
(字幕:Sky Vision Media)

#### Webpack Tree Shaking 与 Babel

由于早期WPAC发展非常快
变化也就会比较多
所以当我们去找资料时
我们得到的结果
并不一定适用于我们当前所使用的版本
对于Tree Shacking的资料更是如此
很多资料中都表示
如果我们使用了Babel Loader
就会导致Tree Shacking失效
针对于这个问题
这里我们来统一说明一下
首先,大家需要明确一点的是
Tree Shacking的实现
它的前提就是必须要使用ES Module去组织我们的代码
也就是说我们交给WPAC去处理的代码
它必须还是使用ES Module的方式来实现模块化
那为什么这么说呢?
我们都应该知道
WPAC在打包所有模块之前
它先是将模块根据配置交给不同的Loader去处理
最后再将所有Loader处理过后的结果打包到一起
那么为了转换我们代码当中Ekma Script的新特性
很多时候我们都会选择Babel Loader去处理我们的JS
而在Babel转换我们的代码时
就有可能处理掉我们代码当中ES Module
把它们转换成CommonJS
当然了,这取决于我们有没有使用转换ES Module的插件
那例如在我们这个项目当中
我们所使用的precedeenv这个插件集合
它里面就有这么个插件
所以说,当precedeenv这个插件集合工作的时候
我们代码当中ES Module的部分
就应该会被它转换成CommonJS的方式
那WPAC在去打包时
它拿到的代码就是以CommonJS的方式组织的代码
所以说Tree Shacking就不能生效
那这里我们具体来尝试一下
那需要注意,我们这儿为了可以更容易分辨结果
我们只开启Use the X-Pulse
然后我们打开命令行中端,运行WPAC命令
运行完WPAC过后
我们找到所生成的Bounder.js
那这里你会发现
我们的结果并不是像刚刚说的那样
这里Use the X-Pulse功能正常的工作了
那这也就说明如果说我们开启压缩代码的话
那这些未引用的代码依然会被移除
那Tree Shacking并没有失效
那这是因为在最新版本的Babel Loader当中
就已经自动帮我们关闭了ES Module转换的插件
那我们可以在Node下线Modules当中
先去找到Babel-Loader的模块
我们可以看一下它的原代码
那它在InjectColor这个文件当中就已经标识了
我们当前这个环境是支持ES Module
然后我们再去找到我们所使用的PrecedeENV这个模块
那在这个模块当中我们可能需要翻一下它的代码
那找到200多行这个位置
那这里它根据我们刚刚的这个标识
自动禁用了ES Module的转换
所以说Webpack最终打包时
它得到的还是ES Module代码
那Tree Shacking自然也就可以正常工作了
当然了我们这只是定位的找到了原代码当中相关的一些信息
如果说你需要仔细了解这个东西的话
那你可以再去翻看一下Babel的原代码
那我们这里也可以尝试在Babel的Precede配置当中
强制去开启这个插件来去试一下
不过给Precede添加配置的方式比较特别
很多人都容易配错
所以一定要注意
那它需要把我们预设这个数组当中的成员再次定义成一个数组
然后我们这个数组当中的第一个成员
就是我们所使用的Precede的名称
第二个成员就是我们给这个Precede所定义的配置对象
这一定不能搞错了
是一个数组套数组
那我们这将这个配置对象当中的Modules属性设置为CommonJS
那默认这个属性的值是Auto
也就是根据环境去判断是否开启ES Module插件
那我们这将它设置为CommonJS
也就表示我们需要强制使用Babel的ES Module插件
把我们代码当中的ES Module转换成CommonJS
那完成以后我们再次打开命行终端
然后运行Webpack打包
那打包完成过后
我们再找到Bounder.js
那此时你就会发现
我们刚刚所配置的use的Xbox就没有办法生效了
那即便我们再去开启压缩代码
那Tree Sharking也是没有办法正常工作的
那总结一下
我们这里通过实验发现
最新版本的Babel Loader
它并不会导致Tree Sharking失效
那如果说你不确定
那最简单的办法就是在配置文件当中
将PreciseENV当中的Modules属性设置为first
这样的话就确保我们这个PreciseENV
它里面不会再去开启ES Module转换的插件
那这样就同时确保了我们Tree Sharking的一个工作的前提
那另外呢
我们刚刚这样一个探索的过程
也值得你仔细再去琢磨一下
因为通过这样的探索
你能够了解到很多知其所以然的内容
(字幕由Amara.org社区提供)
(字幕由Amara.org社区提供)

####  Webpack ideEffect

Webpack 4 中还新增了一个叫做 Side Effects 的新特性
它允许我们通过配置的方式去标识我们的代码是否有副作用
从而为 Tree Shacking 提供更大的压缩空间
副作用是指模块执行的时候
除了导出成员是否还做了一些其他的事情
这样一个特性一般只有我们在开发一个 npm 模块时才会用到
但是因为官网当中把 Side Effects 的介绍跟 Tree Shacking 混到了一起
所以很多人误认为它俩是因果关系
其实它俩真的没有那么大的关系
我们这儿先把 Side Effects 闹明白
你就能理解为什么了
这里我先设计一个能够让 Side Effects 发挥效果的一个场景
我们基于刚刚的案例基础之上
我们把 Components 拆分出了多个组件文件
然后在 index.js 当中我们集中导出便于外界导入
这是一种非常常见的同类文件组织方式
我们再回到 Rook 文件当中导入 Components 中的 Button 成员
这样就会出现一个问题
因为我们在这儿载入的是 Components 目录下的 index
index 当中又载入了所有的组件模块
这就会导致我们只想载入 Button 组件
但是所有的组件模块都会被夹载执行
我们打开命令行中端,尝试运行打包
打包完成过后,我们找到打包结果
此时你会发现,所有组件的模块
确实都被打包进了 Bounder.js
SideFX 的特性就可以用来解决此类问题
我们可以打开 YPEG 的配装件
然后在 Optimization 属性当中开启这个属性
注意这个特性在 Production 模式下同样也会自动开启
开启这个特性过后,YPEG 在打包时
它就会先检查当前代码所属的 package.json 当中
有没有 SideFX 的标识
以此来判断这个模块是否有副作用
如果说这个模块没有副作用
那这些没有用到的模块就不再会打包
我们可以打开 package.json
然后尝试去添加一个 SideFX 的字段
我们把它设置为 First
这样就标识当前 package.json 所影响的项目
当中所有的代码都没有副作用
一旦这些没有用到的模块没有副作用了
它就会被移除掉
完成以后,我们再打开命令行中端
然后再次运行打包
打包过后,我们同样找到打包输出的
bundle.js 这样一个文件
此时,我们那些没有用到的模块
就不再会被打包进来了
这就是 SideFX 的作用
注意我们这里设置了两个地方
我们先在 YPEG 的配置当中开启的 SideFX
它是用来开启这个功能
而在 package.json 当中
我们添加的 SideFX 它是用来标识我们的代码是没有副作用的
它俩是不是一个意思,不要弄混了
(字幕由 Amara.org 社区提供)
(字幕由 Amara.org 社区提供)

####  Webpack ideEffect注意

使用Satisfacts功能的前提就是
确定你的代码没有副作用
否则的话
在Webpack 打包时就会误删掉那些有副作用的代码
例如我们这儿所准备的一个extend.js这样一个文件
在这个文件当中我们并没有向外导出任何成员
它仅仅是在number这个对象的原型上挂载了一个PET方法
用来为数字去添加前面的导龄
这是一种非常常见的基于原型的扩展方法
我们再回到index.js当中我们去导入这个extend
因为这个模块确实没有导出任何成员
所以我们这儿也就不需要去提取任何成员
只不过我们导入这个模块过后
我们就可以使用它为number所提供的扩展方法了
这里为number做扩展的这样一个操作
就属于我们extend这个模块的副作用
因为在导入了这个模块过后
我们的number的原型上就会多一个方法
这就是副作用
此时如果说我们还标示我们的项目当中
所有的代码都没有副作用的话
我们再次回到命令行运行打包
打包过后我们找到打包结果
这个时候我们就会发现
我们刚刚的扩展的操作
它是不会被打包进来的
因为它是副作用代码
但是你在你的配置当中已经声明了你没有副作用
所以说它们就被移除掉了
除此之外还有我们在代码当中载入的css模块
它也都属于副作用模块
同样会面临刚刚这样一种问题
解决的办法就是在我们packager.json当中去关掉副作用
或者是什么呢
或者是标识一下我们当前这个项目当中
哪些文件是有副作用的
这样的话
webpack就不会去忽略这些有副作用的模块了
我们可以打开packager.json
我们这儿把first改成一个数组
然后我们再去添加一下extend文件的路径
还有我们global.css的文件路径
当然了这里我们也可以使用路径通配符的方式来去配置
完成以后我们再次打开明长终端运行打包
此时我们再找到打包结果
我们发现有副作用的两个模块也会被同时打包进来了
以上就是我们对webpack内置的一些优化属性的一些介绍
总之这些特性
它都是为了弥补JavaScript早期在设计上的一些遗留问题
随着像webpack这一类的技术的发展
JavaScript确实越来越好
谢谢大家
(字幕由Amara.org社区提供)

####  Webpack 代码分割

通过WipeEk实现前端项目整体模块化的优势
固然很明显
但是它同样存在一些弊端
那就是我们项目当中所有的代码最终都会被打包到一起
那试想一下
如果说我们的应用非常复杂
模块非常多的话
那我们的打包结果就会特别的大
那很多时候超过两三兆也是非常常见的事情
而事实情况是
大多数时候我们在应用开始工作时
并不是我们所有的模块都是必须要加载进来的
但是这些模块又被全部打包到一起
那我们需要任何一个模块
都必须得把整体加载下来过后才能使用
而我们的应用一般又是运行在浏览器端
那这就意味着我们会浪费掉很多的流量和带宽
那更为合理的方案就是把我们的打包结果
按照一定的规则去分离到多个Bundle当中
然后根据我们应用的运行需要
按需去加载这些模块
这样的话我们就可以大大提高我们应用的响应速度
以及它的运行效率
那可能有人会想起来我们在一开始的时候说过
Vipack就是把我们项目中散落的那些模块合并到一起
从而去提高运行效率
那我们这里又在说它应该把它分离开
那这两个说法是不是自相矛盾呢?
其实这并不是矛盾
只是物极必反而已
那资源太大了也不行
太碎了更不行
我们项目中划分的这种模块的颗粒度一般都会非常的细
那很多时候我们一个模块只是提供了一个小小的工具函数
它并不能形成一个完整的功能单元
那如果我们不把这些散落的模块合并到一起
那就有可能我们在去运行一个小小的功能时
就会加载非常多的模块
而我们目前所主流的这种HTTP协议的1.1版本
它本身就有很多缺陷
例如我们并不能同时对同一个域名下发起很多次的并行请求
而且我们每一次请求它都会有一定的延迟
另外我们每次请求除了传输具体的内容以外
还会有额外的请求头和响应头
那当我们有大量的这种请求的情况下
那这些请求头响应头加在一起也是很大的浪费
那综上所述
模块打包肯定是有必要的
不过在我们的应用越来越大过后
我们要开始慢慢的学会变通
那为了解决这样的问题
Webpack它支持一种分包的功能
那你也可以把这种功能称之为代码分割
那它通过把我们的模块按照我们所设计的一个规则
打包到不同的Bundle当中
从而去提高我们应用的响应速度
目前Webpack去实现分包的方式主要有两种
那第一种就是我们根据我们的业务去配置不同的打包入口
也就是我们会有同时多个打包入口
同时打包
那这时候就会输出多个打包结果
那第二种就是采用ESModule的动态导入这样一个功能
去实现模块的按需加载
那这个时候我们Webpack它也会自动的把我们动态导入的模块
单独输出到一个Bundle当中
那接下来我们来具体来看这两种方式
(音乐播放)
(音乐播放)
(音乐播放)

####  Webpack 多入口打包	

多入口打包一般适用于传统的多页应用程序，最常见的划分规则就是一个页面去对应一个打包入口，对于不同页面之间公共的部分再去提取到公共的结果当中，这种方式使用起来非常简单。
多页应用的示例: 在这里我会有两个页面分别是index和album的页面，代码的组织逻辑也非常简单，index.js负责实现index页面上所有的功能，而album.js负责实现相册页面的所有功能，global.css是公共的样式，然后fetch.js是一个公共的模块，它负责用来去提供请求API的一个方法
这里我们去尝试为这个案例去配置多个打包入口，我们回到配置文件当中，一般我们配置文件当中的entry属性
它只会配置一个文件路径
也就是说我们只会配置一个打包入口
如果我们需要配置多个入口的话
我们可以把entry定义成一个对象
需要注意这里定义的是一个对象而不是数组
因为如果说是定义成数组的话
它就是把多个文件打包到一起
对于整个应用来讲的话还是一个入口
我们这里需要的是多入口
所以说我们配置成一个对象
在这个对象当中一个属性就是我们打包的一路入口
我们属性名就是这个入口的名称
然后值就是这个入口所对应的文件路径
我们这里配置的就是index和album
这两个js所对应的文件路径
一旦我们这里配置为多入口
我们输出的文件名也需要修改
因为这里两个入口就会意味着有两个打包结果
我们不能都叫bundler.js
所以说我们这儿可以为我们的filename属性
去添加一个方块糊name这种占位符的方式
来去动态输出文件名
那方块糊name最终就会被替换成入口的名称
在我们这儿就是index和album
完成以后我们就可以打开命令行中端
然后运行wipack打包
此时我们这一次打包就会有两个入口
完成以后我们找到输出的目录
在输出的目录当中我们就能看到两个入口各自打包过后的结果了
但是这里还是会有一个小问题
我们打开任意一个输出的html文件
这时候你就会发现
这两个打包结果都被页面同时载入了
而我们希望的是一个页面只使用它对应的输出结果
所以说这里我们还需要继续去修改配置文件
我们回到配置文件当中
我们找到输出html的插件
之前我们就介绍过
这个插件它默认就会输出一个
自动注入所有打包结果的html
如果说我们需要去指定我们所输出的html
它所使用的bounder
我们就可以使用tranks属性来去设置
那我们每一个打包入口它就会形成一个独立的trank
那我们在这分别为这两个页面配置不同的trank
完成以后我们再次回到命令行中端
然后运行打包
那此时我们这次的打包结果它就完全正常了
那以上就是我们配置多入口的打包方式
以及我们如何在输出的html当中
指定我们需要注入的bounder


#### Webpack 提取公共模块

多入口打包本身非常容易理解
也非常容易使用
但是它也存在一个小小的问题
那就是我们在不同的打包入口当中
它一定会有那么一些公共的部分
那按照目前这种多入口的打包方式
就会出现我们在不同的打包结果当中
会有相同的模块出现
那例如在我们这里
index入口和album入口当中
就共同使用了global.css和fetch.js
这两个公共的模块
那这里是因为我们的示例比较简单
所以说重复的影响不会有那么大
但是如果说我们共同使用的是
jQuery或者是view这种体积比较大的模块
那影响的话就会特别的大
所以说我们需要把这些公共的模块
去提取到一个单独的bounder当中
那Webpack中实现公共模块提取的方式
也非常简单
我们只需要在优化配置当中
去开启一个叫split_trunks的
一个功能就可以了
那我们回到配置文件当中
那这里我们先添加optimization属性
然后我们在这个属性当中
去添加split_trunks属性
那这个属性它需要我们配置一个trunks属性
然后我们将这个trunks属性设置为all
那就表示我们会把所有的公共模块
都提取到单独的bounder当中
那完成以后我们再次打开命令行中端
然后运行Webpack打包
那此时我们的disk目录下
就会生成额外的一个js文件
那在这个文件当中
就是我们index和album
这两个入口公共的模块部分了
那我们就在这里完成了
我们的disk目录
然后运行Webpack打包
然后运行Webpack打包
然后运行Webpack打包

#### Webpack 动态导入

按需加载是我们开发浏览器应用当中一个非常常见的需求
一般我们常说的按需加载指的是加载数据
我们这里所说的按需加载
指的是我们在应用运行过程中
需要某个模块时我们才去加载这个模块
这种方式可以极大的节省我们的带宽和流量
那WiPAC中支持使用动态导入的这种方式来去实现模块的按需加载
而且所有动态导入的模块都会被自动提取到单独的bundle当中
从而实现分包
那相比于多入口的这种方式
动态导入它更为灵活
因为我们可以通过代码的逻辑去控制
我们需不需要加载某个模块
或者是我们什么时候加载某个模块
而我们分包的目的中就有很重要的一点
就是要让模块实现按需加载
从而去提高应用的响应速度
那么具体来看如何使用
这里我已经提前设计好了一个可以发挥按需加载作用的场景
那在这个页面的主体区域
如果我们访问的是文章页的话
那我们得到的就是一个文章列表
那如果我们访问的是相册页
那我们显示的就是相册列表
那回到代码当中我们来看它的实现方式
那目前我们文章列表所对应的就是Post的组件
而相册列表对应的就是Album组件
那我们在打包入口当中同时导入了这两个模块
然后这里的逻辑就是当我们的锚点发生变化时
我们去根据锚点的值决定要去显示哪个组件
那这里就会存在浪费的可能性
那试想一下如果说用户打开我们的应用过后
只是访问了其中的一个页面
那另外一个页面所对应的组件的加载就是浪费
所以说我们这儿如果是动态导入组件
那就不会存在浪费的问题了
那我们这儿可以先注视掉这种静态导入
那动态导入它使用的就是ES Module标准当中的动态导入
我们在需要动态导入组件的地方通过input这个函数
然后导入我们指定的路径
那这个方法它返回的就是一个Parameter
然后在这个Parameter的Zen方法当中
我们就可以拿到模块对象
那由于我们这儿是使用的默认导出
所以说我们这儿需要去解构我们模块对象当中的default
然后我们把它放到Post这个变量当中
那拿到这个成员过后
我们再来去使用这个成员去创建界面上的元素
那同理我们的AirBump组件它也应该是如此
我们这儿快速来去复制一个AirBump组件的动态导入实现
那完成以后我们再次回到浏览器
那此时我们的页面是仍然可以正常工作的
那这个时候我们再回到开发工具当中
然后重新去运行打包
然后去看看此时我们打包的结果是什么样子的
我们这打开命令行中端
结束掉WipeActiveServer
然后我们去运行WipeActive打包
那打包完成过后我们去打开输出的Dist目录
在此时我们的Dist目录下就会多出三个JS文件
那这三个JS文件实际上就是由动态导入自动分包所产生的
那这三个文件分别是我们刚刚导入的两个模块
以及这两个模块当中公共的部分所提取出来的bundle
那这就是动态导入在WipeActive当中的一个使用
那整个过程我们无需配置任何一个地方
只需要按照ES module动态导入成员的方式
去导入模块就可以了
那WipeActive内部会自动处理分包和按需加载
那如果说你使用的是单页应用开发框架
比如React或是View的话
那在你项目当中的路由映射组件
就可以通过这种动态导入的方式实现按需加载
那这就是WipeActive的功能了
那我们就来看一下
WipeActive的功能是什么样子的

#### Webpack 魔法注释

默认通过动态导入产生的bounder文件
它的名称就只是一个序号
这并没有什么不好的
因为在生产环境当中
大多数时候我们是根本不用关心资源文件的名称是什么
但是如果说你还是需要给这些bounder命名的话
那你可以使用WipeX所特有的魔法注释来去实现
具体的使用方式就是在调用input函数的参数位置
我们去添加一个行内注释
这个注释有一个特定的格式
就是通过WipeX,chunk name,冒号
后面跟上一个名称
这样的话我们就可以给分包所产生的bounder起上名字了
我们再次打开命令行中端
然后运行WipeX打包
此时我们所生成的bounder文件
它的name就会使用我们刚刚注释当中所提供的名称了
如果说你的chunk name是相同的话
相同的chunk name最终就会被打包到一起
例如我们这里可以把这两个chunk的chunk name设置为components
这样的话它们就一致了
然后我们再次运行打包
此时这两个模块都会被打包到components.js这样一个文件当中
借助于这样一个特点
你就可以根据自己的实际情况
灵活组织我们动态加载的模块所输出的文件了
(字幕由Amara.org社区提供)

#### Webpack MiniCextractPlugin

Mini CSS Extract Plugin
它是一个可以将CSS代码从打包结果中提取出来的插件
通过这个插件我们就可以实现CSS模块的按需加载
它的使用也非常简单
我们回到项目当中
这里我们先通过YARN去安装一下这个插件
安装完成后,我们打开WipeHack的配置文件
这里我们需要先导入这个插件的模块
导入过后,我们就可以将这个插件
添加到配置对象的Plugins设组当中
这样的话,Mini CSS Extract Plugin
它在工作时就会自动提取我们代码当中的CSS
到一个单独的文件当中
除此以外,目前我们所使用的样式模块
它是先交给CSS Loader去解析
然后再交给Style Loader去处理
这里的Style Loader它的作用
就是将我们的样式代码通过Style标签的方式
注入到页面当中
从而使样式可以工作
使用Mini CSS Extract Plugin的话
我们的样式就会单独存放到文件当中
也就不需要Style标签
而是直接通过Link的方式去引入
所以说这里我们就不再需要Style Loader了
取而代之,我们使用的是Mini CSS Extract Plugin
当中所提供的一个Loader
来去实现我们样式文件
通过Link标签的方式去注入
完成以后,我们回到Mini行中端
再次运行Webpack打包
打包完成过后
我们就可以在Dist目录当中
看到提取出来的样式文件了
不过这里我们需要注意一点
如果说你的样式文件
它的体积不是很大的话
提取到单个文件当中
效果可能适得其反
我个人的经验是
如果说CSS超过了150KB左右
才需要考虑是否将它提取到单独文件当中
否则的话
其实CSS嵌入到代码当中
它减少一次请求
效果可能会更好
谢谢大家
谢谢大家
谢谢大家
谢谢大家
谢谢大家
谢谢大家

#### Webpack OptimizeCAetWebpackPlugin

使用了mini-css-extract plugin过后
样式文件就可以被提取到单独的css文件当中了
但是这里同样有一个小问题
我们回到命令行
这里我们尝试以生产模式去运行打包
按照之前的了解
在生产模式下
WiFi会自动压缩输出的结果
这里打开输出的样式文件
这里你会发现
我们样式文件根本没有任何的变化
这是因为WiPAC内置的压缩插件
仅仅是针对JS文件的压缩
对于其他的资源文件压缩
都需要额外的插件来支持
WiPAC官方推荐了一个
Optimize CSS Assess WiPAC plugin
我们可以使用这个插件来压缩我们的样式文件
我们回到命令行终端
这里我们先来安装一下这个插件
安装完成过后
我们就可以回到配置文件当中
这里我们同样需要先去导入这个插件
导入完成过后
我们去把这个插件
添加到配置对象的plugins数组当中
此时我们再次回到命令行终端
重新运行打包
这次打包完成过后
我们的样式文件就可以以压缩文件的格式去输出了
不过这里还有一个额外的小点
可能大家在官方文档当中会发现
文档当中这个插件
并不是配置在plugins数组当中的
而是添加到了optimization属性当中的
minimizer属性当中
这是为什么呢?
其实也非常简单
如果说我们把这个插件
配置到plugins数组当中
这个插件在任何情况下都会正常工作
而配置到minimizer数组当中的话
只会在minimize这样一个特性开启时才会工作
所以说Webpack建议
像这种压缩类的插件
我们应该配置到minimizer数组当中
以便于我们可以通过minimize这个选项去统一控制
这里我们尝试把这个插件
移至到我们的optimization属性的minimizer数组当中
然后我们再次运行打包
此时如果说我们没有开启压缩这个功能的话
这个插件就不会工作
反之如果说我们以生产模式打包
minimize的属性就会自动开启
这个压缩插件就会自动工作
那样式文件也就会被压缩
但是这么配置也有一个小小的缺点
我们可以来看一眼输出的JS文件
这时候你会发现原本可以自动压缩的JS
这一次却不能自动压缩了
这是因为我们这设置了minimizer这个数组
Webpack认为如果我们配置了这个数组
那就是要去自定义所使用的压缩器插件
内部的JS压缩器就会被覆盖掉
所以我们这需要手动再去把它添加回来
内置的JS压缩插件叫做Tertial Webpack Plugin
那我们回到命令行
然后来手动安装一下这个模块
那安装完成过后呢
我们这里再来把这个插件手动的去添加到minimizer这个数组当中
那这样的话
如果我们再以生产模式运行打包
然后呢JS文件CSS文件都可以正常被压缩了
那如果说我们以普通模式打包
也就是不开启压缩的话
那它也就不会以压缩的形式输出了
那我们就先来看一下这个模块的使用性
那我们先来看一下这个模块的使用性
那我们先来看一下这个模块的使用性
那我们先来看一下这个模块的使用性

#### Webpack 输出文件名Hash

一般我们去部署前端的资源文件时
都会启用服务器的静态资源缓存
这样的话对于用户的浏览器而言
它就可以缓存住我们应用当中的静态资源
后续就不再需要请求服务器
得到这些静态资源文件了
这样整体我们应用的响应速度
就有一个大幅度的提升
不过开启静态资源的客户端缓存
它也会有一些小小的问题
如果说我们在缓存策略当中
我们的缓存失效时间设置的过短的话
效果就不是特别明显
如果说我们把过期时间设置的比较长
一旦说我们在这个过程当中应用发生了更新
重新部署过后
又没有办法及时更新到客户端
为了解决这么一个问题
我们建议在生产模式下
我们需要给输出的文件名当中添加哈希值
这样的话一旦我们的资源文件发生改变
我们的文件名称也可以跟着一起去变化
对于客户端而言
全新的文件名就是全新的请求
那也就没有缓存的问题
这样的话我们就可以把服务端的缓存策略
当中的时间设置的非常长
也就不用担心文件更新过后的问题
Webpack中的Filename属性
和绝大多数插件的Filename属性
都支持通过占位符的方式
来去为文件名设置哈希
不过他们支持三种哈希
效果各不相同
这里我们分别来尝试一下
首先就是最普通的哈希
我们可以通过方块糊哈希
然后去拿到
这个哈希它实际上是整个项目级别的
也就是说一旦项目当中
有任何一个地方发生改动
那我们这一次打包过程当中的
哈希值都会发生变化
我们这可以在任意一个代码当中
做一些修改
然后尝试重新打包
此时你就会发现
我们的哈希值全部发生变化了
其次是Chunk哈希
这个哈希是Chunk级别的
也就是在我们打包过程当中
只要是同一路的打包
Chunk哈希它都是相同的
我们这里虽然只配置了一个打包入口
但是在我们的代码当中
通过动态导入的方式
又分别形成了两路Chunk
分别是Post和Album
样式文件是从代码当中
单独提取出来的
所以说它并不是单独的Chunk
所以我们这所看到的结果
就是Main和Post还有Album
它们三者Chunk哈希各不相同
而我们CSS文件和所对应的JS文件
它的Chunk哈希是一样的
因为它们是同一路
这里我们先在Index当中
尝试做一些修改
然后重新打包
此时你会发现
只有MainBinder的文件名发生了变化
其他的文件都没有变
然后我们再来尝试
在Post.js当中做一些修改
此次我们Post所输出的JS和CSS
都会发生变化
因为我们刚刚说过了
它们是属于同一个Chunk
至于MainBinder
它也会发生变化的原因
是因为我们Post所生成的JS文件
和CSS文件
它的文件名发生变化
我们在入口文件当中
去引入它们的路径
也会发生变化
所以说MainChunk
它算是一个被动的改变
相比于普通的Hash
Chunk Hash的控制
它要更精确一点
最后还有一个Content Hash
这个Hash
它实际上是文件级别的哈希
它实际上是根据输出文件的内容
生成的哈希值
也就是说只要是不同的文件
它就有不同的哈希值
这里我们先尝试在index当中做一些修改
然后重新打包
此时同样只有MainBinder的文件名发生了变化
然后我们再去修改一下Post.CSS
这个时候你会发现
Post所对应的样式文件名
就发生了变化
而MainBinder它同样也是因为路径的原因
才被动更新
相比于前两者
Chunk Hash它应该算是
解决缓存问题最好的方式了
因为它精确的定位到了文件级别的哈希
只有当这个文件发生了变化
才有可能去更新掉它的文件名
这个实际上是最适合我们去解决缓存问题的
另外如果说你觉得我们20位长度的
Hash太长的话
Webpack还允许我们去指定Hash的长度
我们可以在站位符里面通过冒号
然后跟一个数字的方式
来去指定我们哈希的长度
我们这通过冒号8
来去指定我们的哈希为8
总的来说我个人觉得
如果说是控制缓存的话
8位的Content Hash应该是最好的选择了
谢谢大家
谢谢大家
谢谢大家
谢谢大家
谢谢大家







# Vue.js 框架源码与进阶

# React 框架原理与实战

## React基础

### React介绍

![image-20220610150144884](%E7%AC%94%E8%AE%B0.assets/image-20220610150144884.png)

React是一个用于构建用户界面的JavaScript库，它只负责应用的视图层，帮助开发人员构建快速且交互式的Web应用程序。

React使用组件的方式构建用户界面。

### JSX 语法 

在React中使用JSX语法描述用户界面，它是一种JavaScript语法拓展。

在React代码执行之前，Babel会将JSX语法转换为标准的JavaScript API。

JSX语法就是一种语法糖，让开发人员使用更加舒服的代码构建用户界面。

#### 在JSX中使用表达式

```javascript
const user = {
    firstName:'liu',
    lastName:'cao'
}
function formatName(user){
    return user.firstName + '' + user.lastName;
}
const element = <h1>Hello,{formatName(user)}</h1>;
```

JSX本身其实也是一种表达式，将它赋值给变量，当做参数传入，作为返回值都可以。

```javascript
function formatName(user){
    if(user){
        return <h1>Hello,{formatName(user)}</h1>;
       }
   return <h1>Hello,Stranger</h1>;
}
```

#### 属性

如果属性值为字符串类型，需要加引号，属性名称推荐采用驼峰式命名法。

```react
const element = <div greeting="hello"></div>;
```

如果属性值为JavaScript表达式，属性值外面加大括号。

```react
const element = <img src={user.avatarUrl} />;
// 注意大括号外面不能加引号，JSX 会将引号当中的内容识别为字符串而不是表达式
```

#### JSX 单标记必须闭合

如果 JSX 是单标记，必须闭合，否则报错。

```react
const element = <img src={user.avatarUrl} />
const element = <input type="text"/>
```

#### className

为 JSX 标记添加类名需要使用 className，而不是class。

```react
const element = <img src={user.avatarUrl} className="rounded"/>;
```

#### JSX 自动展开数组

```react
const ary = [<p>哈哈</p>, <p>呵呵</p>, <p>嘿嘿</p>];
const element = (
	<div>{ary}</div>
);
// 解析后
/*
	<div>
		<p>哈哈</p>
		<p>呵呵</p>
		<p>嘿嘿</p>
	</div>
*/
```

#### 三元运算

```react
{ boolean ? <div>Hello React</div> : null }
{ boolean && <div>Hello React</div> }
```

#### 循环

```react
const persons = [{
  id: 1,
  name: '张三',
  age: 20
}, {
  id: 2,
  name: '李四',
  age: 15
}, {
  id: 3,
  name: '王五',
  age: 22
}]
```

```react
<ul>
  { persons.map(person => <li key={person.id}> {person.name} {person.age} </li>) }
</ul>
```

#### 事件

```react
{/* 第一个参数即是事件对象 不需传递 */}
<button onClick={this.eventHandler}>按钮</button>
{/* 需要传递事件对象 */}
<button onClick={e=>this.eventHandler('arg',e)}>按钮</button>
{/* 最后一个参数即是事件对象 不需传递 */}
<button onClick={this.eventHandler.bind(null, 'arg')}>按钮</button>
```

```react
constructor () {
  this.eventHandler = this.eventHandler.bind(this)
}
eventHandler () {}
<button onClick={this.eventHandler}>按钮</button>

// 这边如果使用箭头函数就不需要在constructor里面使用bind函数
eventHandler = () => {}
```

#### 样式

项目中选择css in js方案，使用less or sass ,有一个插件 classnames ，可以写多个classname

##### 行内样式

```react
class App extends Component {
  render() {
    const style = {width: 200, height: 200, backgroundColor: 'red'};
    return <div style={style}></div>
  }
}
```

##### 外链样式

```react
// Button.js
import styles from './Button.module.css';
class Button extends Component {
  render() {
    return <button className={styles.error}>Error Button</button>;
  }
}
```

##### 全局样式

```react
import './styles.css'
```



#### ref 属性

##### createRef

```react
class Input extends Component {
  constructor() {
    super()
    this.inputRef = React.createRef()
  }
  render() {
    return (
      <div>
        <input type="text" ref={this.inputRef} />
        <button onClick={() => console.log(this.inputRef.current)}> button </button>
      </div>
    )
  }
}
```

##### 函数参数

```react
class Input extends Component {
  render() {
    return (
      <div>
        <input type="text" ref={input => (this.input = input)} />
        <button onClick={() => console.log(this.input)}>button</button>
      </div>
    )
  }
}
```

##### ref 字符串

不推荐使用，在严格模式下报错。

```react
class Input extends Component {
  render() {
    return (
      <div>
        <input type="text" ref="username" />
        <button onClick={() => console.log(this.refs.username)}>button</button>
      </div>
    )
  }
}
```

##### 获取组件实例

点击按钮让 input 文本框获取焦点。

input 文本框以及让文本框获取焦点的方法定义在 Input 组件中，在 App 组件中引入 Input 组件，按钮定义在 App 组件中。

```react
// Input.js
class Input extends Component {
  constructor() {
    super()
    this.inputRef = React.createRef()
    this.focusInput = this.focusInput.bind(this)
  }
  focusInput() {
    this.inputRef.current.focus()
  }
  render() {
    return (
      <div>
        <input type="text" ref={this.inputRef} />
      </div>
    )
  }
}
```

```react
// App.js
class App extends Component {
  constructor() {
    super()
    this.InputComponentRef = React.createRef()
  }
  render() {
    return (
      <div className="App">
        <Input ref={this.InputComponentRef} />
        <button onClick={() => this.InputComponentRef.current.focusInput()}>button</button>
      </div>
    )
}
```

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/5.gif" />

- 



### 组件

####  什么是组件

React 是基于组件的方式进行用户界面开发的. 组件可以理解为对页面中某一块区域的封装。

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/2.png" width="70%"/>

#### 创建组件

##### d创建类组件

```react
import React, { Component } from 'react';
class App extends Component {
    render () {
        return <div>Hello, 我是类组件</div>
    }
}
```

##### 创建函数组件

```react
const Person = () => {
     return <div>Hello, 我是函数型组件</div>;
}
```

**注意事项**

1. 组件名称首字母必须大写，用以区分组件和普通标签。
2. jsx语法外层必须有一个根元素

#### 组件 props

##### props 传递数据

在调用组件时可以向组件内部传递数据，在组件中可以通过 props 对象获取外部传递进来的数据。

```react
<Person name="乔治" age="20"/>
<Person name="玛丽" age="10"/>
```

```react
// 类组件
class Person extends Component {
  render() {
    return (
      <div>
        <h3>姓名：{this.props.name}</h3>
        <h4>年龄：{this.props.age}</h4>
      </div>
    );
  }
}
```

```react
// 函数组件
const Person = props => {
  return (
    <div>
      <h3>姓名：{props.name}</h3>
      <h4>年龄：{props.age}</h4>
    </div>
  );
}
```

**注意：**

1. props 对象中存储的数据是只读的，不能在组件内部被修改。
2. 当 props 数据源中的数据被修改后，组件中的接收到的 props 数据会被同步更新。( 数据驱动DOM )

##### 设置 props 默认值

```react
class App extends Component {
    static defaultProps = {}
}
```

```react
function ThemedButton(props) {
}
ThemedButton.defaultProps = {
  theme: "secondary",
  label: "Button Text"
};
```

##### 组件 children

通过 props.children 属性可以获取到在调用组件时填充到组件标签内部的内容。

```react
<Person>组件内部的内容</Person>
```

```react
const Person = (props) => {
    return (
    	<div>{props.children}</div>
    );
}
```

##### 单向数据流

1. 在React中, 关于数据流动有一条原则, 就是单向数据流动, 自顶向下, 从父组件到子组件.

2. 单向数据流特性要求我们共享数据要放置在上层组件中.

3. 子组件通过调用父组件传递过来的方法更改数据.

4. 当数据发生更改时, React会重新渲染组件树.

5. 单向数据流使组件之间的数据流动变得可预测. 使得定位程序错误变得简单.

   <img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/3.png" />

#### 类组件状态 state

##### 定义组件状态

类组件除了能够从外部 (props) 接收状态数据以外还可以拥有自己的状态 (state)，此状态在组件内部可以被更新，状态更新 DOM 更新。

组件内部的状态数据被存储在组件类中的 state 属性中，state 属性值为对象类型，属性名称固定不可更改。

```react
class App extends Component {
  constructor () {
    super()
    this.state = {
      person: { name: '张三', age: 20 },
    }
  }
  render () {
    return (
      <div>
        {this.state.person.name}
        {this.state.person.age}
      </div>
    );
  }
}
```

##### 更改组件状态

state 状态对象中的数据不可直接更改，如果直接更改 DOM 不会被更新，要更改 state 状态数据需要使用 setState方法。

```react
class App extends Component {
  constructor () {
    this.state = {
      person: { name: '张三', age: 20 },
    }
    this.changePerson = this.changePerson.bind(this)
  }
	changePerson () {
    this.setState({
      person: {
        name: '李四',
        age: 15
      }
    })
  }
  render() {
    return (
      <div>
        {this.state.person.name}
        {this.state.person.age}
        <button onClick={this.changePerson}>按钮</button>
      </div>
    );
  }
}
```

##### 双向数据绑定

双向数据绑定是指，组件类中更新了状态，DOM 状态同步更新，DOM 更改了状态，组件类中同步更新。组件 <=> 视图。

要实现双向数据绑定需要用到表单元素和 state 状态对象。

```react
class App extends Component {
  constructor () {
    this.state = {
      name: "张三"
    }
    this.nameChanged = this.nameChanged.bind(this)
  }
  nameChanged (event) {
    this.setState({name: event.target.value});
  }
  render() {
    return (
      <div>
        <div>{this.state.name}</div>
        <Person name={this.state.name} changed={this.nameChanged}/>
      </div>
    )
  }
}
```

```react
const Person = props => {
	return <input type="text" value={props.name} onChange={props.changed}/>;
}
```

#### 类组件生命周期函数

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/4.jpg"/>



在组件完成更新之前需要做某种逻辑或者计算，就需要用到快照

```react
componentDidUpdate(prevProps, prevState, snapshot) {}
```

getSnapshotBeforeUpdate 方法会在组件完成更新之前执行，用于执行某种逻辑或计算，返回值可以在 componentDidUpdate 方法中的第三个参数中获取，就是说在组件更新之后可以拿到这个值再去做其他事情。

```react
getSnapshotBeforeUpdate(prevProps, prevState) {
  return 'snapshot'
}
```

#### Context 

通过 Context 可以跨层级传递数据

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-01-React%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/images/6.png" width="70%"/>

```react
// userContext.js
import React from "react"

const userContext = React.createContext("default value")
const UserProvider = userContext.Provider
const UserConsumer = userContext.Consumer

export { UserProvider, UserConsumer }
```

```react
// App.js
import { UserProvider } from "./userContext"
class App extends Component {
  render() {
    return (
      <UserProvider value="Hello React Context">
        <A />
      </UserProvider>
    )
  }
}
```

```react
// C.js
import { UserConsumer } from "./userContext"
// username 就是UserProvider传递过来的值
export class C extends Component {
  render() {
    return (
      <div>
        <UserConsumer>
          {username => {
            return <div>{username}</div>
          }}
        </UserConsumer>
      </div>
    )
  }
}
```

context 的另一种用法

```react
// userContext.js
export default userContext
```

```react
// C.js
import userContext from "./userContext"

export class C extends Component {
  static contextType = userContext
  render() {
    return (
      <div>
        {this.context}
      </div>
    )
  }
}
```

- 

### 表单

#### 受控表单

表单控件中的值由组件的 state 对象来管理，state对象中存储的值和表单控件中的值时同步状态的

```react
class App extends Component {
  constructor () {
    this.state = { username: "" }
    this.nameChanged = this.nameChanged.bind(this)
  }
  
  nameChanged (e) {
    this.setState({username: e.target.value})
  }
  render() {
    return (
      <form>
        <p>{this.state.username}</p>
        <input type="text" value={this.state.username} onChange={this.nameChanged}/>
      </form>
    )
  }
}
```

#### 非受控表单

表单元素的值由 DOM 元素本身管理。

```react
class App extends Component {
  constructor () {
    this.onSubmit = this.onSubmit.bind(this)
  }
  onSubmit(e) {
    console.log(this.username.value)
    e.preventDefault();
  }
  render(
    <form onSubmit={this.onSubmit}>
      <input type="text" ref={username => this.username = username}/>
    </form>
  )
}
```



### 路由

url地址与组件之间的对应关系，访问不同的url地址显示不同的组件。

下载：`npm install react-router-dom`



#### 路由基本使用

```react
// App.js
import React from 'react';
import { BrowserRouter as Router, Route, Link } from 'react-router-dom';
function Index() {
	return <div>首页</div>;
}
function News() {
	return <div>新闻</div>;
}
function App() {
  return (
    <Router>
      <div>
        <Link to="/index">首页</Link>
        <Link to="/news">新闻</Link>
      </div>
      <div>
        <Route path="/index" component={Index}/>
        <Route path="/news" component={News}/>
      </div>
    </Router>
  );
}
```

#### 5.1.2 路由嵌套

```react
function News(props) {
  return (
    <div>
      <div>
        <Link to={`${props.match.url}/company`}>公司新闻</Link>
        <Link to={`${props.match.url}/industry`}>行业新闻</Link>
      </div>
      <div>
        <Route path={`${props.match.path}/company`} component={CompanyNews} />
        <Route path={`${props.match.path}/industry`} component={IndustryNews}/>  
      </div>	
    </div>
  );
}

function CompanyNews() {
	return <div>公司新闻</div>
}
function IndustryNews() {
	return <div>行业新闻</div>
}
```

#### 5.1.3 路由传参

```react
import url from 'url';
class News extends Component {
  constructor(props) {
    super(props);
    this.state = {
      list: [{
        id: 1,
        title: '新闻1'
      }, {
        id: 2,
        title: '新闻2'
      }]
    }
  }
    
  render() {
    return (
      <div>
        <div>新闻列表组件</div>
        <ul>
          this.state.list.map((item, index) => {
            return (
              <li key={index}>
                <Link to={`/detail?id=${item.id}`}>{item.title}</Link>
              </li>
            );
          })
        </ul>
      </div>
    );
  }
}
class Detail extends Component {
  constructor(props) {
    super(props);
  }
	const { query } = url.parse(this.props.location.search, true);
	console.log(query); // {id: 1}
  render() {
    return <div>新闻详情</div>
  }
}
```

#### 路由重定向

```react
import { Redirect } from 'react-router-dom';

class Login extends Component {
  render() {
    if (this.state.isLogin) {
      return <Redirect to="/"/>
    }
  }
}
```



### 

## Virtual DOM 及Diff算法

### JSX 到底是什么

使用 React 就一定会写 JSX，JSX 到底是什么呢？它是一种 JavaScript 语法的扩展，React 使用它来描述用户界面长成什么样子。虽然它看起来非常像 HTML，但它确实是 JavaScript 。在 React 代码执行之前，Babel 会对将 JSX 编译为 React API.

```react
<div className="container">
  <h3>Hello React</h3>
  <p>React is great </p>
</div>
```

```react
React.createElement(
  "div",
  {
    className: "container"
  },
  React.createElement("h3", null, "Hello React"),
  React.createElement("p", null, "React is great")
);
```

从两种语法对比来看，JSX 语法的出现是为了让 React 开发人员编写用户界面代码更加轻松。

[Babel REPL](https://babeljs.io/repl)

React 代码执行之前，Babel 会对将 JSX 编译为 React API（JSX 会被 Babel 转换为 React.createElement 方法的调用）,使用上面链接，try it out 进行尝试，左边第一个是普通JSX变量，第二个是函数组件

![image-20220610162443238](%E7%AC%94%E8%AE%B0.assets/image-20220610162443238.png)

### DOM 操作问题

在现代 web 应用程序中使用 JavaScript 操作 DOM 是必不可少的，但遗憾的是它比其他大多数 JavaScript 操作要慢的多。

大多数 JavaScript 框架对于 DOM 的更新远远超过其必须进行的更新，从而使得这种缓慢操作变得更糟。

例如假设你有包含十个项目的列表，你仅仅更改了列表中的第一项，大多数 JavaScript 框架会重建整个列表，这比必要的工作要多十倍。

更新效率低下已经成为严重问题，为了解决这个问题，React 普及了一种叫做 Virtual DOM 的东西，Virtual DOM 出现的目的就是为了提高 JavaScript 操作 DOM 对象的效率。

### 什么是 Virtual DOM

在 React 中，每个 DOM 对象都有一个对应的 Virtual DOM 对象，它是 DOM 对象的 JavaScript 对象表现形式，其实就是使用 JavaScript 对象来描述 DOM 对象信息，比如 DOM 对象的类型是什么，它身上有哪些属性，它拥有哪些子元素。

可以把 Virtual DOM 对象理解为 DOM 对象的副本，但是它不能直接显示在屏幕上。

```react
<div className="container">
  <h3>Hello React</h3>
  <p>React is great </p>
</div>
```

```react
{
  type: "div",
  props: { className: "container" },
  children: [
    {
      type: "h3",
      props: null,
      children: [
        {
          type: "text",
          props: {
            textContent: "Hello React"
          }
        }
      ]
    },
    {
      type: "p",
      props: null,
      children: [
        {
          type: "text",
          props: {
            textContent: "React is great"
          }
        }
      ]
    }
  ]
}
```

### Virtual DOM 如何提升效率

精准找出发生变化的 DOM 对象，只更新发生变化的部分。

在 React 第一次创建 DOM 对象后，会为每个 DOM 对象创建其对应的 Virtual DOM 对象，在 DOM 对象发生更新之前，React 会先更新所有的 Virtual DOM 对象，然后 React 会将更新后的 Virtual DOM 和 更新前的 Virtual DOM 进行比较，从而找出发生变化的部分，React 会将发生变化的部分更新到真实的 DOM 对象中，React 仅更新必要更新的部分。

Virtual DOM 对象的更新和比较仅发生在内存中，不会在视图中渲染任何内容，所以这一部分的性能损耗成本是微不足道的。

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/1.png" style="margin: 20px 0;width: 80%"/>

```react
<div id="container">
	<p>Hello React</p>
</div>
```

```react
<div id="container">
	<p>Hello Angular</p>
</div>
```

```react
const before = {
  type: "div",
  props: { id: "container" },
  children: [
    {
      type: "p",
      props: null,
      children: [
        { type: "text", props: { textContent: "Hello React" } }
      ]
    }
  ]
}
```

```react
const after = {
  type: "div",
  props: { id: "container" },
  children: [
    {
      type: "p",
      props: null,
      children: [
        { type: "text", props: { textContent: "Hello Angular" } }
      ]
    }
  ]
}
```

###  创建 Virtual DOM

在 React 代码执行前，JSX 会被 Babel 转换为 React.createElement 方法的调用，在调用 createElement 方法时会传入元素的类型，元素的属性，以及元素的子元素，createElement 方法的返回值为构建好的 Virtual DOM 对象。

```react
{
  type: "div",
  props: null,
  children: [{type: "text", props: {textContent: "Hello"}}]
}
```

``` react
/**
 * 创建 Virtual DOM
 * @param {string} type 类型
 * @param {object | null} props 属性
 * @param  {createElement[]} children 子元素
 * @return {object} Virtual DOM
 */
function createElement (type, props, ...children) {
	return {
    type,
    props,
    children
  } 
}
```

从 createElement 方法的第三个参数开始就都是子元素了，在定义 createElement 方法时，通过 `...children` 将所有的子元素放置到 children 数组中。

```react
const virtualDOM = (
  <div className="container">
    <h1>你好 Tiny React</h1>
    <h2>(编码必杀技)</h2>
    <div>
      嵌套1 <div>嵌套 1.1</div>
    </div>
    <h3>(观察: 这个将会被改变)</h3>
    {2 == 1 && <div>如果2和1相等渲染当前内容</div>}
    {2 == 2 && <div>2</div>}
    <span>这是一段内容</span>
    <button onClick={() => alert("你好")}>点击我</button>
    <h3>这个将会被删除</h3>
    2, 3
  </div>
)
console.log(virtualDOM)
```

通过以上代码测试，发现返回的 Virtual DOM 存在一些问题，第一个问题是文本节点被直接放入到了数组中

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/2.png" width="50%"/>

而我们期望是文本节点应该是这样的

```react
children: [
  {
    type: "text",
    props: {
      textContent: "React is great"
    }
  }
]
```

通过以下代码对 Virtual DOM 进行改造，重新构建 Virtual DOM。

```javascript
// 将原有 children 拷贝一份 不要在原有数组上进行操作
const childElements = [].concat(...children).map(child => {
  // 判断 child 是否是对象类型
  if (child instanceof Object) {
    // 如果是 什么都不需要做 直接返回即可
    return child
  } else {
    // 如果不是对象就是文本 手动调用 createElement 方法将文本转换为 Virtual DOM
    return createElement("text", { textContent: child })
  }
})
return {
  type,
  props,
  children: childElements
}
```

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/3.png" width="50%"/>

通过观察返回的 Virtual DOM，文本节点已经被转化成了对象类型的 Virtual DOM，但是布尔值也被当做文本节点被转化了，在 JSX 中，如果 Virtual DOM 被转化为了布尔值或者null，是不应该被更新到真实 DOM 中的，所以接下来要做的事情就是清除 Virtual DOM 中的布尔值和null。

```react
// 由于 map 方法无法从数据中刨除元素, 所以此处将 map 方法更改为 reduce 方法
const childElements = [].concat(...children).reduce((result, child) => {
  // 判断子元素类型 刨除 null true false
  if (child != null && child != false && child != true) {
    if (child instanceof Object) {
      result.push(child)
    } else {
      result.push(createElement("text", { textContent: child }))
    }
  }
  // 将需要保留的 Virtual DOM 放入 result 数组
  return result
}, [])
```

在 React 组件中，可以通过 props.children 获取子元素，所以还需要将子元素存储在 props 对象中。

```javascript
return {
  type,
  props: Object.assign({ children: childElements }, props),
  children: childElements
}
```

###  渲染 Virtual DOM 对象为 DOM 对象

通过调用 render 方法可以将 Virtual DOM 对象更新为真实 DOM 对象。

在更新之前需要确定是否存在旧的 Virtual DOM，如果存在需要比对差异，如果不存在可以直接将 Virtual DOM 转换为 DOM 对象。 

目前先只考虑不存在旧的 Virtual DOM 的情况，就是说先直接将 Virtual DOM 对象更新为真实 DOM 对象。

```react
// render.js
export default function render(virtualDOM, container, oldDOM = container.firstChild) {
  // 在 diff 方法内部判断是否需要对比 对比也好 不对比也好 都在 diff 方法中进行操作  
  diff(virtualDOM, container, oldDOM)
}
```

```react
// diff.js
import mountElement from "./mountElement"

export default function diff(virtualDOM, container, oldDOM) {
  // 判断 oldDOM 是否存在
  if (!oldDOM) {
    // 如果不存在 不需要对比 直接将 Virtual DOM 转换为真实 DOM
    mountElement(virtualDOM, container)
  }
}
```

在进行 virtual DOM 转换之前还需要确定 Virtual DOM 的类 Component VS Native Element。

类型不同需要做不同的处理 如果是 Native Element 直接转换。

如果是组件 还需要得到组件实例对象 通过组件实例对象获取组件返回的 virtual DOM 然后再进行转换。

目前先只考虑 Native Element 的情况。

```javascript
babel 转化
<div className="container">
  <h3>Hello React</h3>
  <p>React is great </p>
</div>

function Demo (){
	return <div>Hello React</div>
}

// 转化后

"use strict";

/*#__PURE__*/
React.createElement("div", {
  className: "container"
}, /*#__PURE__*/React.createElement("h3", null, "Hello React"), /*#__PURE__*/React.createElement("p", null, "React is great "));

function Demo() {
  return /*#__PURE__*/React.createElement("div", null, "Hello React");
}
```



```react
// mountElement.js
import mountNativeElement from "./mountNativeElement"

export default function mountElement(virtualDOM, container) {
  // 通过调用 mountNativeElement 方法转换 Native Element
  mountNativeElement(virtualDOM, container)
}
```

```react
// mountNativeElement.js
import createDOMElement from "./createDOMElement"

export default function mountNativeElement(virtualDOM, container) {
  const newElement = createDOMElement(virtualDOM)
  container.appendChild(newElement)
}
```

```react
// createDOMElement.js
import mountElement from "./mountElement"
import updateElementNode from "./updateElementNode"

export default function createDOMElement(virtualDOM) {
  let newElement = null
  if (virtualDOM.type === "text") {
    // 创建文本节点
    newElement = document.createTextNode(virtualDOM.props.textContent)
  } else {
    // 创建元素节点
    newElement = document.createElement(virtualDOM.type)
    // 更新元素属性
    updateElementNode(newElement, virtualDOM)
  }
  // 递归渲染子节点
  virtualDOM.children.forEach(child => {
    // 因为不确定子元素是 NativeElement 还是 Component 所以调用 mountElement 方法进行确定
    mountElement(child, newElement)
  })
  return newElement
}

```

###  为元素节点添加属性

```react
// createDOMElement.js
// 看看节点类型是文本类型还是元素类型
if (virtualDOM.type === "text") {
  // 创建文本节点 设置节点内容
  newElement = document.createTextNode(virtualDOM.props.textContent)
} else {
  // 根据 Virtual DOM type 属性值创建 DOM 元素
  newElement = document.createElement(virtualDOM.type)
  // 为元素设置属性
  updateElementNode(newElement, virtualDOM)
}
```

```react
export default function updateElementNode(element, virtualDOM) {
  // 获取要解析的 VirtualDOM 对象中的属性对象
  const newProps = virtualDOM.props
  // 将属性对象中的属性名称放到一个数组中并循环数组
  Object.keys(newProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    // 考虑属性名称是否以 on 开头 如果是就表示是个事件属性 onClick -> click
    if (propName.slice(0, 2) === "on") {
      const eventName = propName.toLowerCase().slice(2)
      element.addEventListener(eventName, newPropsValue)
      // 如果属性名称是 value 或者 checked 需要通过 [] 的形式添加
    } else if (propName === "value" || propName === "checked") {
      element[propName] = newPropsValue
      // 刨除 children 因为它是子元素 不是属性
    } else if (propName !== "children") {
      // className 属性单独处理 不直接在元素上添加 class 属性是因为 class 是 JavaScript 中的关键字
      if (propName === "className") {
        element.setAttribute("class", newPropsValue)
      } else {
        // 普通属性
        element.setAttribute(propName, newPropsValue)
      }
    }
  })
}
```

### 渲染组件

####  函数组件

在渲染组件之前首先要明确的是，组件的 Virtual DOM 类型值为函数，函数组件和类组件都是这样的。

```react
// 原始组件
const Heart = () => <span>&hearts;</span>
```

```react
<Heart />
```

```react
// 组件的 Virtual DOM
{
  type: f function() {},
  props: {}
  children: []
}
```

在渲染组件时，要先将 Component 与 Native Element 区分开，如果是 Native Element 可以直接开始渲染，如果是组件，特别处理。

```react
// mountElement.js
export default function mountElement(virtualDOM, container) {
  // 无论是类组件还是函数组件 其实本质上都是函数 
  // 如果 Virtual DOM 的 type 属性值为函数 就说明当前这个 Virtual DOM 为组件
  if (isFunction(virtualDOM)) {
    // 如果是组件 调用 mountComponent 方法进行组件渲染
    mountComponent(virtualDOM, container)
  } else {
    mountNativeElement(virtualDOM, container)
  }
}

// Virtual DOM 是否为函数类型
export function isFunction(virtualDOM) {
  return virtualDOM && typeof virtualDOM.type === "function"
}
```

在 mountComponent 方法中再进行函数组件和类型的区分，然后再分别进行处理。

```react
// mountComponent.js
import mountNativeElement from "./mountNativeElement"

export default function mountComponent(virtualDOM, container) {
  // 存放组件调用后返回的 Virtual DOM 的容器
  let nextVirtualDOM = null
  // 区分函数型组件和类组件
  if (isFunctionalComponent(virtualDOM)) {
    // 函数组件 调用 buildFunctionalComponent 方法处理函数组件
    nextVirtualDOM = buildFunctionalComponent(virtualDOM)
  } else {
    // 类组件
  }
  // 判断得到的 Virtual Dom 是否是组件
  if (isFunction(nextVirtualDOM)) {
    // 如果是组件 继续调用 mountComponent 解剖组件
    mountComponent(nextVirtualDOM, container)
  } else {
    // 如果是 Navtive Element 就去渲染
    mountNativeElement(nextVirtualDOM, container)
  }
}

// Virtual DOM 是否为函数型组件
// 条件有两个: 1. Virtual DOM 的 type 属性值为函数 2. 函数的原型对象中不能有render方法
// 只有类组件的原型对象中有render方法 
export function isFunctionalComponent(virtualDOM) {
  const type = virtualDOM && virtualDOM.type
  return (
    type && isFunction(virtualDOM) && !(type.prototype && type.prototype.render)
  )
}

// 函数组件处理 
function buildFunctionalComponent(virtualDOM) {
  // 通过 Virtual DOM 中的 type 属性获取到组件函数并调用
  // 调用组件函数时将 Virtual DOM 对象中的 props 属性传递给组件函数 这样在组件中就可以通过 props 属性获取数据了
  // 组件返回要渲染的 Virtual DOM
  return virtualDOM && virtualDOM.type(virtualDOM.props || {})
}
```

####  类组件

类组件本身也是 Virtual DOM，可以通过 Virtual DOM 中的 type 属性值确定当前要渲染的组件是类组件还是函数组件。

在确定当前要渲染的组件为类组件以后，需要实例化类组件得到类组件实例对象，通过类组件实例对象调用类组件中的 render 方法，获取组件要渲染的 Virtual DOM。

类组件需要继承 Component 父类，子类需要通过 super 方法将自身的 props 属性传递给 Component 父类，父类会将 props 属性挂载为父类属性，子类继承了父类，自己本身也就自然拥有props属性了。这样做的好处是当 props 发生更新后，父类可以根据更新后的 props 帮助子类更新视图。

假设以下代码就是我们要渲染的类组件：

```react
class Alert extends TinyReact.Component {
  constructor(props) {
    // 将 props 传递给父类 子类继承父类的 props 子类自然就有 props 数据了
    // 否则 props 仅仅是 constructor 函数的参数而已
    // 将 props 传递给父类的好处是 当 props 发生更改时 父类可以帮助更新 props 更新组件视图
    super(props)
    this.state = {
      title: "default title"
    }
  }
  render() {
    return (
      <div>
        <h2>{this.state.title}</h2>
        <p>{this.props.message}</p>
      </div>
    )
  }
}

TinyReact.render(<Alert message="Hello React" />, root)
```

```react
// Component.js 父类 Component 实现
export default class Component {
  constructor(props) {
    this.props = props
  }
}
```

在 mountComponent 方法中通过调用 buildStatefulComponent 方法得到类组件要渲染的 Virtual DOM

```react
// mountComponent.js
export default function mountComponent(virtualDOM, container) {
  let nextVirtualDOM = null
  // 区分函数型组件和类组件
  if (isFunctionalComponent(virtualDOM)) {
    // 函数组件
    nextVirtualDOM = buildFunctionalComponent(virtualDOM)
  } else {
    // 类组件
    nextVirtualDOM = buildStatefulComponent(virtualDOM)
  }
  // 判断得到的 Virtual Dom 是否是组件
  if (isFunction(nextVirtualDOM)) {
    mountComponent(nextVirtualDOM, container)
  } else {
    mountNativeElement(nextVirtualDOM, container)
  }
}

// 处理类组件
function buildStatefulComponent(virtualDOM) {
  // 实例化类组件 得到类组件实例对象 并将 props 属性传递进类组件
  const component = new virtualDOM.type(virtualDOM.props)
  // 调用类组件中的render方法得到要渲染的 Virtual DOM
  const nextVirtualDOM = component.render()
  // 返回要渲染的 Virtual DOM
  return nextVirtualDOM
}
```

### Virtual DOM 比对

在进行 Virtual DOM 比对时，需要用到更新后的 Virtual DOM 和更新前的 Virtual DOM，更新后的 Virtual DOM 目前我们可以通过 render 方法进行传递，现在的问题是更新前的 Virtual DOM 要如何获取呢？

对于更新前的 Virtual DOM，对应的其实就是已经在页面中显示的真实 DOM 对象。既然是这样，那么我们在创建真实DOM对象时，就可以将 Virtual DOM 添加到真实 DOM 对象的属性中。在进行 Virtual DOM 对比之前，就可以通过真实 DOM 对象获取其对应的 Virtual DOM 对象了，其实就是通过render方法的第三个参数获取的，container.firstChild。

在创建真实 DOM 对象时为其添加对应的 Virtual DOM 对象

 ```react
// mountElement.js
import mountElement from "./mountElement"

export default function mountNativeElement(virtualDOM, container) {
  // 将 Virtual DOM 挂载到真实 DOM 对象的属性中 方便在对比时获取其 Virtual DOM
  newElement._virtualDOM = virtualDOM
}
 ```

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/8.png" width="80%" style="margin-bottom: 30px"/>

####  Virtual DOM 类型相同

Virtual DOM 类型相同，如果是元素节点，就对比元素节点属性是否发生变化，如果是文本节点就对比文本节点内容是否发生变化

要实现对比，需要先从已存在 DOM 对象中获取其对应的 Virtual DOM 对象。

```react
// diff.js
// 获取未更新前的 Virtual DOM
const oldVirtualDOM = oldDOM && oldDOM._virtualDOM
```

判断 oldVirtualDOM 是否存在， 如果存在则继续判断要对比的 Virtual DOM 类型是否相同，如果类型相同判断节点类型是否是文本，如果是文本节点对比，就调用 updateTextNode 方法，如果是元素节点对比就调用 setAttributeForElement 方法

```react
// diff.js
else if (oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
  if (virtualDOM.type === "text") {
    // 文本节点 对比文本内容是否发生变化
    updateTextNode(virtualDOM, oldVirtualDOM, oldDOM)
  } else {
    // 元素节点 对比元素属性是否发生变化
    setAttributeForElement(oldDOM, virtualDOM, oldVirtualDOM)
  }
```

updateTextNode 方法用于对比文本节点内容是否发生变化，如果发生变化则更新真实 DOM 对象中的内容，既然真实 DOM 对象发生了变化，还要将最新的 Virtual DOM 同步给真实 DOM 对象。

```react
function updateTextNode(virtualDOM, oldVirtualDOM, oldDOM) {
  // 如果文本节点内容不同
  if (virtualDOM.props.textContent !== oldVirtualDOM.props.textContent) {
    // 更新真实 DOM 对象中的内容
    oldDOM.textContent = virtualDOM.props.textContent
  }
  // 同步真实 DOM 对应的 Virtual DOM
  oldDOM._virtualDOM = virtualDOM
}
```

setAttributeForElement 方法用于设置/更新元素节点属性

思路是先分别获取更新后的和更新前的 Virtual DOM 中的 props 属性，循环新 Virtual DOM 中的 props 属性，通过对比看一下新 Virtual DOM 中的属性值是否发生了变化，如果发生变化 需要将变化的值更新到真实 DOM 对象中

再循环未更新前的 Virtual DOM 对象，通过对比看看新的 Virtual DOM 中是否有被删除的属性，如果存在删除的属性 需要将 DOM 对象中对应的属性也删除掉

```react
// updateNodeElement.js
export default function updateNodeElement(
  newElement,
  virtualDOM,
  oldVirtualDOM = {}
) {
  // 获取节点对应的属性对象
  const newProps = virtualDOM.props || {}
  const oldProps = oldVirtualDOM.props || {}
  Object.keys(newProps).forEach(propName => {
    // 获取属性值
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if (newPropsValue !== oldPropsValue) {
      // 判断属性是否是否事件属性 onClick -> click
      if (propName.slice(0, 2) === "on") {
        // 事件名称
        const eventName = propName.toLowerCase().slice(2)
        // 为元素添加事件
        newElement.addEventListener(eventName, newPropsValue)
        // 删除原有的事件的事件处理函数
        if (oldPropsValue) {
          newElement.removeEventListener(eventName, oldPropsValue)
        }
      } else if (propName === "value" || propName === "checked") {
        newElement[propName] = newPropsValue
      } else if (propName !== "children") {
        if (propName === "className") {
          newElement.setAttribute("class", newPropsValue)
        } else {
          newElement.setAttribute(propName, newPropsValue)
        }
      }
    }
  })
  // 判断属性被删除的情况
  Object.keys(oldProps).forEach(propName => {
    const newPropsValue = newProps[propName]
    const oldPropsValue = oldProps[propName]
    if (!newPropsValue) {
      // 属性被删除了
      if (propName.slice(0, 2) === "on") {
        const eventName = propName.toLowerCase().slice(2)
        newElement.removeEventListener(eventName, oldPropsValue)
      } else if (propName !== "children") {
        newElement.removeAttribute(propName)
      }
    }
  })
}
```

以上对比的仅仅是最上层元素，上层元素对比完成以后还需要递归对比子元素

```react
else if (oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
    // 递归对比 Virtual DOM 的子元素
    virtualDOM.children.forEach((child, i) => {
      diff(child, oldDOM, oldDOM.childNodes[i])
    })
  }
```

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/7.png"/>

####  Virtual DOM 类型不同

当对比的元素节点类型不同时，就不需要继续对比了，直接使用新的 Virtual DOM 创建 DOM 对象，用新的 DOM 对象直接替换旧的 DOM 对象。当前这种情况要将组件刨除，组件要被单独处理。

```react
// diff.js
else if (
  // 如果 Virtual DOM 类型不一样
  virtualDOM.type !== oldVirtualDOM.type &&
  // 并且 Virtual DOM 不是组件 因为组件要单独进行处理
  typeof virtualDOM.type !== "function"
) {
  // 根据 Virtual DOM 创建真实 DOM 元素
  const newDOMElement = createDOMElement(virtualDOM)
  // 用创建出来的真实 DOM 元素 替换旧的 DOM 元素
  oldDOM.parentNode.replaceChild(newDOMElement, oldDOM)
} 
```

####  删除节点

删除节点发生在节点更新以后并且发生在同一个父节点下的所有子节点身上。

在节点更新完成以后，如果旧节点对象的数量多于新 VirtualDOM 节点的数量，就说明有节点需要被删除。

<img src="../../../../react-test/04-01/04-01-study-materials/handouts/04-01-02-VirtualDOM/Virtual%20DOM%20%E5%8F%8A%20Diff%20%E7%AE%97%E6%B3%95/images/5.png" width="40%" align="left"/>

```react
// 获取就节点的数量
let oldChildNodes = oldDOM.childNodes
// 如果旧节点的数量多于要渲染的新节点的长度
if (oldChildNodes.length > virtualDOM.children.length) {
  for (
    let i = oldChildNodes.length - 1;
    i > virtualDOM.children.length - 1;
    i--
  ) {
    oldDOM.removeChild(oldChildNodes[i])
  }
}
```

####  类组件状态更新

以下代码是要更新状态的类组件，在类组件的 state 对象中有默认的 title 状态，点击 change title 按钮调用 handleChange 方法，在 handleChange 方法中调用 this.setState 方法更改 title 的状态值。

```react
class Alert extends TinyReact.Component {
  constructor(props) {
    super(props)
    this.state = {
      title: "default title"
    }
    // 更改 handleChange 方法中的 this 指向 让 this 指向类实例对象
    this.handleChange = this.handleChange.bind(this)
  }
  handleChange() {
    // 调用父类中的 setState 方法更改状态
    this.setState({
      title: "changed title"
    })
  }
  render() {
    return (
      <div>
        <h2>{this.state.title}</h2>
        <p>{this.props.message}</p>
        <button onClick={this.handleChange}>change title</button>
      </div>
    )
  }
}
```

setState 方法是定义在父类 Component 中的，该方法的作用是更改子类的 state，产生一个全新的 state 对象。

```react
// Component.js
export default class Component {
  constructor(props) {
    this.props = props
  }
  setState (state) {
    // setState 方法被子类调用 此处this指向子类实例对象
    // 所以改变的是子类的 state 对象
    this.state = Object.assign({}, this.state, state)
  }
}
```

现在子类已经可以调用父类的 setState 方法更改状态值了，当组件的 state 对象发生更改时，要调用 render 方法更新组件视图。

在更新组件之前，要使用更新的 Virtual DOM 对象和未更新的 Virtual DOM 进行对比找出更新的部分，达到 DOM 最小化操作的目的。

在 setState 方法中可以通过调用 this.render 方法获取更新后的 Virtual DOM，由于 setState 方法被子类调用，this 指向子类，所以此处调用的是子类的 render 方法。

```react
// Component.js
setState(state) {
  // setState 方法被子类调用 此处this指向子类
  // 所以改变的是子类的 state
  this.state = Object.assign({}, this.state, state)
  // 通过调用 render 方法获取最新的 Virtual DOM
  let virtualDOM = this.render()
}
```

要实现对比，还需要获取未更新前的 Virtual DOM，按照之前的经验，我们可以从 DOM 对象中获取其对应的 Virtual  DOM 对象，未更新前的 DOM 对象实际上就是现在在页面中显示的 DOM 对象，我们只要能获取到这个 DOM 对象就可以获取到其对应的 Virtual DOM 对象了。

页面中的 DOM 对象要怎样获取呢？页面中的 DOM 对象是通过 mountNativeElement 方法挂载到页面中的，所以我们只需要在这个方法中调用 Component 类中的方法就可以将 DOM 对象保存在 Component 类中了。在子类调用 setState 方法的时候，在 setState 方法中再调用另一个获取 DOM 对象的方法就可以获取到之前保存的 DOM 对象了。

```react
// Component.js
// 保存 DOM 对象的方法
setDOM(dom) {
  this._dom = dom
}
// 获取 DOM 对象的方法
getDOM() {
  return this._dom
}
```

接下来我们要研究一下在 mountNativeElement 方法中如何才能调用到 setDOM 方法，要调用 setDOM 方法，必须要得到类的实例对象，所以目前的问题就是如何在 mountNativeElement 方法中得到类的实例对象，这个类指的不是Component类，因为我们在代码中并不是直接实例化的Component类，而是实例化的它的子类，由于子类继承了父类，所以在子类的实例对象中也是可以调用到 setDOM 方法的。

mountNativeElement 方法接收最新的 Virtual DOM 对象，如果这个 Virtual DOM 对象是类组件产生的，在产生这个 Virtual DOM 对象时一定会先得到这个类的实例对象，然后再调用实例对象下面的 render 方法进行获取。我们可以在那个时候将类组件实例对象添加到 Virtual DOM 对象的属性中，而这个 Virtual DOM 对象最终会传递给 mountNativeElement  方法，这样我们就可以在 mountNativeElement 方法中获取到组件的实例对象了，既然类组件的实例对象获取到了，我们就可以调用 setDOM 方法了。

在 buildClassComponent 方法中为 Virtual DOM 对象添加 component 属性， 值为类组件的实例对象。

```react
function buildClassComponent(virtualDOM) {
  const component = new virtualDOM.type(virtualDOM.props)
  const nextVirtualDOM = component.render()
  nextVirtualDOM.component = component
  return nextVirtualDOM
}
```

在 mountNativeElement 方法中获取组件实例对象，通过实例调用调用 setDOM 方法保存 DOM 对象，方便在对比时通过它获取它的 Virtual DOM 对象

```react
export default function mountNativeElement(virtualDOM, container) {
  // 获取组件实例对象
  const component = virtualDOM.component
  // 如果组件实例对象存在
  if (component) {
    // 保存 DOM 对象
    component.setDOM(newElement)
  }
}
```

接下来在 setState 方法中就可以调用 getDOM 方法获取 DOM 对象了

```react
setState(state) {
  this.state = Object.assign({}, this.state, state)
  let virtualDOM = this.render()
  // 获取页面中正在显示的 DOM 对象 通过它可以获取其对象的 Virtual DOM 对象
  let oldDOM = this.getDOM()
}
```

现在更新前的 Virtual DOM 对象和更新后的 Virtual DOM 对象就都已经获取到了，接下来还要获取到真实 DOM 对象父级容器对象，因为在调用 diff 方法进行对比的时候需要用到

```react
setState(state) {
  this.state = Object.assign({}, this.state, state)
  let virtualDOM = this.render()
  let oldDOM = this.getDOM()
  // 获取真实 DOM 对象父级容器对象
  let container = oldDOM.parentNode
}
```

接下来就可以调用 diff 方法进行比对了，比对后会按照我们之前写好的逻辑进行 DOM 对象更新，我们就可以在页面中看到效果了

```react
setState(state) {
    this.state = Object.assign({}, this.state, state)
    let virtualDOM = this.render()
    let oldDOM = this.getDOM()
    let container = oldDOM.parentNode
    // 比对
    diff(virtualDOM, container, oldDOM)
  }
```

#### 组件更新

在 diff 方法中判断要更新的 Virtual DOM 是否是组件。

如果是组件再判断要更新的组件和未更新前的组件是否是同一个组件，如果不是同一个组件就不需要做组件更新操作，直接调用 mountElement 方法将组件返回的 Virtual DOM 添加到页面中。

如果是同一个组件，就执行更新组件操作，其实就是将最新的 props 传递到组件中，再调用组件的render方法获取组件返回的最新的 Virtual DOM 对象，再将 Virtual DOM 对象传递给 diff 方法，让 diff 方法找出差异，从而将差异更新到真实 DOM 对象中。

在更新组件的过程中还要在不同阶段调用其不同的组件生命周期函数。

在 diff 方法中判断要更新的 Virtual DOM 是否是组件，如果是组件又分为多种情况，新增 diffComponent 方法进行处理

```react
else if (typeof virtualDOM.type === "function") {
  // 要更新的是组件
  // 1) 组件本身的 virtualDOM 对象 通过它可以获取到组件最新的 props
  // 2) 要更新的组件的实例对象 通过它可以调用组件的生命周期函数 可以更新组件的 props 属性 可以获取到组件返回的最新的 Virtual DOM
  // 3) 要更新的 DOM 象 在更新组件时 需要在已有DOM对象的身上进行修改 实现DOM最小化操作 获取旧的 Virtual DOM 对象
  // 4) 如果要更新的组件和旧组件不是同一个组件 要直接将组件返回的 Virtual DOM 显示在页面中 此时需要 container 做为父级容器
  diffComponent(virtualDOM, oldComponent, oldDOM, container)
}
```

在 diffComponent 方法中判断要更新的组件是未更新前的组件是否是同一个组件

```react
// diffComponent.js
export default function diffComponent(virtualDOM, oldComponent, oldDOM, container) {
  // 判断要更新的组件和未更新的组件是否是同一个组件 只需要确定两者使用的是否是同一个构造函数就可以了
  if (isSameComponent(virtualDOM, oldComponent)) {
    // 属同一个组件 做组件更新  
  } else {
    // 不是同一个组件 直接将组件内容显示在页面中
  }
}
// virtualDOM.type 更新后的组件构造函数
// oldComponent.constructor 未更新前的组件构造函数
// 两者等价就表示是同一组件
function isSameComponent(virtualDOM, oldComponent) {
  return oldComponent && virtualDOM.type === oldComponent.constructor
}
```

如果不是同一个组件的话，就不需要执行更新组件的操作，直接将组件内容显示在页面中，替换原有内容

```react
// diffComponent.js
else {
  // 不是同一个组件 直接将组件内容显示在页面中
  // 这里为 mountElement 方法新增了一个参数 oldDOM 
  // 作用是在将 DOM 对象插入到页面前 将页面中已存在的 DOM 对象删除 否则无论是旧DOM对象还是新DOM对象都会显示在页面中
  mountElement(virtualDOM, container, oldDOM)
}
```

在 mountNativeElement 方法中删除原有的旧 DOM 对象

```javascript
// mountNavtiveElement.js
export default function mountNativeElement(virtualDOM, container, oldDOM) {
 // 如果旧的DOM对象存在 删除
  if (oldDOM) {
    unmount(oldDOM)
  }
}
```

```react
// unmount.js
export default function unmount(node) {
  node.remove()
}
```

如果是同一个组件的话，需要执行组件更新操作，需要调用组件生命周期函数

先在 Component 类中添加生命周期函数，子类要使用的话直接覆盖就可以

```react
// Component.js
export default class Component {
  // 生命周期函数
  componentWillMount() {}
  componentDidMount() {}
  componentWillReceiveProps(nextProps) {}
  shouldComponentUpdate(nextProps, nextState) {
    return nextProps != this.props || nextState != this.state
  }
  componentWillUpdate(nextProps, nextState) {}
  componentDidUpdate(prevProps, preState) {}
  componentWillUnmount() {}
}
```

新建 updateComponent 方法用于更新组件操作，并在 if 成立后调用

```react
// diffComponent.js
if (isSameComponent(virtualDOM, oldComponent)) {
  // 属同一个组件 做组件更新
  updateComponent(virtualDOM, oldComponent, oldDOM, container)
}
```

在 updateComponent 方法中调用组件的生命周期函数，更新组件获取最新 Virtual DOM，最终调用 diff 方法进行更新

```react
import diff from "./diff"

export default function updateComponent(
  virtualDOM,
  oldComponent,
  oldDOM,
  container
) {
  // 生命周期函数
  oldComponent.componentWillReceiveProps(virtualDOM.props)
  if (
    // 调用 shouldComponentUpdate 生命周期函数判断是否要执行更新操作
    oldComponent.shouldComponentUpdate(virtualDOM.props)
  ) {
    // 将未更新的 props 保存一份
    let prevProps = oldComponent.props
    // 生命周期函数
    oldComponent.componentWillUpdate(virtualDOM.props)
    // 更新组件的 props 属性 updateProps 方法定义在 Component 类型
    oldComponent.updateProps(virtualDOM.props)
    // 因为组件的 props 已经更新 所以调用 render 方法获取最新的 Virtual DOM
    const nextVirtualDOM = oldComponent.render()
    // 将组件实例对象挂载到 Virtual DOM 身上
    nextVirtualDOM.component = oldComponent
    // 调用diff方法更新视图
    diff(nextVirtualDOM, container, oldDOM)
    // 生命周期函数
    oldComponent.componentDidUpdate(prevProps)
  }
}
```

```react
// Component.js
export default class Component {
  updateProps(props) {
    this.props = props
  }
}
```

###  ref 属性

为节点添加 ref 属性可以获取到这个节点的 DOM 对象，比如在 DemoRef 类中，为 input 元素添加了 ref 属性，目的是获取 input DOM 元素对象，在点击按钮时获取用户在文本框中输入的内容

```react
class DemoRef extends TinyReact.Component {
  handle() {
    let value = this.input.value
    console.log(value)
  }
  render() {
    return (
      <div>
        <input type="text" ref={input => (this.input = input)} />
        <button onClick={this.handle.bind(this)}>按钮</button>
      </div>
    )
  }
}
```

实现思路是在创建节点时判断其 Virtual DOM 对象中是否有 ref 属性，如果有就调用 ref 属性中所存储的方法并且将创建出来的DOM对象作为参数传递给 ref 方法，这样在渲染组件节点的时候就可以拿到元素对象并将元素对象存储为组件属性了。

```react
// createDOMElement.js
if (virtualDOM.props && virtualDOM.props.ref) {
  virtualDOM.props.ref(newElement)
}
```

在类组件的身上也可以添加 ref 属性，目的是获取组件的实例对象，比如下列代码中，在 DemoRef 组件中渲染了 Alert 组件，在 Alert 组件中添加了 ref 属性，目的是在 DemoRef 组件中获取 Alert 组件实例对象。

```react
class DemoRef extends TinyReact.Component {
  handle() {
    let value = this.input.value
    console.log(value)
    console.log(this.alert)
  }
  componentDidMount() {
    console.log("componentDidMount")
  }
  render() {
    return (
      <div>
        <input type="text" ref={input => (this.input = input)} />
        <button onClick={this.handle.bind(this)}>按钮</button>
        <Alert ref={alert => (this.alert = alert)} />
      </div>
    )
  }
}
```

实现思路是在 mountComponent 方法中，如果判断了当前处理的是类组件，就通过类组件返回的 Virtual DOM 对象中获取组件实例对象，判断组件实例对象中的 props 属性中是否存在 ref 属性，如果存在就调用 ref 方法并且将组件实例对象传递给 ref 方法。

```react
// mountComponent.js
let component = null
  if (isFunctionalComponent(virtualDOM)) {}
	else {
    // 类组件
    nextVirtualDOM = buildStatefulComponent(virtualDOM)
    // 获取组件实例对象
    component = nextVirtualDOM.component
  }
	// 如果组件实例对象存在的话
	if (component) {
   	// 判断组件实例对象身上是否有 props 属性 props 属性中是否有 ref 属性
    if (component.props && component.props.ref) {
      // 调用 ref 方法并传递组件实例对象
      component.props.ref(component)
    }
  }

```

代码走到这，顺便处理一下组件挂载完成的生命周期函数

```react
// 如果组件实例对象存在的话
if (component) {
  component.componentDidMount()
}
```

### key 属性

在 React 中，渲染列表数据时通常会在被渲染的列表元素上添加 key 属性，key 属性就是数据的唯一标识，帮助 React 识别哪些数据被修改或者删除了，从而达到 DOM 最小化操作的目的。

key 属性不需要全局唯一，但是在同一个父节点下的兄弟节点之间必须是唯一的。

也就是说，在比对同一个父节点下类型相同的子节点时需要用到 key 属性。

####  节点对比

实现思路是在两个元素进行比对时，如果类型相同，就循环旧的 DOM 对象的子元素，查看其身上是否有key 属性，如果有就将这个子元素的 DOM 对象存储在一个 JavaScript 对象中，接着循环要渲染的 Virtual DOM 对象的子元素，在循环过程中获取到这个子元素的 key 属性，然后使用这个 key 属性到 JavaScript 对象中查找 DOM 对象，如果能够找到就说明这个元素是已经存在的，是不需要重新渲染的。如果通过key属性找不到这个元素，就说明这个元素是新增的是需要渲染的。

```react
// diff.js
else if (oldVirtualDOM && virtualDOM.type === oldVirtualDOM.type) {
  // 将拥有key属性的元素放入 keyedElements 对象中
  let keyedElements = {}
  for (let i = 0, len = oldDOM.childNodes.length; i < len; i++) {
    let domElement = oldDOM.childNodes[i]
    if (domElement.nodeType === 1) {
      let key = domElement.getAttribute("key")
      if (key) {
        keyedElements[key] = domElement
      }
    }
  }
}
```

```react
// diff.js
// 看一看是否有找到了拥有 key 属性的元素
let hasNoKey = Object.keys(keyedElements).length === 0

// 如果没有找到拥有 key 属性的元素 就按照索引进行比较
if (hasNoKey) {
  // 递归对比 Virtual DOM 的子元素
  virtualDOM.children.forEach((child, i) => {
    diff(child, oldDOM, oldDOM.childNodes[i])
  })
} else {
  // 使用key属性进行元素比较
  virtualDOM.children.forEach((child, i) => {
    // 获取要进行比对的元素的 key 属性
    let key = child.props.key
    // 如果 key 属性存在
    if (key) {
      // 到已存在的 DOM 元素对象中查找对应的 DOM 元素
      let domElement = keyedElements[key]
      // 如果找到元素就说明该元素已经存在 不需要重新渲染
      if (domElement) {
        // 虽然 DOM 元素不需要重新渲染 但是不能确定元素的位置就一定没有发生变化
        // 所以还要查看一下元素的位置
        // 看一下 oldDOM 对应的(i)子元素和 domElement 是否是同一个元素 如果不是就说明元素位置发生了变化
        if (oldDOM.childNodes[i] && oldDOM.childNodes[i] !== domElement) {
          // 元素位置发生了变化
          // 将 domElement 插入到当前元素位置的前面 oldDOM.childNodes[i] 就是当前位置
          // domElement 就被放入了当前位置
          oldDOM.insertBefore(domElement, oldDOM.childNodes[i])
        }
      } else {
        mountElement(child, oldDOM, oldDOM.childNodes[i])
      }
    }
  })
}
```

```react
// mountNativeElement.js
if (oldDOM) {
  container.insertBefore(newElement, oldDOM)
} else {
  // 将转换之后的DOM对象放置在页面中
  container.appendChild(newElement)
}
```

#### 节点卸载

在比对节点的过程中，如果旧节点的数量多于要渲染的新节点的数量就说明有节点被删除了，继续判断 keyedElements 对象中是否有元素，如果没有就使用索引方式删除，如果有就要使用 key 属性比对的方式进行删除。

实现思路是循环旧节点，在循环旧节点的过程中获取旧节点对应的 key 属性，然后根据 key 属性在新节点中查找这个旧节点，如果找到就说明这个节点没有被删除，如果没有找到，就说明节点被删除了，调用卸载节点的方法卸载节点即可。

```react
// 获取就节点的数量
let oldChildNodes = oldDOM.childNodes
// 如果旧节点的数量多于要渲染的新节点的长度
if (oldChildNodes.length > virtualDOM.children.length) {
  if (hasNoKey) {
    for (
      let i = oldChildNodes.length - 1;
      i >= virtualDOM.children.length;
      i--
    ) {
      oldDOM.removeChild(oldChildNodes[i])
    }
  } else {
    for (let i = 0; i < oldChildNodes.length; i++) {
      let oldChild = oldChildNodes[i]
      let oldChildKey = oldChild._virtualDOM.props.key
      let found = false
      for (let n = 0; n < virtualDOM.children.length; n++) {
        if (oldChildKey === virtualDOM.children[n].props.key) {
          found = true
          break
        }
      }
      if (!found) {
        unmount(oldChild)
        i--
      }
    }
  }
}
```

卸载节点并不是说将节点直接删除就可以了，还需要考虑以下几种情况

1. 如果要删除的节点是文本节点的话可以直接删除
2. 如果要删除的节点由组件生成，需要调用组件卸载生命周期函数
3. 如果要删除的节点中包含了其他组件生成的节点，需要调用其他组件的卸载生命周期函数
4. 如果要删除的节点身上有 ref 属性，还需要删除通过 ref 属性传递给组件的 DOM 节点对象
5. 如果要删除的节点身上有事件，需要删除事件对应的事件处理函数

```react
export default function unmount(dom) {
  // 获取节点对应的 virtualDOM 对象
  const virtualDOM = dom._virtualDOM
  // 如果要删除的节点时文本
  if (virtualDOM.type === "text") {
    // 直接删除节点
    dom.remove()
    // 阻止程序向下运行
    return
  }
  // 查看节点是否由组件生成
  let component = virtualDOM.component
  // 如果由组件生成
  if (component) {
    // 调用组件卸载生命周期函数
    component.componentWillUnmount()
  }
  
  // 如果节点具有 ref 属性 通过再次调用 ref 方法 将传递给组件的DOM对象删除
  if (virtualDOM.props && virtualDOM.props.ref) {
    virtualDOM.props.ref(null)
  }

  // 事件处理
  Object.keys(virtualDOM.props).forEach(propName => {
    if (propName.slice(0, 2) === "on") {
      const eventName = propName.toLowerCase().slice(2)
      const eventHandler = virtualDOM.props[propName]
      dom.removeEventListener(eventName, eventHandler)
    }
  })
	
  // 递归删除子节点
  if (dom.childNodes.length > 0) {
    for (let i = 0; i < dom.childNodes.length; i++) {
      unmount(dom.childNodes[i])
      i--
    }
  }
  	
  dom.remove()
}

```



# Node.js 全栈开发

# 泛客户端开发

# 商业技术解决方案与高阶技术

# 

